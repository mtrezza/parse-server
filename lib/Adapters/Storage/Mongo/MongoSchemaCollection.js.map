{"version":3,"sources":["../../../../src/Adapters/Storage/Mongo/MongoSchemaCollection.js"],"names":["mongoFieldToParseSchemaField","type","targetClass","slice","startsWith","length","nonFieldSchemaKeys","mongoSchemaFieldsToParseSchemaFields","schema","fieldNames","Object","keys","filter","key","indexOf","response","reduce","obj","fieldName","_metadata","fields_options","assign","ACL","createdAt","updatedAt","objectId","emptyCLPS","freeze","find","count","get","create","update","delete","addField","protectedFields","defaultCLPS","mongoSchemaToParseSchema","mongoSchema","clps","indexes","class_permissions","className","_id","fields","classLevelPermissions","_mongoSchemaQueryFromNameQuery","name","query","object","forEach","parseFieldTypeToMongoFieldType","MongoSchemaCollection","constructor","collection","_collection","_fetchAllSchemasFrom_SCHEMA","_rawFind","then","schemas","map","_fetchOneSchemaFrom_SCHEMA","limit","results","undefined","findAndDeleteSchema","_mongoCollection","findOneAndDelete","insertSchema","insertOne","result","ops","catch","error","code","Parse","Error","DUPLICATE_VALUE","updateSchema","updateOne","upsertSchema","upsertOne","addFieldIfNotExists","fieldType","some","existingField","INCORRECT_TYPE","fieldOptions","$exists","$set","_TESTmongoSchemaToParseSchema"],"mappings":"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","sourcesContent":["import MongoCollection from './MongoCollection';\nimport Parse from 'parse/node';\n\nfunction mongoFieldToParseSchemaField(type) {\n  if (type[0] === '*') {\n    return {\n      type: 'Pointer',\n      targetClass: type.slice(1),\n    };\n  }\n  if (type.startsWith('relation<')) {\n    return {\n      type: 'Relation',\n      targetClass: type.slice('relation<'.length, type.length - 1),\n    };\n  }\n  switch (type) {\n    case 'number':\n      return { type: 'Number' };\n    case 'string':\n      return { type: 'String' };\n    case 'boolean':\n      return { type: 'Boolean' };\n    case 'date':\n      return { type: 'Date' };\n    case 'map':\n    case 'object':\n      return { type: 'Object' };\n    case 'array':\n      return { type: 'Array' };\n    case 'geopoint':\n      return { type: 'GeoPoint' };\n    case 'file':\n      return { type: 'File' };\n    case 'bytes':\n      return { type: 'Bytes' };\n    case 'polygon':\n      return { type: 'Polygon' };\n  }\n}\n\nconst nonFieldSchemaKeys = ['_id', '_metadata', '_client_permissions'];\nfunction mongoSchemaFieldsToParseSchemaFields(schema) {\n  var fieldNames = Object.keys(schema).filter(key => nonFieldSchemaKeys.indexOf(key) === -1);\n  var response = fieldNames.reduce((obj, fieldName) => {\n    obj[fieldName] = mongoFieldToParseSchemaField(schema[fieldName]);\n    if (\n      schema._metadata &&\n      schema._metadata.fields_options &&\n      schema._metadata.fields_options[fieldName]\n    ) {\n      obj[fieldName] = Object.assign(\n        {},\n        obj[fieldName],\n        schema._metadata.fields_options[fieldName]\n      );\n    }\n    return obj;\n  }, {});\n  response.ACL = { type: 'ACL' };\n  response.createdAt = { type: 'Date' };\n  response.updatedAt = { type: 'Date' };\n  response.objectId = { type: 'String' };\n  return response;\n}\n\nconst emptyCLPS = Object.freeze({\n  find: {},\n  count: {},\n  get: {},\n  create: {},\n  update: {},\n  delete: {},\n  addField: {},\n  protectedFields: {},\n});\n\nconst defaultCLPS = Object.freeze({\n  find: { '*': true },\n  count: { '*': true },\n  get: { '*': true },\n  create: { '*': true },\n  update: { '*': true },\n  delete: { '*': true },\n  addField: { '*': true },\n  protectedFields: { '*': [] },\n});\n\nfunction mongoSchemaToParseSchema(mongoSchema) {\n  let clps = defaultCLPS;\n  let indexes = {};\n  if (mongoSchema._metadata) {\n    if (mongoSchema._metadata.class_permissions) {\n      clps = { ...emptyCLPS, ...mongoSchema._metadata.class_permissions };\n    }\n    if (mongoSchema._metadata.indexes) {\n      indexes = { ...mongoSchema._metadata.indexes };\n    }\n  }\n  return {\n    className: mongoSchema._id,\n    fields: mongoSchemaFieldsToParseSchemaFields(mongoSchema),\n    classLevelPermissions: clps,\n    indexes: indexes,\n  };\n}\n\nfunction _mongoSchemaQueryFromNameQuery(name: string, query) {\n  const object = { _id: name };\n  if (query) {\n    Object.keys(query).forEach(key => {\n      object[key] = query[key];\n    });\n  }\n  return object;\n}\n\n// Returns a type suitable for inserting into mongo _SCHEMA collection.\n// Does no validation. That is expected to be done in Parse Server.\nfunction parseFieldTypeToMongoFieldType({ type, targetClass }) {\n  switch (type) {\n    case 'Pointer':\n      return `*${targetClass}`;\n    case 'Relation':\n      return `relation<${targetClass}>`;\n    case 'Number':\n      return 'number';\n    case 'String':\n      return 'string';\n    case 'Boolean':\n      return 'boolean';\n    case 'Date':\n      return 'date';\n    case 'Object':\n      return 'object';\n    case 'Array':\n      return 'array';\n    case 'GeoPoint':\n      return 'geopoint';\n    case 'File':\n      return 'file';\n    case 'Bytes':\n      return 'bytes';\n    case 'Polygon':\n      return 'polygon';\n  }\n}\n\nclass MongoSchemaCollection {\n  _collection: MongoCollection;\n\n  constructor(collection: MongoCollection) {\n    this._collection = collection;\n  }\n\n  _fetchAllSchemasFrom_SCHEMA() {\n    return this._collection._rawFind({}).then(schemas => schemas.map(mongoSchemaToParseSchema));\n  }\n\n  _fetchOneSchemaFrom_SCHEMA(name: string) {\n    return this._collection\n      ._rawFind(_mongoSchemaQueryFromNameQuery(name), { limit: 1 })\n      .then(results => {\n        if (results.length === 1) {\n          return mongoSchemaToParseSchema(results[0]);\n        } else {\n          throw undefined;\n        }\n      });\n  }\n\n  // Atomically find and delete an object based on query.\n  findAndDeleteSchema(name: string) {\n    return this._collection._mongoCollection.findOneAndDelete(_mongoSchemaQueryFromNameQuery(name));\n  }\n\n  insertSchema(schema: any) {\n    return this._collection\n      .insertOne(schema)\n      .then(result => mongoSchemaToParseSchema(result.ops[0]))\n      .catch(error => {\n        if (error.code === 11000) {\n          //Mongo's duplicate key error\n          throw new Parse.Error(Parse.Error.DUPLICATE_VALUE, 'Class already exists.');\n        } else {\n          throw error;\n        }\n      });\n  }\n\n  updateSchema(name: string, update) {\n    return this._collection.updateOne(_mongoSchemaQueryFromNameQuery(name), update);\n  }\n\n  upsertSchema(name: string, query: string, update) {\n    return this._collection.upsertOne(_mongoSchemaQueryFromNameQuery(name, query), update);\n  }\n\n  // Add a field to the schema. If database does not support the field\n  // type (e.g. mongo doesn't support more than one GeoPoint in a class) reject with an \"Incorrect Type\"\n  // Parse error with a desciptive message. If the field already exists, this function must\n  // not modify the schema, and must reject with DUPLICATE_VALUE error.\n  // If this is called for a class that doesn't exist, this function must create that class.\n\n  // TODO: throw an error if an unsupported field type is passed. Deciding whether a type is supported\n  // should be the job of the adapter. Some adapters may not support GeoPoint at all. Others may\n  // Support additional types that Mongo doesn't, like Money, or something.\n\n  // TODO: don't spend an extra query on finding the schema if the type we are trying to add isn't a GeoPoint.\n  addFieldIfNotExists(className: string, fieldName: string, fieldType: string) {\n    return this._fetchOneSchemaFrom_SCHEMA(className)\n      .then(\n        schema => {\n          // If a field with this name already exists, it will be handled elsewhere.\n          if (schema.fields[fieldName] != undefined) {\n            return;\n          }\n          // The schema exists. Check for existing GeoPoints.\n          if (fieldType.type === 'GeoPoint') {\n            // Make sure there are not other geopoint fields\n            if (\n              Object.keys(schema.fields).some(\n                existingField => schema.fields[existingField].type === 'GeoPoint'\n              )\n            ) {\n              throw new Parse.Error(\n                Parse.Error.INCORRECT_TYPE,\n                'MongoDB only supports one GeoPoint field in a class.'\n              );\n            }\n          }\n          return;\n        },\n        error => {\n          // If error is undefined, the schema doesn't exist, and we can create the schema with the field.\n          // If some other error, reject with it.\n          if (error === undefined) {\n            return;\n          }\n          throw error;\n        }\n      )\n      .then(() => {\n        const { type, targetClass, ...fieldOptions } = fieldType;\n        // We use $exists and $set to avoid overwriting the field type if it\n        // already exists. (it could have added inbetween the last query and the update)\n        if (fieldOptions && Object.keys(fieldOptions).length > 0) {\n          return this.upsertSchema(\n            className,\n            { [fieldName]: { $exists: false } },\n            {\n              $set: {\n                [fieldName]: parseFieldTypeToMongoFieldType({\n                  type,\n                  targetClass,\n                }),\n                [`_metadata.fields_options.${fieldName}`]: fieldOptions,\n              },\n            }\n          );\n        } else {\n          return this.upsertSchema(\n            className,\n            { [fieldName]: { $exists: false } },\n            {\n              $set: {\n                [fieldName]: parseFieldTypeToMongoFieldType({\n                  type,\n                  targetClass,\n                }),\n              },\n            }\n          );\n        }\n      });\n  }\n}\n\n// Exported for testing reasons and because we haven't moved all mongo schema format\n// related logic into the database adapter yet.\nMongoSchemaCollection._TESTmongoSchemaToParseSchema = mongoSchemaToParseSchema;\nMongoSchemaCollection.parseFieldTypeToMongoFieldType = parseFieldTypeToMongoFieldType;\n\nexport default MongoSchemaCollection;\n"],"file":"MongoSchemaCollection.js"}