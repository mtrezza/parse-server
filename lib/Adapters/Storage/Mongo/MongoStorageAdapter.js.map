{"version":3,"sources":["../../../../src/Adapters/Storage/Mongo/MongoStorageAdapter.js"],"names":["mongodb","require","MongoClient","ReadPreference","MongoSchemaCollectionName","storageAdapterAllCollections","mongoAdapter","connect","then","database","collections","filter","collection","namespace","match","collectionName","indexOf","_collectionPrefix","convertParseSchemaToMongoSchema","schema","fields","_rperm","_wperm","className","_hashed_password","mongoSchemaFromFieldsAndClassNameAndCLP","classLevelPermissions","indexes","mongoObject","_id","objectId","updatedAt","createdAt","_metadata","undefined","fieldName","type","targetClass","fieldOptions","MongoSchemaCollection","parseFieldTypeToMongoFieldType","Object","keys","length","fields_options","class_permissions","MongoStorageAdapter","constructor","uri","defaults","DefaultMongoURI","collectionPrefix","mongoOptions","_uri","_mongoOptions","useNewUrlParser","useUnifiedTopology","_maxTimeMS","maxTimeMS","canSortOnJoinTables","connectionPromise","encodedUri","client","options","s","db","dbName","on","catch","err","Promise","reject","handleError","error","code","logger","handleShutdown","resolve","close","_adaptiveCollection","name","rawCollection","MongoCollection","_schemaCollection","classExists","listCollections","toArray","setClassLevelPermissions","CLPs","schemaCollection","updateSchema","$set","setIndexesWithSchemaFormat","submittedIndexes","existingIndexes","_id_","deletePromises","insertedIndexes","forEach","field","__op","Parse","Error","INVALID_QUERY","promise","dropIndex","push","key","prototype","hasOwnProperty","call","replace","insertPromise","createIndexes","all","setIndexesFromMongo","getIndexes","reduce","obj","index","_fts","_ftsx","weights","createClass","insertSchema","addFieldIfNotExists","createIndexesIfNeeded","deleteClass","drop","message","findAndDeleteSchema","deleteAllClasses","fast","map","deleteMany","deleteFields","fieldNames","mongoFormatNames","collectionUpdate","$unset","collectionFilter","$or","$exists","schemaUpdate","updateMany","getAllClasses","schemasCollection","_fetchAllSchemasFrom_SCHEMA","getClass","_fetchOneSchemaFrom_SCHEMA","createObject","object","transactionalSession","insertOne","DUPLICATE_VALUE","underlyingError","matches","Array","isArray","userInfo","duplicated_field","deleteObjectsByQuery","query","mongoWhere","result","n","OBJECT_NOT_FOUND","INTERNAL_SERVER_ERROR","updateObjectsByQuery","update","mongoUpdate","findOneAndUpdate","_mongoCollection","returnOriginal","session","value","upsertOneObject","upsertOne","find","skip","limit","sort","readPreference","hint","caseInsensitive","explain","mongoSort","_","mapKeys","mongoKeys","memo","_parseReadPreference","createTextIndexesIfNeeded","objects","ensureIndex","indexName","indexCreationRequest","mongoFieldNames","indexType","defaultOptions","background","sparse","indexNameOptions","ttlOptions","ttl","expireAfterSeconds","caseInsensitiveOptions","collation","caseInsensitiveCollation","indexOptions","createIndex","ensureUniqueness","_ensureSparseUniqueIndexInBackground","_rawFind","count","distinct","isPointerField","transformField","aggregate","pipeline","stage","$group","_parseAggregateGroupArgs","$match","_parseAggregateArgs","$project","_parseAggregateProjectArgs","$geoNear","results","split","includes","isEmpty","returnValue","_convertToDate","substring","Date","toUpperCase","PRIMARY","PRIMARY_PREFERRED","SECONDARY","SECONDARY_PREFERRED","NEAREST","performInitialization","$text","textIndex","dropAllIndexes","dropIndexes","updateSchemaWithIndexes","classes","promises","createTransactionalSession","transactionalSection","startSession","startTransaction","commitTransactionalSession","commitTransaction","endSession","abortTransactionalSession","abortTransaction"],"mappings":"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","sourcesContent":["// @flow\nimport MongoCollection from './MongoCollection';\nimport MongoSchemaCollection from './MongoSchemaCollection';\nimport { StorageAdapter } from '../StorageAdapter';\nimport type { SchemaType, QueryType, StorageClass, QueryOptions } from '../StorageAdapter';\nimport { parse as parseUrl, format as formatUrl } from '../../../vendor/mongodbUrl';\nimport {\n  parseObjectToMongoObjectForCreate,\n  mongoObjectToParseObject,\n  transformKey,\n  transformWhere,\n  transformUpdate,\n  transformPointerString,\n} from './MongoTransform';\n// @flow-disable-next\nimport Parse from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\nimport defaults from '../../../defaults';\nimport logger from '../../../logger';\n\n// @flow-disable-next\nconst mongodb = require('mongodb');\nconst MongoClient = mongodb.MongoClient;\nconst ReadPreference = mongodb.ReadPreference;\n\nconst MongoSchemaCollectionName = '_SCHEMA';\n\nconst storageAdapterAllCollections = mongoAdapter => {\n  return mongoAdapter\n    .connect()\n    .then(() => mongoAdapter.database.collections())\n    .then(collections => {\n      return collections.filter(collection => {\n        if (collection.namespace.match(/\\.system\\./)) {\n          return false;\n        }\n        // TODO: If you have one app with a collection prefix that happens to be a prefix of another\n        // apps prefix, this will go very very badly. We should fix that somehow.\n        return collection.collectionName.indexOf(mongoAdapter._collectionPrefix) == 0;\n      });\n    });\n};\n\nconst convertParseSchemaToMongoSchema = ({ ...schema }) => {\n  delete schema.fields._rperm;\n  delete schema.fields._wperm;\n\n  if (schema.className === '_User') {\n    // Legacy mongo adapter knows about the difference between password and _hashed_password.\n    // Future database adapters will only know about _hashed_password.\n    // Note: Parse Server will bring back password with injectDefaultSchema, so we don't need\n    // to add _hashed_password back ever.\n    delete schema.fields._hashed_password;\n  }\n\n  return schema;\n};\n\n// Returns { code, error } if invalid, or { result }, an object\n// suitable for inserting into _SCHEMA collection, otherwise.\nconst mongoSchemaFromFieldsAndClassNameAndCLP = (\n  fields,\n  className,\n  classLevelPermissions,\n  indexes\n) => {\n  const mongoObject = {\n    _id: className,\n    objectId: 'string',\n    updatedAt: 'string',\n    createdAt: 'string',\n    _metadata: undefined,\n  };\n\n  for (const fieldName in fields) {\n    const { type, targetClass, ...fieldOptions } = fields[fieldName];\n    mongoObject[fieldName] = MongoSchemaCollection.parseFieldTypeToMongoFieldType({\n      type,\n      targetClass,\n    });\n    if (fieldOptions && Object.keys(fieldOptions).length > 0) {\n      mongoObject._metadata = mongoObject._metadata || {};\n      mongoObject._metadata.fields_options = mongoObject._metadata.fields_options || {};\n      mongoObject._metadata.fields_options[fieldName] = fieldOptions;\n    }\n  }\n\n  if (typeof classLevelPermissions !== 'undefined') {\n    mongoObject._metadata = mongoObject._metadata || {};\n    if (!classLevelPermissions) {\n      delete mongoObject._metadata.class_permissions;\n    } else {\n      mongoObject._metadata.class_permissions = classLevelPermissions;\n    }\n  }\n\n  if (indexes && typeof indexes === 'object' && Object.keys(indexes).length > 0) {\n    mongoObject._metadata = mongoObject._metadata || {};\n    mongoObject._metadata.indexes = indexes;\n  }\n\n  if (!mongoObject._metadata) {\n    // cleanup the unused _metadata\n    delete mongoObject._metadata;\n  }\n\n  return mongoObject;\n};\n\nexport class MongoStorageAdapter implements StorageAdapter {\n  // Private\n  _uri: string;\n  _collectionPrefix: string;\n  _mongoOptions: Object;\n  // Public\n  connectionPromise: ?Promise<any>;\n  database: any;\n  client: MongoClient;\n  _maxTimeMS: ?number;\n  canSortOnJoinTables: boolean;\n\n  constructor({ uri = defaults.DefaultMongoURI, collectionPrefix = '', mongoOptions = {} }: any) {\n    this._uri = uri;\n    this._collectionPrefix = collectionPrefix;\n    this._mongoOptions = mongoOptions;\n    this._mongoOptions.useNewUrlParser = true;\n    this._mongoOptions.useUnifiedTopology = true;\n\n    // MaxTimeMS is not a global MongoDB client option, it is applied per operation.\n    this._maxTimeMS = mongoOptions.maxTimeMS;\n    this.canSortOnJoinTables = true;\n    delete mongoOptions.maxTimeMS;\n  }\n\n  connect() {\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    // parsing and re-formatting causes the auth value (if there) to get URI\n    // encoded\n    const encodedUri = formatUrl(parseUrl(this._uri));\n\n    this.connectionPromise = MongoClient.connect(encodedUri, this._mongoOptions)\n      .then(client => {\n        // Starting mongoDB 3.0, the MongoClient.connect don't return a DB anymore but a client\n        // Fortunately, we can get back the options and use them to select the proper DB.\n        // https://github.com/mongodb/node-mongodb-native/blob/2c35d76f08574225b8db02d7bef687123e6bb018/lib/mongo_client.js#L885\n        const options = client.s.options;\n        const database = client.db(options.dbName);\n        if (!database) {\n          delete this.connectionPromise;\n          return;\n        }\n        database.on('error', () => {\n          delete this.connectionPromise;\n        });\n        database.on('close', () => {\n          delete this.connectionPromise;\n        });\n        this.client = client;\n        this.database = database;\n      })\n      .catch(err => {\n        delete this.connectionPromise;\n        return Promise.reject(err);\n      });\n\n    return this.connectionPromise;\n  }\n\n  handleError<T>(error: ?(Error | Parse.Error)): Promise<T> {\n    if (error && error.code === 13) {\n      // Unauthorized error\n      delete this.client;\n      delete this.database;\n      delete this.connectionPromise;\n      logger.error('Received unauthorized error', { error: error });\n    }\n    throw error;\n  }\n\n  handleShutdown() {\n    if (!this.client) {\n      return Promise.resolve();\n    }\n    return this.client.close(false);\n  }\n\n  _adaptiveCollection(name: string) {\n    return this.connect()\n      .then(() => this.database.collection(this._collectionPrefix + name))\n      .then(rawCollection => new MongoCollection(rawCollection))\n      .catch(err => this.handleError(err));\n  }\n\n  _schemaCollection(): Promise<MongoSchemaCollection> {\n    return this.connect()\n      .then(() => this._adaptiveCollection(MongoSchemaCollectionName))\n      .then(collection => new MongoSchemaCollection(collection));\n  }\n\n  classExists(name: string) {\n    return this.connect()\n      .then(() => {\n        return this.database.listCollections({ name: this._collectionPrefix + name }).toArray();\n      })\n      .then(collections => {\n        return collections.length > 0;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  setClassLevelPermissions(className: string, CLPs: any): Promise<void> {\n    return this._schemaCollection()\n      .then(schemaCollection =>\n        schemaCollection.updateSchema(className, {\n          $set: { '_metadata.class_permissions': CLPs },\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  setIndexesWithSchemaFormat(\n    className: string,\n    submittedIndexes: any,\n    existingIndexes: any = {},\n    fields: any\n  ): Promise<void> {\n    if (submittedIndexes === undefined) {\n      return Promise.resolve();\n    }\n    if (Object.keys(existingIndexes).length === 0) {\n      existingIndexes = { _id_: { _id: 1 } };\n    }\n    const deletePromises = [];\n    const insertedIndexes = [];\n    Object.keys(submittedIndexes).forEach(name => {\n      const field = submittedIndexes[name];\n      if (existingIndexes[name] && field.__op !== 'Delete') {\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, `Index ${name} exists, cannot update.`);\n      }\n      if (!existingIndexes[name] && field.__op === 'Delete') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_QUERY,\n          `Index ${name} does not exist, cannot delete.`\n        );\n      }\n      if (field.__op === 'Delete') {\n        const promise = this.dropIndex(className, name);\n        deletePromises.push(promise);\n        delete existingIndexes[name];\n      } else {\n        Object.keys(field).forEach(key => {\n          if (\n            !Object.prototype.hasOwnProperty.call(\n              fields,\n              key.indexOf('_p_') === 0 ? key.replace('_p_', '') : key\n            )\n          ) {\n            throw new Parse.Error(\n              Parse.Error.INVALID_QUERY,\n              `Field ${key} does not exist, cannot add index.`\n            );\n          }\n        });\n        existingIndexes[name] = field;\n        insertedIndexes.push({\n          key: field,\n          name,\n        });\n      }\n    });\n    let insertPromise = Promise.resolve();\n    if (insertedIndexes.length > 0) {\n      insertPromise = this.createIndexes(className, insertedIndexes);\n    }\n    return Promise.all(deletePromises)\n      .then(() => insertPromise)\n      .then(() => this._schemaCollection())\n      .then(schemaCollection =>\n        schemaCollection.updateSchema(className, {\n          $set: { '_metadata.indexes': existingIndexes },\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  setIndexesFromMongo(className: string) {\n    return this.getIndexes(className)\n      .then(indexes => {\n        indexes = indexes.reduce((obj, index) => {\n          if (index.key._fts) {\n            delete index.key._fts;\n            delete index.key._ftsx;\n            for (const field in index.weights) {\n              index.key[field] = 'text';\n            }\n          }\n          obj[index.name] = index.key;\n          return obj;\n        }, {});\n        return this._schemaCollection().then(schemaCollection =>\n          schemaCollection.updateSchema(className, {\n            $set: { '_metadata.indexes': indexes },\n          })\n        );\n      })\n      .catch(err => this.handleError(err))\n      .catch(() => {\n        // Ignore if collection not found\n        return Promise.resolve();\n      });\n  }\n\n  createClass(className: string, schema: SchemaType): Promise<void> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoObject = mongoSchemaFromFieldsAndClassNameAndCLP(\n      schema.fields,\n      className,\n      schema.classLevelPermissions,\n      schema.indexes\n    );\n    mongoObject._id = className;\n    return this.setIndexesWithSchemaFormat(className, schema.indexes, {}, schema.fields)\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.insertSchema(mongoObject))\n      .catch(err => this.handleError(err));\n  }\n\n  addFieldIfNotExists(className: string, fieldName: string, type: any): Promise<void> {\n    return this._schemaCollection()\n      .then(schemaCollection => schemaCollection.addFieldIfNotExists(className, fieldName, type))\n      .then(() => this.createIndexesIfNeeded(className, fieldName, type))\n      .catch(err => this.handleError(err));\n  }\n\n  // Drops a collection. Resolves with true if it was a Parse Schema (eg. _User, Custom, etc.)\n  // and resolves with false if it wasn't (eg. a join table). Rejects if deletion was impossible.\n  deleteClass(className: string) {\n    return (\n      this._adaptiveCollection(className)\n        .then(collection => collection.drop())\n        .catch(error => {\n          // 'ns not found' means collection was already gone. Ignore deletion attempt.\n          if (error.message == 'ns not found') {\n            return;\n          }\n          throw error;\n        })\n        // We've dropped the collection, now remove the _SCHEMA document\n        .then(() => this._schemaCollection())\n        .then(schemaCollection => schemaCollection.findAndDeleteSchema(className))\n        .catch(err => this.handleError(err))\n    );\n  }\n\n  deleteAllClasses(fast: boolean) {\n    return storageAdapterAllCollections(this).then(collections =>\n      Promise.all(\n        collections.map(collection => (fast ? collection.deleteMany({}) : collection.drop()))\n      )\n    );\n  }\n\n  // Remove the column and all the data. For Relations, the _Join collection is handled\n  // specially, this function does not delete _Join columns. It should, however, indicate\n  // that the relation fields does not exist anymore. In mongo, this means removing it from\n  // the _SCHEMA collection.  There should be no actual data in the collection under the same name\n  // as the relation column, so it's fine to attempt to delete it. If the fields listed to be\n  // deleted do not exist, this function should return successfully anyways. Checking for\n  // attempts to delete non-existent fields is the responsibility of Parse Server.\n\n  // Pointer field names are passed for legacy reasons: the original mongo\n  // format stored pointer field names differently in the database, and therefore\n  // needed to know the type of the field before it could delete it. Future database\n  // adapters should ignore the pointerFieldNames argument. All the field names are in\n  // fieldNames, they show up additionally in the pointerFieldNames database for use\n  // by the mongo adapter, which deals with the legacy mongo format.\n\n  // This function is not obligated to delete fields atomically. It is given the field\n  // names in a list so that databases that are capable of deleting fields atomically\n  // may do so.\n\n  // Returns a Promise.\n  deleteFields(className: string, schema: SchemaType, fieldNames: string[]) {\n    const mongoFormatNames = fieldNames.map(fieldName => {\n      if (schema.fields[fieldName].type === 'Pointer') {\n        return `_p_${fieldName}`;\n      } else {\n        return fieldName;\n      }\n    });\n    const collectionUpdate = { $unset: {} };\n    mongoFormatNames.forEach(name => {\n      collectionUpdate['$unset'][name] = null;\n    });\n\n    const collectionFilter = { $or: [] };\n    mongoFormatNames.forEach(name => {\n      collectionFilter['$or'].push({ [name]: { $exists: true } });\n    });\n\n    const schemaUpdate = { $unset: {} };\n    fieldNames.forEach(name => {\n      schemaUpdate['$unset'][name] = null;\n      schemaUpdate['$unset'][`_metadata.fields_options.${name}`] = null;\n    });\n\n    return this._adaptiveCollection(className)\n      .then(collection => collection.updateMany(collectionFilter, collectionUpdate))\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.updateSchema(className, schemaUpdate))\n      .catch(err => this.handleError(err));\n  }\n\n  // Return a promise for all schemas known to this adapter, in Parse format. In case the\n  // schemas cannot be retrieved, returns a promise that rejects. Requirements for the\n  // rejection reason are TBD.\n  getAllClasses(): Promise<StorageClass[]> {\n    return this._schemaCollection()\n      .then(schemasCollection => schemasCollection._fetchAllSchemasFrom_SCHEMA())\n      .catch(err => this.handleError(err));\n  }\n\n  // Return a promise for the schema with the given name, in Parse format. If\n  // this adapter doesn't know about the schema, return a promise that rejects with\n  // undefined as the reason.\n  getClass(className: string): Promise<StorageClass> {\n    return this._schemaCollection()\n      .then(schemasCollection => schemasCollection._fetchOneSchemaFrom_SCHEMA(className))\n      .catch(err => this.handleError(err));\n  }\n\n  // TODO: As yet not particularly well specified. Creates an object. Maybe shouldn't even need the schema,\n  // and should infer from the type. Or maybe does need the schema for validations. Or maybe needs\n  // the schema only for the legacy mongo format. We'll figure that out later.\n  createObject(className: string, schema: SchemaType, object: any, transactionalSession: ?any) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoObject = parseObjectToMongoObjectForCreate(className, object, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.insertOne(mongoObject, transactionalSession))\n      .catch(error => {\n        if (error.code === 11000) {\n          // Duplicate value\n          const err = new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'A duplicate value for a field with unique values was provided'\n          );\n          err.underlyingError = error;\n          if (error.message) {\n            const matches = error.message.match(/index:[\\sa-zA-Z0-9_\\-\\.]+\\$?([a-zA-Z_-]+)_1/);\n            if (matches && Array.isArray(matches)) {\n              err.userInfo = { duplicated_field: matches[1] };\n            }\n          }\n          throw err;\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Remove all objects that match the given Parse Query.\n  // If no objects match, reject with OBJECT_NOT_FOUND. If objects are found and deleted, resolve with undefined.\n  // If there is some other error, reject with INTERNAL_SERVER_ERROR.\n  deleteObjectsByQuery(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    return this._adaptiveCollection(className)\n      .then(collection => {\n        const mongoWhere = transformWhere(className, query, schema);\n        return collection.deleteMany(mongoWhere, transactionalSession);\n      })\n      .catch(err => this.handleError(err))\n      .then(\n        ({ result }) => {\n          if (result.n === 0) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          return Promise.resolve();\n        },\n        () => {\n          throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Database adapter error');\n        }\n      );\n  }\n\n  // Apply the update to all objects that match the given Parse Query.\n  updateObjectsByQuery(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.updateMany(mongoWhere, mongoUpdate, transactionalSession))\n      .catch(err => this.handleError(err));\n  }\n\n  // Atomically finds and updates an object based on query.\n  // Return value not currently well specified.\n  findOneAndUpdate(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection._mongoCollection.findOneAndUpdate(mongoWhere, mongoUpdate, {\n          returnOriginal: false,\n          session: transactionalSession || undefined,\n        })\n      )\n      .then(result => mongoObjectToParseObject(className, result.value, schema))\n      .catch(error => {\n        if (error.code === 11000) {\n          throw new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'A duplicate value for a field with unique values was provided'\n          );\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Hopefully we can get rid of this. It's only used for config and hooks.\n  upsertOneObject(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.upsertOne(mongoWhere, mongoUpdate, transactionalSession))\n      .catch(err => this.handleError(err));\n  }\n\n  // Executes a find. Accepts: className, query in Parse format, and { skip, limit, sort }.\n  find(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    { skip, limit, sort, keys, readPreference, hint, caseInsensitive, explain }: QueryOptions\n  ): Promise<any> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    const mongoSort = _.mapKeys(sort, (value, fieldName) =>\n      transformKey(className, fieldName, schema)\n    );\n    const mongoKeys = _.reduce(\n      keys,\n      (memo, key) => {\n        if (key === 'ACL') {\n          memo['_rperm'] = 1;\n          memo['_wperm'] = 1;\n        } else {\n          memo[transformKey(className, key, schema)] = 1;\n        }\n        return memo;\n      },\n      {}\n    );\n\n    // If we aren't requesting the `_id` field, we need to explicitly opt out\n    // of it. Doing so in parse-server is unusual, but it can allow us to\n    // optimize some queries with covering indexes.\n    if (keys && !mongoKeys._id) {\n      mongoKeys._id = 0;\n    }\n\n    readPreference = this._parseReadPreference(readPreference);\n    return this.createTextIndexesIfNeeded(className, query, schema)\n      .then(() => this._adaptiveCollection(className))\n      .then(collection =>\n        collection.find(mongoWhere, {\n          skip,\n          limit,\n          sort: mongoSort,\n          keys: mongoKeys,\n          maxTimeMS: this._maxTimeMS,\n          readPreference,\n          hint,\n          caseInsensitive,\n          explain,\n        })\n      )\n      .then(objects => {\n        if (explain) {\n          return objects;\n        }\n        return objects.map(object => mongoObjectToParseObject(className, object, schema));\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  ensureIndex(\n    className: string,\n    schema: SchemaType,\n    fieldNames: string[],\n    indexName: ?string,\n    caseInsensitive: boolean = false,\n    options?: Object = {}\n  ): Promise<any> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const indexCreationRequest = {};\n    const mongoFieldNames = fieldNames.map(fieldName => transformKey(className, fieldName, schema));\n    mongoFieldNames.forEach(fieldName => {\n      indexCreationRequest[fieldName] = options.indexType !== undefined ? options.indexType : 1;\n    });\n\n    const defaultOptions: Object = { background: true, sparse: true };\n    const indexNameOptions: Object = indexName ? { name: indexName } : {};\n    const ttlOptions: Object = options.ttl !== undefined ? { expireAfterSeconds: options.ttl } : {};\n    const caseInsensitiveOptions: Object = caseInsensitive\n      ? { collation: MongoCollection.caseInsensitiveCollation() }\n      : {};\n    const indexOptions: Object = {\n      ...defaultOptions,\n      ...caseInsensitiveOptions,\n      ...indexNameOptions,\n      ...ttlOptions,\n    };\n\n    return this._adaptiveCollection(className)\n      .then(\n        collection =>\n          new Promise((resolve, reject) =>\n            collection._mongoCollection.createIndex(indexCreationRequest, indexOptions, error =>\n              error ? reject(error) : resolve()\n            )\n          )\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  // Create a unique index. Unique indexes on nullable fields are not allowed. Since we don't\n  // currently know which fields are nullable and which aren't, we ignore that criteria.\n  // As such, we shouldn't expose this function to users of parse until we have an out-of-band\n  // Way of determining if a field is nullable. Undefined doesn't count against uniqueness,\n  // which is why we use sparse indexes.\n  ensureUniqueness(className: string, schema: SchemaType, fieldNames: string[]) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const indexCreationRequest = {};\n    const mongoFieldNames = fieldNames.map(fieldName => transformKey(className, fieldName, schema));\n    mongoFieldNames.forEach(fieldName => {\n      indexCreationRequest[fieldName] = 1;\n    });\n    return this._adaptiveCollection(className)\n      .then(collection => collection._ensureSparseUniqueIndexInBackground(indexCreationRequest))\n      .catch(error => {\n        if (error.code === 11000) {\n          throw new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'Tried to ensure field uniqueness for a class that already has duplicates.'\n          );\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Used in tests\n  _rawFind(className: string, query: QueryType) {\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.find(query, {\n          maxTimeMS: this._maxTimeMS,\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  // Executes a count.\n  count(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    readPreference: ?string,\n    hint: ?mixed\n  ) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    readPreference = this._parseReadPreference(readPreference);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.count(transformWhere(className, query, schema, true), {\n          maxTimeMS: this._maxTimeMS,\n          readPreference,\n          hint,\n        })\n      )\n      .catch(err => this.handleError(err));\n  }\n\n  distinct(className: string, schema: SchemaType, query: QueryType, fieldName: string) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const isPointerField = schema.fields[fieldName] && schema.fields[fieldName].type === 'Pointer';\n    const transformField = transformKey(className, fieldName, schema);\n\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.distinct(transformField, transformWhere(className, query, schema))\n      )\n      .then(objects => {\n        objects = objects.filter(obj => obj != null);\n        return objects.map(object => {\n          if (isPointerField) {\n            return transformPointerString(schema, fieldName, object);\n          }\n          return mongoObjectToParseObject(className, object, schema);\n        });\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  aggregate(\n    className: string,\n    schema: any,\n    pipeline: any,\n    readPreference: ?string,\n    hint: ?mixed,\n    explain?: boolean\n  ) {\n    let isPointerField = false;\n    pipeline = pipeline.map(stage => {\n      if (stage.$group) {\n        stage.$group = this._parseAggregateGroupArgs(schema, stage.$group);\n        if (\n          stage.$group._id &&\n          typeof stage.$group._id === 'string' &&\n          stage.$group._id.indexOf('$_p_') >= 0\n        ) {\n          isPointerField = true;\n        }\n      }\n      if (stage.$match) {\n        stage.$match = this._parseAggregateArgs(schema, stage.$match);\n      }\n      if (stage.$project) {\n        stage.$project = this._parseAggregateProjectArgs(schema, stage.$project);\n      }\n      if (stage.$geoNear && stage.$geoNear.query) {\n        stage.$geoNear.query = this._parseAggregateArgs(schema, stage.$geoNear.query);\n      }\n      return stage;\n    });\n    readPreference = this._parseReadPreference(readPreference);\n    return this._adaptiveCollection(className)\n      .then(collection =>\n        collection.aggregate(pipeline, {\n          readPreference,\n          maxTimeMS: this._maxTimeMS,\n          hint,\n          explain,\n        })\n      )\n      .then(results => {\n        results.forEach(result => {\n          if (Object.prototype.hasOwnProperty.call(result, '_id')) {\n            if (isPointerField && result._id) {\n              result._id = result._id.split('$')[1];\n            }\n            if (\n              result._id == null ||\n              result._id == undefined ||\n              (['object', 'string'].includes(typeof result._id) && _.isEmpty(result._id))\n            ) {\n              result._id = null;\n            }\n            result.objectId = result._id;\n            delete result._id;\n          }\n        });\n        return results;\n      })\n      .then(objects => objects.map(object => mongoObjectToParseObject(className, object, schema)))\n      .catch(err => this.handleError(err));\n  }\n\n  // This function will recursively traverse the pipeline and convert any Pointer or Date columns.\n  // If we detect a pointer column we will rename the column being queried for to match the column\n  // in the database. We also modify the value to what we expect the value to be in the database\n  // as well.\n  // For dates, the driver expects a Date object, but we have a string coming in. So we'll convert\n  // the string to a Date so the driver can perform the necessary comparison.\n  //\n  // The goal of this method is to look for the \"leaves\" of the pipeline and determine if it needs\n  // to be converted. The pipeline can have a few different forms. For more details, see:\n  //     https://docs.mongodb.com/manual/reference/operator/aggregation/\n  //\n  // If the pipeline is an array, it means we are probably parsing an '$and' or '$or' operator. In\n  // that case we need to loop through all of it's children to find the columns being operated on.\n  // If the pipeline is an object, then we'll loop through the keys checking to see if the key name\n  // matches one of the schema columns. If it does match a column and the column is a Pointer or\n  // a Date, then we'll convert the value as described above.\n  //\n  // As much as I hate recursion...this seemed like a good fit for it. We're essentially traversing\n  // down a tree to find a \"leaf node\" and checking to see if it needs to be converted.\n  _parseAggregateArgs(schema: any, pipeline: any): any {\n    if (pipeline === null) {\n      return null;\n    } else if (Array.isArray(pipeline)) {\n      return pipeline.map(value => this._parseAggregateArgs(schema, value));\n    } else if (typeof pipeline === 'object') {\n      const returnValue = {};\n      for (const field in pipeline) {\n        if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n          if (typeof pipeline[field] === 'object') {\n            // Pass objects down to MongoDB...this is more than likely an $exists operator.\n            returnValue[`_p_${field}`] = pipeline[field];\n          } else {\n            returnValue[`_p_${field}`] = `${schema.fields[field].targetClass}$${pipeline[field]}`;\n          }\n        } else if (schema.fields[field] && schema.fields[field].type === 'Date') {\n          returnValue[field] = this._convertToDate(pipeline[field]);\n        } else {\n          returnValue[field] = this._parseAggregateArgs(schema, pipeline[field]);\n        }\n\n        if (field === 'objectId') {\n          returnValue['_id'] = returnValue[field];\n          delete returnValue[field];\n        } else if (field === 'createdAt') {\n          returnValue['_created_at'] = returnValue[field];\n          delete returnValue[field];\n        } else if (field === 'updatedAt') {\n          returnValue['_updated_at'] = returnValue[field];\n          delete returnValue[field];\n        }\n      }\n      return returnValue;\n    }\n    return pipeline;\n  }\n\n  // This function is slightly different than the one above. Rather than trying to combine these\n  // two functions and making the code even harder to understand, I decided to split it up. The\n  // difference with this function is we are not transforming the values, only the keys of the\n  // pipeline.\n  _parseAggregateProjectArgs(schema: any, pipeline: any): any {\n    const returnValue = {};\n    for (const field in pipeline) {\n      if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n        returnValue[`_p_${field}`] = pipeline[field];\n      } else {\n        returnValue[field] = this._parseAggregateArgs(schema, pipeline[field]);\n      }\n\n      if (field === 'objectId') {\n        returnValue['_id'] = returnValue[field];\n        delete returnValue[field];\n      } else if (field === 'createdAt') {\n        returnValue['_created_at'] = returnValue[field];\n        delete returnValue[field];\n      } else if (field === 'updatedAt') {\n        returnValue['_updated_at'] = returnValue[field];\n        delete returnValue[field];\n      }\n    }\n    return returnValue;\n  }\n\n  // This function is slightly different than the two above. MongoDB $group aggregate looks like:\n  //     { $group: { _id: <expression>, <field1>: { <accumulator1> : <expression1> }, ... } }\n  // The <expression> could be a column name, prefixed with the '$' character. We'll look for\n  // these <expression> and check to see if it is a 'Pointer' or if it's one of createdAt,\n  // updatedAt or objectId and change it accordingly.\n  _parseAggregateGroupArgs(schema: any, pipeline: any): any {\n    if (Array.isArray(pipeline)) {\n      return pipeline.map(value => this._parseAggregateGroupArgs(schema, value));\n    } else if (typeof pipeline === 'object') {\n      const returnValue = {};\n      for (const field in pipeline) {\n        returnValue[field] = this._parseAggregateGroupArgs(schema, pipeline[field]);\n      }\n      return returnValue;\n    } else if (typeof pipeline === 'string') {\n      const field = pipeline.substring(1);\n      if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n        return `$_p_${field}`;\n      } else if (field == 'createdAt') {\n        return '$_created_at';\n      } else if (field == 'updatedAt') {\n        return '$_updated_at';\n      }\n    }\n    return pipeline;\n  }\n\n  // This function will attempt to convert the provided value to a Date object. Since this is part\n  // of an aggregation pipeline, the value can either be a string or it can be another object with\n  // an operator in it (like $gt, $lt, etc). Because of this I felt it was easier to make this a\n  // recursive method to traverse down to the \"leaf node\" which is going to be the string.\n  _convertToDate(value: any): any {\n    if (typeof value === 'string') {\n      return new Date(value);\n    }\n\n    const returnValue = {};\n    for (const field in value) {\n      returnValue[field] = this._convertToDate(value[field]);\n    }\n    return returnValue;\n  }\n\n  _parseReadPreference(readPreference: ?string): ?string {\n    if (readPreference) {\n      readPreference = readPreference.toUpperCase();\n    }\n    switch (readPreference) {\n      case 'PRIMARY':\n        readPreference = ReadPreference.PRIMARY;\n        break;\n      case 'PRIMARY_PREFERRED':\n        readPreference = ReadPreference.PRIMARY_PREFERRED;\n        break;\n      case 'SECONDARY':\n        readPreference = ReadPreference.SECONDARY;\n        break;\n      case 'SECONDARY_PREFERRED':\n        readPreference = ReadPreference.SECONDARY_PREFERRED;\n        break;\n      case 'NEAREST':\n        readPreference = ReadPreference.NEAREST;\n        break;\n      case undefined:\n      case null:\n      case '':\n        break;\n      default:\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Not supported read preference.');\n    }\n    return readPreference;\n  }\n\n  performInitialization(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  createIndex(className: string, index: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.createIndex(index))\n      .catch(err => this.handleError(err));\n  }\n\n  createIndexes(className: string, indexes: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.createIndexes(indexes))\n      .catch(err => this.handleError(err));\n  }\n\n  createIndexesIfNeeded(className: string, fieldName: string, type: any) {\n    if (type && type.type === 'Polygon') {\n      const index = {\n        [fieldName]: '2dsphere',\n      };\n      return this.createIndex(className, index);\n    }\n    return Promise.resolve();\n  }\n\n  createTextIndexesIfNeeded(className: string, query: QueryType, schema: any): Promise<void> {\n    for (const fieldName in query) {\n      if (!query[fieldName] || !query[fieldName].$text) {\n        continue;\n      }\n      const existingIndexes = schema.indexes;\n      for (const key in existingIndexes) {\n        const index = existingIndexes[key];\n        if (Object.prototype.hasOwnProperty.call(index, fieldName)) {\n          return Promise.resolve();\n        }\n      }\n      const indexName = `${fieldName}_text`;\n      const textIndex = {\n        [indexName]: { [fieldName]: 'text' },\n      };\n      return this.setIndexesWithSchemaFormat(\n        className,\n        textIndex,\n        existingIndexes,\n        schema.fields\n      ).catch(error => {\n        if (error.code === 85) {\n          // Index exist with different options\n          return this.setIndexesFromMongo(className);\n        }\n        throw error;\n      });\n    }\n    return Promise.resolve();\n  }\n\n  getIndexes(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.indexes())\n      .catch(err => this.handleError(err));\n  }\n\n  dropIndex(className: string, index: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.dropIndex(index))\n      .catch(err => this.handleError(err));\n  }\n\n  dropAllIndexes(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.dropIndexes())\n      .catch(err => this.handleError(err));\n  }\n\n  updateSchemaWithIndexes(): Promise<any> {\n    return this.getAllClasses()\n      .then(classes => {\n        const promises = classes.map(schema => {\n          return this.setIndexesFromMongo(schema.className);\n        });\n        return Promise.all(promises);\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  createTransactionalSession(): Promise<any> {\n    const transactionalSection = this.client.startSession();\n    transactionalSection.startTransaction();\n    return Promise.resolve(transactionalSection);\n  }\n\n  commitTransactionalSession(transactionalSection: any): Promise<void> {\n    return transactionalSection.commitTransaction().then(() => {\n      transactionalSection.endSession();\n    });\n  }\n\n  abortTransactionalSession(transactionalSection: any): Promise<void> {\n    return transactionalSection.abortTransaction().then(() => {\n      transactionalSection.endSession();\n    });\n  }\n}\n\nexport default MongoStorageAdapter;\n"],"file":"MongoStorageAdapter.js"}