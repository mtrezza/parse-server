{"version":3,"sources":["../../../../src/Adapters/Storage/Postgres/PostgresStorageAdapter.js"],"names":["PostgresRelationDoesNotExistError","PostgresDuplicateRelationError","PostgresDuplicateColumnError","PostgresMissingColumnError","PostgresDuplicateObjectError","PostgresUniqueIndexViolationError","logger","require","debug","args","arguments","concat","slice","length","log","getLogger","apply","parseTypeToPostgresType","type","contents","JSON","stringify","ParseToPosgresComparator","$gt","$lt","$gte","$lte","mongoAggregateToPostgres","$dayOfMonth","$dayOfWeek","$dayOfYear","$isoDayOfWeek","$isoWeekYear","$hour","$minute","$second","$millisecond","$month","$week","$year","toPostgresValue","value","__type","iso","name","transformValue","objectId","emptyCLPS","Object","freeze","find","get","count","create","update","delete","addField","protectedFields","defaultCLPS","toParseSchema","schema","className","fields","_hashed_password","_wperm","_rperm","clps","classLevelPermissions","indexes","toPostgresSchema","_password_history","handleDotFields","object","keys","forEach","fieldName","indexOf","components","split","first","shift","currentObj","next","__op","undefined","transformDotFieldToComponents","map","cmpt","index","transformDotField","join","transformAggregateField","substr","validateKeys","key","includes","Parse","Error","INVALID_NESTED_KEY","joinTablesForSchema","list","field","push","buildWhereClause","query","caseInsensitive","patterns","values","sorts","isArrayField","initialPatternsLength","fieldValue","$exists","authDataMatch","match","$in","$regex","MAX_INT_PLUS_ONE","clauses","clauseValues","subQuery","clause","pattern","orOrAnd","not","$ne","constraintFieldName","point","longitude","latitude","$eq","isInOrNin","Array","isArray","$nin","inPatterns","allowNull","listElem","listIndex","createConstraint","baseArray","notIn","_","flatMap","elt","INVALID_JSON","$all","isAnyValueRegexStartsWith","isAllValuesRegexOrNone","i","processRegexPattern","substring","$containedBy","arr","$text","search","$search","language","$term","$language","$caseSensitive","$diacriticSensitive","$nearSphere","distance","$maxDistance","distanceInKM","$within","$box","box","left","bottom","right","top","$geoWithin","$centerSphere","centerSphere","GeoPoint","GeoPointCoder","isValidJSON","_validate","isNaN","$polygon","polygon","points","coordinates","$geoIntersects","$point","regex","operator","opts","$options","removeWhiteSpace","convertPolygonToSQL","cmp","pgComparator","postgresValue","castType","OPERATION_FORBIDDEN","PostgresStorageAdapter","constructor","uri","collectionPrefix","databaseOptions","_collectionPrefix","client","pgp","_client","_pgp","canSortOnJoinTables","createExplainableQuery","analyze","handleShutdown","$pool","end","_ensureSchemaCollectionExists","conn","none","catch","error","code","classExists","one","a","exists","setClassLevelPermissions","CLPs","self","task","t","setIndexesWithSchemaFormat","submittedIndexes","existingIndexes","Promise","resolve","_id_","_id","deletedIndexes","insertedIndexes","INVALID_QUERY","prototype","hasOwnProperty","call","tx","createIndexes","dropIndexes","createClass","createTable","err","detail","DUPLICATE_VALUE","valuesArray","patternsArray","assign","_email_verify_token_expires_at","_email_verify_token","_account_lockout_expires_at","_failed_login_count","_perishable_token","_perishable_token_expires_at","_password_changed_at","relations","parseType","qs","batch","joinTable","schemaUpgrade","columns","column_name","newColumns","filter","item","addFieldIfNotExists","postgresType","result","any","path","deleteClass","operations","helpers","then","deleteAllClasses","now","Date","getTime","results","joins","reduce","classes","queries","deleteFields","fieldNames","idx","getAllClasses","row","getClass","createObject","transactionalSession","columnsArray","geoPoints","provider","pop","initialValues","val","termination","geoPointsInjects","l","columnsPattern","col","valuesPattern","promise","ops","underlyingError","constraint","matches","userInfo","duplicated_field","deleteObjectsByQuery","where","OBJECT_NOT_FOUND","findOneAndUpdate","updateObjectsByQuery","updatePatterns","originalUpdate","dotNotationOptions","generate","jsonb","lastKey","fieldNameIndex","str","amount","objects","keysToIncrement","k","incrementPatterns","c","keysToDelete","deletePatterns","p","updateObject","expectedType","reject","whereClause","upsertOneObject","createValue","skip","limit","sort","explain","hasLimit","hasSkip","wherePattern","limitPattern","skipPattern","sortPattern","sortCopy","sorting","transformKey","memo","originalQuery","postgresObjectToParseObject","targetClass","y","x","coords","parseFloat","createdAt","toISOString","updatedAt","expiresAt","ensureUniqueness","constraintName","constraintPatterns","message","readPreference","estimate","approximate_row_count","distinct","column","isNested","isPointerField","transformer","child","aggregate","pipeline","hint","countField","groupValues","groupPattern","stage","$group","groupByFields","alias","source","operation","$sum","$max","$min","$avg","$project","$match","$or","collapse","element","matchPatterns","$limit","$skip","$sort","order","e","trim","Boolean","parseInt","performInitialization","VolatileClassesSchemas","promises","INVALID_CLASS_NAME","all","sql","misc","jsonObjectSetKeys","array","add","addUnique","remove","containsAll","containsAllRegex","contains","ctx","duration","console","createIndexesIfNeeded","getIndexes","updateSchemaWithIndexes","updateEstimatedCount","createTransactionalSession","commitTransactionalSession","abortTransactionalSession","ensureIndex","indexName","options","defaultIndexName","indexNameOptions","unique","ar","foundIndex","pt","INTERNAL_SERVER_ERROR","endsWith","replace","s","startsWith","literalizeRegexPart","isStartsWithRegex","firstValuesIsRegex","some","createLiteralRegex","remaining","RegExp","matcher1","result1","prefix","matcher2","result2"],"mappings":"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","sourcesContent":["// @flow\nimport { createClient } from './PostgresClient';\n// @flow-disable-next\nimport Parse from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\nimport sql from './sql';\n\nconst PostgresRelationDoesNotExistError = '42P01';\nconst PostgresDuplicateRelationError = '42P07';\nconst PostgresDuplicateColumnError = '42701';\nconst PostgresMissingColumnError = '42703';\nconst PostgresDuplicateObjectError = '42710';\nconst PostgresUniqueIndexViolationError = '23505';\nconst logger = require('../../../logger');\n\nconst debug = function (...args: any) {\n  args = ['PG: ' + arguments[0]].concat(args.slice(1, args.length));\n  const log = logger.getLogger();\n  log.debug.apply(log, args);\n};\n\nimport { StorageAdapter } from '../StorageAdapter';\nimport type { SchemaType, QueryType, QueryOptions } from '../StorageAdapter';\n\nconst parseTypeToPostgresType = type => {\n  switch (type.type) {\n    case 'String':\n      return 'text';\n    case 'Date':\n      return 'timestamp with time zone';\n    case 'Object':\n      return 'jsonb';\n    case 'File':\n      return 'text';\n    case 'Boolean':\n      return 'boolean';\n    case 'Pointer':\n      return 'text';\n    case 'Number':\n      return 'double precision';\n    case 'GeoPoint':\n      return 'point';\n    case 'Bytes':\n      return 'jsonb';\n    case 'Polygon':\n      return 'polygon';\n    case 'Array':\n      if (type.contents && type.contents.type === 'String') {\n        return 'text[]';\n      } else {\n        return 'jsonb';\n      }\n    default:\n      throw `no type for ${JSON.stringify(type)} yet`;\n  }\n};\n\nconst ParseToPosgresComparator = {\n  $gt: '>',\n  $lt: '<',\n  $gte: '>=',\n  $lte: '<=',\n};\n\nconst mongoAggregateToPostgres = {\n  $dayOfMonth: 'DAY',\n  $dayOfWeek: 'DOW',\n  $dayOfYear: 'DOY',\n  $isoDayOfWeek: 'ISODOW',\n  $isoWeekYear: 'ISOYEAR',\n  $hour: 'HOUR',\n  $minute: 'MINUTE',\n  $second: 'SECOND',\n  $millisecond: 'MILLISECONDS',\n  $month: 'MONTH',\n  $week: 'WEEK',\n  $year: 'YEAR',\n};\n\nconst toPostgresValue = value => {\n  if (typeof value === 'object') {\n    if (value.__type === 'Date') {\n      return value.iso;\n    }\n    if (value.__type === 'File') {\n      return value.name;\n    }\n  }\n  return value;\n};\n\nconst transformValue = value => {\n  if (typeof value === 'object' && value.__type === 'Pointer') {\n    return value.objectId;\n  }\n  return value;\n};\n\n// Duplicate from then mongo adapter...\nconst emptyCLPS = Object.freeze({\n  find: {},\n  get: {},\n  count: {},\n  create: {},\n  update: {},\n  delete: {},\n  addField: {},\n  protectedFields: {},\n});\n\nconst defaultCLPS = Object.freeze({\n  find: { '*': true },\n  get: { '*': true },\n  count: { '*': true },\n  create: { '*': true },\n  update: { '*': true },\n  delete: { '*': true },\n  addField: { '*': true },\n  protectedFields: { '*': [] },\n});\n\nconst toParseSchema = schema => {\n  if (schema.className === '_User') {\n    delete schema.fields._hashed_password;\n  }\n  if (schema.fields) {\n    delete schema.fields._wperm;\n    delete schema.fields._rperm;\n  }\n  let clps = defaultCLPS;\n  if (schema.classLevelPermissions) {\n    clps = { ...emptyCLPS, ...schema.classLevelPermissions };\n  }\n  let indexes = {};\n  if (schema.indexes) {\n    indexes = { ...schema.indexes };\n  }\n  return {\n    className: schema.className,\n    fields: schema.fields,\n    classLevelPermissions: clps,\n    indexes,\n  };\n};\n\nconst toPostgresSchema = schema => {\n  if (!schema) {\n    return schema;\n  }\n  schema.fields = schema.fields || {};\n  schema.fields._wperm = { type: 'Array', contents: { type: 'String' } };\n  schema.fields._rperm = { type: 'Array', contents: { type: 'String' } };\n  if (schema.className === '_User') {\n    schema.fields._hashed_password = { type: 'String' };\n    schema.fields._password_history = { type: 'Array' };\n  }\n  return schema;\n};\n\nconst handleDotFields = object => {\n  Object.keys(object).forEach(fieldName => {\n    if (fieldName.indexOf('.') > -1) {\n      const components = fieldName.split('.');\n      const first = components.shift();\n      object[first] = object[first] || {};\n      let currentObj = object[first];\n      let next;\n      let value = object[fieldName];\n      if (value && value.__op === 'Delete') {\n        value = undefined;\n      }\n      /* eslint-disable no-cond-assign */\n      while ((next = components.shift())) {\n        /* eslint-enable no-cond-assign */\n        currentObj[next] = currentObj[next] || {};\n        if (components.length === 0) {\n          currentObj[next] = value;\n        }\n        currentObj = currentObj[next];\n      }\n      delete object[fieldName];\n    }\n  });\n  return object;\n};\n\nconst transformDotFieldToComponents = fieldName => {\n  return fieldName.split('.').map((cmpt, index) => {\n    if (index === 0) {\n      return `\"${cmpt}\"`;\n    }\n    return `'${cmpt}'`;\n  });\n};\n\nconst transformDotField = fieldName => {\n  if (fieldName.indexOf('.') === -1) {\n    return `\"${fieldName}\"`;\n  }\n  const components = transformDotFieldToComponents(fieldName);\n  let name = components.slice(0, components.length - 1).join('->');\n  name += '->>' + components[components.length - 1];\n  return name;\n};\n\nconst transformAggregateField = fieldName => {\n  if (typeof fieldName !== 'string') {\n    return fieldName;\n  }\n  if (fieldName === '$_created_at') {\n    return 'createdAt';\n  }\n  if (fieldName === '$_updated_at') {\n    return 'updatedAt';\n  }\n  return fieldName.substr(1);\n};\n\nconst validateKeys = object => {\n  if (typeof object == 'object') {\n    for (const key in object) {\n      if (typeof object[key] == 'object') {\n        validateKeys(object[key]);\n      }\n\n      if (key.includes('$') || key.includes('.')) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_NESTED_KEY,\n          \"Nested keys should not contain the '$' or '.' characters\"\n        );\n      }\n    }\n  }\n};\n\n// Returns the list of join tables on a schema\nconst joinTablesForSchema = schema => {\n  const list = [];\n  if (schema) {\n    Object.keys(schema.fields).forEach(field => {\n      if (schema.fields[field].type === 'Relation') {\n        list.push(`_Join:${field}:${schema.className}`);\n      }\n    });\n  }\n  return list;\n};\n\ninterface WhereClause {\n  pattern: string;\n  values: Array<any>;\n  sorts: Array<any>;\n}\n\nconst buildWhereClause = ({ schema, query, index, caseInsensitive }): WhereClause => {\n  const patterns = [];\n  let values = [];\n  const sorts = [];\n\n  schema = toPostgresSchema(schema);\n  for (const fieldName in query) {\n    const isArrayField =\n      schema.fields && schema.fields[fieldName] && schema.fields[fieldName].type === 'Array';\n    const initialPatternsLength = patterns.length;\n    const fieldValue = query[fieldName];\n\n    // nothing in the schema, it's gonna blow up\n    if (!schema.fields[fieldName]) {\n      // as it won't exist\n      if (fieldValue && fieldValue.$exists === false) {\n        continue;\n      }\n    }\n\n    const authDataMatch = fieldName.match(/^_auth_data_([a-zA-Z0-9_]+)$/);\n    if (authDataMatch) {\n      // TODO: Handle querying by _auth_data_provider, authData is stored in authData field\n      continue;\n    } else if (caseInsensitive && (fieldName === 'username' || fieldName === 'email')) {\n      patterns.push(`LOWER($${index}:name) = LOWER($${index + 1})`);\n      values.push(fieldName, fieldValue);\n      index += 2;\n    } else if (fieldName.indexOf('.') >= 0) {\n      let name = transformDotField(fieldName);\n      if (fieldValue === null) {\n        patterns.push(`$${index}:raw IS NULL`);\n        values.push(name);\n        index += 1;\n        continue;\n      } else {\n        if (fieldValue.$in) {\n          name = transformDotFieldToComponents(fieldName).join('->');\n          patterns.push(`($${index}:raw)::jsonb @> $${index + 1}::jsonb`);\n          values.push(name, JSON.stringify(fieldValue.$in));\n          index += 2;\n        } else if (fieldValue.$regex) {\n          // Handle later\n        } else if (typeof fieldValue !== 'object') {\n          patterns.push(`$${index}:raw = $${index + 1}::text`);\n          values.push(name, fieldValue);\n          index += 2;\n        }\n      }\n    } else if (fieldValue === null || fieldValue === undefined) {\n      patterns.push(`$${index}:name IS NULL`);\n      values.push(fieldName);\n      index += 1;\n      continue;\n    } else if (typeof fieldValue === 'string') {\n      patterns.push(`$${index}:name = $${index + 1}`);\n      values.push(fieldName, fieldValue);\n      index += 2;\n    } else if (typeof fieldValue === 'boolean') {\n      patterns.push(`$${index}:name = $${index + 1}`);\n      // Can't cast boolean to double precision\n      if (schema.fields[fieldName] && schema.fields[fieldName].type === 'Number') {\n        // Should always return zero results\n        const MAX_INT_PLUS_ONE = 9223372036854775808;\n        values.push(fieldName, MAX_INT_PLUS_ONE);\n      } else {\n        values.push(fieldName, fieldValue);\n      }\n      index += 2;\n    } else if (typeof fieldValue === 'number') {\n      patterns.push(`$${index}:name = $${index + 1}`);\n      values.push(fieldName, fieldValue);\n      index += 2;\n    } else if (['$or', '$nor', '$and'].includes(fieldName)) {\n      const clauses = [];\n      const clauseValues = [];\n      fieldValue.forEach(subQuery => {\n        const clause = buildWhereClause({\n          schema,\n          query: subQuery,\n          index,\n          caseInsensitive,\n        });\n        if (clause.pattern.length > 0) {\n          clauses.push(clause.pattern);\n          clauseValues.push(...clause.values);\n          index += clause.values.length;\n        }\n      });\n\n      const orOrAnd = fieldName === '$and' ? ' AND ' : ' OR ';\n      const not = fieldName === '$nor' ? ' NOT ' : '';\n\n      patterns.push(`${not}(${clauses.join(orOrAnd)})`);\n      values.push(...clauseValues);\n    }\n\n    if (fieldValue.$ne !== undefined) {\n      if (isArrayField) {\n        fieldValue.$ne = JSON.stringify([fieldValue.$ne]);\n        patterns.push(`NOT array_contains($${index}:name, $${index + 1})`);\n      } else {\n        if (fieldValue.$ne === null) {\n          patterns.push(`$${index}:name IS NOT NULL`);\n          values.push(fieldName);\n          index += 1;\n          continue;\n        } else {\n          // if not null, we need to manually exclude null\n          if (fieldValue.$ne.__type === 'GeoPoint') {\n            patterns.push(\n              `($${index}:name <> POINT($${index + 1}, $${index + 2}) OR $${index}:name IS NULL)`\n            );\n          } else {\n            if (fieldName.indexOf('.') >= 0) {\n              const constraintFieldName = transformDotField(fieldName);\n              patterns.push(\n                `(${constraintFieldName} <> $${index} OR ${constraintFieldName} IS NULL)`\n              );\n            } else {\n              patterns.push(`($${index}:name <> $${index + 1} OR $${index}:name IS NULL)`);\n            }\n          }\n        }\n      }\n      if (fieldValue.$ne.__type === 'GeoPoint') {\n        const point = fieldValue.$ne;\n        values.push(fieldName, point.longitude, point.latitude);\n        index += 3;\n      } else {\n        // TODO: support arrays\n        values.push(fieldName, fieldValue.$ne);\n        index += 2;\n      }\n    }\n    if (fieldValue.$eq !== undefined) {\n      if (fieldValue.$eq === null) {\n        patterns.push(`$${index}:name IS NULL`);\n        values.push(fieldName);\n        index += 1;\n      } else {\n        if (fieldName.indexOf('.') >= 0) {\n          values.push(fieldValue.$eq);\n          patterns.push(`${transformDotField(fieldName)} = $${index++}`);\n        } else {\n          values.push(fieldName, fieldValue.$eq);\n          patterns.push(`$${index}:name = $${index + 1}`);\n          index += 2;\n        }\n      }\n    }\n    const isInOrNin = Array.isArray(fieldValue.$in) || Array.isArray(fieldValue.$nin);\n    if (\n      Array.isArray(fieldValue.$in) &&\n      isArrayField &&\n      schema.fields[fieldName].contents &&\n      schema.fields[fieldName].contents.type === 'String'\n    ) {\n      const inPatterns = [];\n      let allowNull = false;\n      values.push(fieldName);\n      fieldValue.$in.forEach((listElem, listIndex) => {\n        if (listElem === null) {\n          allowNull = true;\n        } else {\n          values.push(listElem);\n          inPatterns.push(`$${index + 1 + listIndex - (allowNull ? 1 : 0)}`);\n        }\n      });\n      if (allowNull) {\n        patterns.push(`($${index}:name IS NULL OR $${index}:name && ARRAY[${inPatterns.join()}])`);\n      } else {\n        patterns.push(`$${index}:name && ARRAY[${inPatterns.join()}]`);\n      }\n      index = index + 1 + inPatterns.length;\n    } else if (isInOrNin) {\n      var createConstraint = (baseArray, notIn) => {\n        const not = notIn ? ' NOT ' : '';\n        if (baseArray.length > 0) {\n          if (isArrayField) {\n            patterns.push(`${not} array_contains($${index}:name, $${index + 1})`);\n            values.push(fieldName, JSON.stringify(baseArray));\n            index += 2;\n          } else {\n            // Handle Nested Dot Notation Above\n            if (fieldName.indexOf('.') >= 0) {\n              return;\n            }\n            const inPatterns = [];\n            values.push(fieldName);\n            baseArray.forEach((listElem, listIndex) => {\n              if (listElem != null) {\n                values.push(listElem);\n                inPatterns.push(`$${index + 1 + listIndex}`);\n              }\n            });\n            patterns.push(`$${index}:name ${not} IN (${inPatterns.join()})`);\n            index = index + 1 + inPatterns.length;\n          }\n        } else if (!notIn) {\n          values.push(fieldName);\n          patterns.push(`$${index}:name IS NULL`);\n          index = index + 1;\n        } else {\n          // Handle empty array\n          if (notIn) {\n            patterns.push('1 = 1'); // Return all values\n          } else {\n            patterns.push('1 = 2'); // Return no values\n          }\n        }\n      };\n      if (fieldValue.$in) {\n        createConstraint(\n          _.flatMap(fieldValue.$in, elt => elt),\n          false\n        );\n      }\n      if (fieldValue.$nin) {\n        createConstraint(\n          _.flatMap(fieldValue.$nin, elt => elt),\n          true\n        );\n      }\n    } else if (typeof fieldValue.$in !== 'undefined') {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $in value');\n    } else if (typeof fieldValue.$nin !== 'undefined') {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $nin value');\n    }\n\n    if (Array.isArray(fieldValue.$all) && isArrayField) {\n      if (isAnyValueRegexStartsWith(fieldValue.$all)) {\n        if (!isAllValuesRegexOrNone(fieldValue.$all)) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_JSON,\n            'All $all values must be of regex type or none: ' + fieldValue.$all\n          );\n        }\n\n        for (let i = 0; i < fieldValue.$all.length; i += 1) {\n          const value = processRegexPattern(fieldValue.$all[i].$regex);\n          fieldValue.$all[i] = value.substring(1) + '%';\n        }\n        patterns.push(`array_contains_all_regex($${index}:name, $${index + 1}::jsonb)`);\n      } else {\n        patterns.push(`array_contains_all($${index}:name, $${index + 1}::jsonb)`);\n      }\n      values.push(fieldName, JSON.stringify(fieldValue.$all));\n      index += 2;\n    } else if (Array.isArray(fieldValue.$all)) {\n      if (fieldValue.$all.length === 1) {\n        patterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue.$all[0].objectId);\n        index += 2;\n      }\n    }\n\n    if (typeof fieldValue.$exists !== 'undefined') {\n      if (fieldValue.$exists) {\n        patterns.push(`$${index}:name IS NOT NULL`);\n      } else {\n        patterns.push(`$${index}:name IS NULL`);\n      }\n      values.push(fieldName);\n      index += 1;\n    }\n\n    if (fieldValue.$containedBy) {\n      const arr = fieldValue.$containedBy;\n      if (!(arr instanceof Array)) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, `bad $containedBy: should be an array`);\n      }\n\n      patterns.push(`$${index}:name <@ $${index + 1}::jsonb`);\n      values.push(fieldName, JSON.stringify(arr));\n      index += 2;\n    }\n\n    if (fieldValue.$text) {\n      const search = fieldValue.$text.$search;\n      let language = 'english';\n      if (typeof search !== 'object') {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, `bad $text: $search, should be object`);\n      }\n      if (!search.$term || typeof search.$term !== 'string') {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, `bad $text: $term, should be string`);\n      }\n      if (search.$language && typeof search.$language !== 'string') {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, `bad $text: $language, should be string`);\n      } else if (search.$language) {\n        language = search.$language;\n      }\n      if (search.$caseSensitive && typeof search.$caseSensitive !== 'boolean') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $caseSensitive, should be boolean`\n        );\n      } else if (search.$caseSensitive) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $caseSensitive not supported, please use $regex or create a separate lower case column.`\n        );\n      }\n      if (search.$diacriticSensitive && typeof search.$diacriticSensitive !== 'boolean') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $diacriticSensitive, should be boolean`\n        );\n      } else if (search.$diacriticSensitive === false) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $diacriticSensitive - false not supported, install Postgres Unaccent Extension`\n        );\n      }\n      patterns.push(\n        `to_tsvector($${index}, $${index + 1}:name) @@ to_tsquery($${index + 2}, $${index + 3})`\n      );\n      values.push(language, fieldName, language, search.$term);\n      index += 4;\n    }\n\n    if (fieldValue.$nearSphere) {\n      const point = fieldValue.$nearSphere;\n      const distance = fieldValue.$maxDistance;\n      const distanceInKM = distance * 6371 * 1000;\n      patterns.push(\n        `ST_DistanceSphere($${index}:name::geometry, POINT($${index + 1}, $${\n          index + 2\n        })::geometry) <= $${index + 3}`\n      );\n      sorts.push(\n        `ST_DistanceSphere($${index}:name::geometry, POINT($${index + 1}, $${\n          index + 2\n        })::geometry) ASC`\n      );\n      values.push(fieldName, point.longitude, point.latitude, distanceInKM);\n      index += 4;\n    }\n\n    if (fieldValue.$within && fieldValue.$within.$box) {\n      const box = fieldValue.$within.$box;\n      const left = box[0].longitude;\n      const bottom = box[0].latitude;\n      const right = box[1].longitude;\n      const top = box[1].latitude;\n\n      patterns.push(`$${index}:name::point <@ $${index + 1}::box`);\n      values.push(fieldName, `((${left}, ${bottom}), (${right}, ${top}))`);\n      index += 2;\n    }\n\n    if (fieldValue.$geoWithin && fieldValue.$geoWithin.$centerSphere) {\n      const centerSphere = fieldValue.$geoWithin.$centerSphere;\n      if (!(centerSphere instanceof Array) || centerSphere.length < 2) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          'bad $geoWithin value; $centerSphere should be an array of Parse.GeoPoint and distance'\n        );\n      }\n      // Get point, convert to geo point if necessary and validate\n      let point = centerSphere[0];\n      if (point instanceof Array && point.length === 2) {\n        point = new Parse.GeoPoint(point[1], point[0]);\n      } else if (!GeoPointCoder.isValidJSON(point)) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          'bad $geoWithin value; $centerSphere geo point invalid'\n        );\n      }\n      Parse.GeoPoint._validate(point.latitude, point.longitude);\n      // Get distance and validate\n      const distance = centerSphere[1];\n      if (isNaN(distance) || distance < 0) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          'bad $geoWithin value; $centerSphere distance invalid'\n        );\n      }\n      const distanceInKM = distance * 6371 * 1000;\n      patterns.push(\n        `ST_DistanceSphere($${index}:name::geometry, POINT($${index + 1}, $${\n          index + 2\n        })::geometry) <= $${index + 3}`\n      );\n      values.push(fieldName, point.longitude, point.latitude, distanceInKM);\n      index += 4;\n    }\n\n    if (fieldValue.$geoWithin && fieldValue.$geoWithin.$polygon) {\n      const polygon = fieldValue.$geoWithin.$polygon;\n      let points;\n      if (typeof polygon === 'object' && polygon.__type === 'Polygon') {\n        if (!polygon.coordinates || polygon.coordinates.length < 3) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_JSON,\n            'bad $geoWithin value; Polygon.coordinates should contain at least 3 lon/lat pairs'\n          );\n        }\n        points = polygon.coordinates;\n      } else if (polygon instanceof Array) {\n        if (polygon.length < 3) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_JSON,\n            'bad $geoWithin value; $polygon should contain at least 3 GeoPoints'\n          );\n        }\n        points = polygon;\n      } else {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          \"bad $geoWithin value; $polygon should be Polygon object or Array of Parse.GeoPoint's\"\n        );\n      }\n      points = points\n        .map(point => {\n          if (point instanceof Array && point.length === 2) {\n            Parse.GeoPoint._validate(point[1], point[0]);\n            return `(${point[0]}, ${point[1]})`;\n          }\n          if (typeof point !== 'object' || point.__type !== 'GeoPoint') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $geoWithin value');\n          } else {\n            Parse.GeoPoint._validate(point.latitude, point.longitude);\n          }\n          return `(${point.longitude}, ${point.latitude})`;\n        })\n        .join(', ');\n\n      patterns.push(`$${index}:name::point <@ $${index + 1}::polygon`);\n      values.push(fieldName, `(${points})`);\n      index += 2;\n    }\n    if (fieldValue.$geoIntersects && fieldValue.$geoIntersects.$point) {\n      const point = fieldValue.$geoIntersects.$point;\n      if (typeof point !== 'object' || point.__type !== 'GeoPoint') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          'bad $geoIntersect value; $point should be GeoPoint'\n        );\n      } else {\n        Parse.GeoPoint._validate(point.latitude, point.longitude);\n      }\n      patterns.push(`$${index}:name::polygon @> $${index + 1}::point`);\n      values.push(fieldName, `(${point.longitude}, ${point.latitude})`);\n      index += 2;\n    }\n\n    if (fieldValue.$regex) {\n      let regex = fieldValue.$regex;\n      let operator = '~';\n      const opts = fieldValue.$options;\n      if (opts) {\n        if (opts.indexOf('i') >= 0) {\n          operator = '~*';\n        }\n        if (opts.indexOf('x') >= 0) {\n          regex = removeWhiteSpace(regex);\n        }\n      }\n\n      const name = transformDotField(fieldName);\n      regex = processRegexPattern(regex);\n\n      patterns.push(`$${index}:raw ${operator} '$${index + 1}:raw'`);\n      values.push(name, regex);\n      index += 2;\n    }\n\n    if (fieldValue.__type === 'Pointer') {\n      if (isArrayField) {\n        patterns.push(`array_contains($${index}:name, $${index + 1})`);\n        values.push(fieldName, JSON.stringify([fieldValue]));\n        index += 2;\n      } else {\n        patterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue.objectId);\n        index += 2;\n      }\n    }\n\n    if (fieldValue.__type === 'Date') {\n      patterns.push(`$${index}:name = $${index + 1}`);\n      values.push(fieldName, fieldValue.iso);\n      index += 2;\n    }\n\n    if (fieldValue.__type === 'GeoPoint') {\n      patterns.push(`$${index}:name ~= POINT($${index + 1}, $${index + 2})`);\n      values.push(fieldName, fieldValue.longitude, fieldValue.latitude);\n      index += 3;\n    }\n\n    if (fieldValue.__type === 'Polygon') {\n      const value = convertPolygonToSQL(fieldValue.coordinates);\n      patterns.push(`$${index}:name ~= $${index + 1}::polygon`);\n      values.push(fieldName, value);\n      index += 2;\n    }\n\n    Object.keys(ParseToPosgresComparator).forEach(cmp => {\n      if (fieldValue[cmp] || fieldValue[cmp] === 0) {\n        const pgComparator = ParseToPosgresComparator[cmp];\n        const postgresValue = toPostgresValue(fieldValue[cmp]);\n        let constraintFieldName;\n        if (fieldName.indexOf('.') >= 0) {\n          let castType;\n          switch (typeof postgresValue) {\n            case 'number':\n              castType = 'double precision';\n              break;\n            case 'boolean':\n              castType = 'boolean';\n              break;\n            default:\n              castType = undefined;\n          }\n          constraintFieldName = castType\n            ? `CAST ((${transformDotField(fieldName)}) AS ${castType})`\n            : transformDotField(fieldName);\n        } else {\n          constraintFieldName = `$${index++}:name`;\n          values.push(fieldName);\n        }\n        values.push(postgresValue);\n        patterns.push(`${constraintFieldName} ${pgComparator} $${index++}`);\n      }\n    });\n\n    if (initialPatternsLength === patterns.length) {\n      throw new Parse.Error(\n        Parse.Error.OPERATION_FORBIDDEN,\n        `Postgres doesn't support this query type yet ${JSON.stringify(fieldValue)}`\n      );\n    }\n  }\n  values = values.map(transformValue);\n  return { pattern: patterns.join(' AND '), values, sorts };\n};\n\nexport class PostgresStorageAdapter implements StorageAdapter {\n  canSortOnJoinTables: boolean;\n\n  // Private\n  _collectionPrefix: string;\n  _client: any;\n  _pgp: any;\n\n  constructor({ uri, collectionPrefix = '', databaseOptions }: any) {\n    this._collectionPrefix = collectionPrefix;\n    const { client, pgp } = createClient(uri, databaseOptions);\n    this._client = client;\n    this._pgp = pgp;\n    this.canSortOnJoinTables = false;\n  }\n\n  //Note that analyze=true will run the query, executing INSERTS, DELETES, etc.\n  createExplainableQuery(query: string, analyze: boolean = false) {\n    if (analyze) {\n      return 'EXPLAIN (ANALYZE, FORMAT JSON) ' + query;\n    } else {\n      return 'EXPLAIN (FORMAT JSON) ' + query;\n    }\n  }\n\n  handleShutdown() {\n    if (!this._client) {\n      return;\n    }\n    this._client.$pool.end();\n  }\n\n  async _ensureSchemaCollectionExists(conn: any) {\n    conn = conn || this._client;\n    await conn\n      .none(\n        'CREATE TABLE IF NOT EXISTS \"_SCHEMA\" ( \"className\" varChar(120), \"schema\" jsonb, \"isParseClass\" bool, PRIMARY KEY (\"className\") )'\n      )\n      .catch(error => {\n        if (\n          error.code === PostgresDuplicateRelationError ||\n          error.code === PostgresUniqueIndexViolationError ||\n          error.code === PostgresDuplicateObjectError\n        ) {\n          // Table already exists, must have been created by a different request. Ignore error.\n        } else {\n          throw error;\n        }\n      });\n  }\n\n  async classExists(name: string) {\n    return this._client.one(\n      'SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = $1)',\n      [name],\n      a => a.exists\n    );\n  }\n\n  async setClassLevelPermissions(className: string, CLPs: any) {\n    const self = this;\n    await this._client.task('set-class-level-permissions', async t => {\n      await self._ensureSchemaCollectionExists(t);\n      const values = [className, 'schema', 'classLevelPermissions', JSON.stringify(CLPs)];\n      await t.none(\n        `UPDATE \"_SCHEMA\" SET $2:name = json_object_set_key($2:name, $3::text, $4::jsonb) WHERE \"className\" = $1`,\n        values\n      );\n    });\n  }\n\n  async setIndexesWithSchemaFormat(\n    className: string,\n    submittedIndexes: any,\n    existingIndexes: any = {},\n    fields: any,\n    conn: ?any\n  ): Promise<void> {\n    conn = conn || this._client;\n    const self = this;\n    if (submittedIndexes === undefined) {\n      return Promise.resolve();\n    }\n    if (Object.keys(existingIndexes).length === 0) {\n      existingIndexes = { _id_: { _id: 1 } };\n    }\n    const deletedIndexes = [];\n    const insertedIndexes = [];\n    Object.keys(submittedIndexes).forEach(name => {\n      const field = submittedIndexes[name];\n      if (existingIndexes[name] && field.__op !== 'Delete') {\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, `Index ${name} exists, cannot update.`);\n      }\n      if (!existingIndexes[name] && field.__op === 'Delete') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_QUERY,\n          `Index ${name} does not exist, cannot delete.`\n        );\n      }\n      if (field.__op === 'Delete') {\n        deletedIndexes.push(name);\n        delete existingIndexes[name];\n      } else {\n        Object.keys(field).forEach(key => {\n          if (!Object.prototype.hasOwnProperty.call(fields, key)) {\n            throw new Parse.Error(\n              Parse.Error.INVALID_QUERY,\n              `Field ${key} does not exist, cannot add index.`\n            );\n          }\n        });\n        existingIndexes[name] = field;\n        insertedIndexes.push({\n          key: field,\n          name,\n        });\n      }\n    });\n    await conn.tx('set-indexes-with-schema-format', async t => {\n      if (insertedIndexes.length > 0) {\n        await self.createIndexes(className, insertedIndexes, t);\n      }\n      if (deletedIndexes.length > 0) {\n        await self.dropIndexes(className, deletedIndexes, t);\n      }\n      await self._ensureSchemaCollectionExists(t);\n      await t.none(\n        'UPDATE \"_SCHEMA\" SET $2:name = json_object_set_key($2:name, $3::text, $4::jsonb) WHERE \"className\" = $1',\n        [className, 'schema', 'indexes', JSON.stringify(existingIndexes)]\n      );\n    });\n  }\n\n  async createClass(className: string, schema: SchemaType, conn: ?any) {\n    conn = conn || this._client;\n    return conn\n      .tx('create-class', async t => {\n        await this.createTable(className, schema, t);\n        await t.none(\n          'INSERT INTO \"_SCHEMA\" (\"className\", \"schema\", \"isParseClass\") VALUES ($<className>, $<schema>, true)',\n          { className, schema }\n        );\n        await this.setIndexesWithSchemaFormat(className, schema.indexes, {}, schema.fields, t);\n        return toParseSchema(schema);\n      })\n      .catch(err => {\n        if (err.code === PostgresUniqueIndexViolationError && err.detail.includes(className)) {\n          throw new Parse.Error(Parse.Error.DUPLICATE_VALUE, `Class ${className} already exists.`);\n        }\n        throw err;\n      });\n  }\n\n  // Just create a table, do not insert in schema\n  async createTable(className: string, schema: SchemaType, conn: any) {\n    conn = conn || this._client;\n    const self = this;\n    debug('createTable', className, schema);\n    const valuesArray = [];\n    const patternsArray = [];\n    const fields = Object.assign({}, schema.fields);\n    if (className === '_User') {\n      fields._email_verify_token_expires_at = { type: 'Date' };\n      fields._email_verify_token = { type: 'String' };\n      fields._account_lockout_expires_at = { type: 'Date' };\n      fields._failed_login_count = { type: 'Number' };\n      fields._perishable_token = { type: 'String' };\n      fields._perishable_token_expires_at = { type: 'Date' };\n      fields._password_changed_at = { type: 'Date' };\n      fields._password_history = { type: 'Array' };\n    }\n    let index = 2;\n    const relations = [];\n    Object.keys(fields).forEach(fieldName => {\n      const parseType = fields[fieldName];\n      // Skip when it's a relation\n      // We'll create the tables later\n      if (parseType.type === 'Relation') {\n        relations.push(fieldName);\n        return;\n      }\n      if (['_rperm', '_wperm'].indexOf(fieldName) >= 0) {\n        parseType.contents = { type: 'String' };\n      }\n      valuesArray.push(fieldName);\n      valuesArray.push(parseTypeToPostgresType(parseType));\n      patternsArray.push(`$${index}:name $${index + 1}:raw`);\n      if (fieldName === 'objectId') {\n        patternsArray.push(`PRIMARY KEY ($${index}:name)`);\n      }\n      index = index + 2;\n    });\n    const qs = `CREATE TABLE IF NOT EXISTS $1:name (${patternsArray.join()})`;\n    const values = [className, ...valuesArray];\n\n    debug(qs, values);\n    return conn.task('create-table', async t => {\n      try {\n        await self._ensureSchemaCollectionExists(t);\n        await t.none(qs, values);\n      } catch (error) {\n        if (error.code !== PostgresDuplicateRelationError) {\n          throw error;\n        }\n        // ELSE: Table already exists, must have been created by a different request. Ignore the error.\n      }\n      await t.tx('create-table-tx', tx => {\n        return tx.batch(\n          relations.map(fieldName => {\n            return tx.none(\n              'CREATE TABLE IF NOT EXISTS $<joinTable:name> (\"relatedId\" varChar(120), \"owningId\" varChar(120), PRIMARY KEY(\"relatedId\", \"owningId\") )',\n              { joinTable: `_Join:${fieldName}:${className}` }\n            );\n          })\n        );\n      });\n    });\n  }\n\n  async schemaUpgrade(className: string, schema: SchemaType, conn: any) {\n    debug('schemaUpgrade', { className, schema });\n    conn = conn || this._client;\n    const self = this;\n\n    await conn.tx('schema-upgrade', async t => {\n      const columns = await t.map(\n        'SELECT column_name FROM information_schema.columns WHERE table_name = $<className>',\n        { className },\n        a => a.column_name\n      );\n      const newColumns = Object.keys(schema.fields)\n        .filter(item => columns.indexOf(item) === -1)\n        .map(fieldName =>\n          self.addFieldIfNotExists(className, fieldName, schema.fields[fieldName], t)\n        );\n\n      await t.batch(newColumns);\n    });\n  }\n\n  async addFieldIfNotExists(className: string, fieldName: string, type: any, conn: any) {\n    // TODO: Must be revised for invalid logic...\n    debug('addFieldIfNotExists', { className, fieldName, type });\n    conn = conn || this._client;\n    const self = this;\n    await conn.tx('add-field-if-not-exists', async t => {\n      if (type.type !== 'Relation') {\n        try {\n          await t.none(\n            'ALTER TABLE $<className:name> ADD COLUMN IF NOT EXISTS $<fieldName:name> $<postgresType:raw>',\n            {\n              className,\n              fieldName,\n              postgresType: parseTypeToPostgresType(type),\n            }\n          );\n        } catch (error) {\n          if (error.code === PostgresRelationDoesNotExistError) {\n            return self.createClass(className, { fields: { [fieldName]: type } }, t);\n          }\n          if (error.code !== PostgresDuplicateColumnError) {\n            throw error;\n          }\n          // Column already exists, created by other request. Carry on to see if it's the right type.\n        }\n      } else {\n        await t.none(\n          'CREATE TABLE IF NOT EXISTS $<joinTable:name> (\"relatedId\" varChar(120), \"owningId\" varChar(120), PRIMARY KEY(\"relatedId\", \"owningId\") )',\n          { joinTable: `_Join:${fieldName}:${className}` }\n        );\n      }\n\n      const result = await t.any(\n        'SELECT \"schema\" FROM \"_SCHEMA\" WHERE \"className\" = $<className> and (\"schema\"::json->\\'fields\\'->$<fieldName>) is not null',\n        { className, fieldName }\n      );\n\n      if (result[0]) {\n        throw 'Attempted to add a field that already exists';\n      } else {\n        const path = `{fields,${fieldName}}`;\n        await t.none(\n          'UPDATE \"_SCHEMA\" SET \"schema\"=jsonb_set(\"schema\", $<path>, $<type>)  WHERE \"className\"=$<className>',\n          { path, type, className }\n        );\n      }\n    });\n  }\n\n  // Drops a collection. Resolves with true if it was a Parse Schema (eg. _User, Custom, etc.)\n  // and resolves with false if it wasn't (eg. a join table). Rejects if deletion was impossible.\n  async deleteClass(className: string) {\n    const operations = [\n      { query: `DROP TABLE IF EXISTS $1:name`, values: [className] },\n      {\n        query: `DELETE FROM \"_SCHEMA\" WHERE \"className\" = $1`,\n        values: [className],\n      },\n    ];\n    return this._client\n      .tx(t => t.none(this._pgp.helpers.concat(operations)))\n      .then(() => className.indexOf('_Join:') != 0); // resolves with false when _Join table\n  }\n\n  // Delete all data known to this adapter. Used for testing.\n  async deleteAllClasses() {\n    const now = new Date().getTime();\n    const helpers = this._pgp.helpers;\n    debug('deleteAllClasses');\n\n    await this._client\n      .task('delete-all-classes', async t => {\n        try {\n          const results = await t.any('SELECT * FROM \"_SCHEMA\"');\n          const joins = results.reduce((list: Array<string>, schema: any) => {\n            return list.concat(joinTablesForSchema(schema.schema));\n          }, []);\n          const classes = [\n            '_SCHEMA',\n            '_PushStatus',\n            '_JobStatus',\n            '_JobSchedule',\n            '_Hooks',\n            '_GlobalConfig',\n            '_GraphQLConfig',\n            '_Audience',\n            '_Idempotency',\n            ...results.map(result => result.className),\n            ...joins,\n          ];\n          const queries = classes.map(className => ({\n            query: 'DROP TABLE IF EXISTS $<className:name>',\n            values: { className },\n          }));\n          await t.tx(tx => tx.none(helpers.concat(queries)));\n        } catch (error) {\n          if (error.code !== PostgresRelationDoesNotExistError) {\n            throw error;\n          }\n          // No _SCHEMA collection. Don't delete anything.\n        }\n      })\n      .then(() => {\n        debug(`deleteAllClasses done in ${new Date().getTime() - now}`);\n      });\n  }\n\n  // Remove the column and all the data. For Relations, the _Join collection is handled\n  // specially, this function does not delete _Join columns. It should, however, indicate\n  // that the relation fields does not exist anymore. In mongo, this means removing it from\n  // the _SCHEMA collection.  There should be no actual data in the collection under the same name\n  // as the relation column, so it's fine to attempt to delete it. If the fields listed to be\n  // deleted do not exist, this function should return successfully anyways. Checking for\n  // attempts to delete non-existent fields is the responsibility of Parse Server.\n\n  // This function is not obligated to delete fields atomically. It is given the field\n  // names in a list so that databases that are capable of deleting fields atomically\n  // may do so.\n\n  // Returns a Promise.\n  async deleteFields(className: string, schema: SchemaType, fieldNames: string[]): Promise<void> {\n    debug('deleteFields', className, fieldNames);\n    fieldNames = fieldNames.reduce((list: Array<string>, fieldName: string) => {\n      const field = schema.fields[fieldName];\n      if (field.type !== 'Relation') {\n        list.push(fieldName);\n      }\n      delete schema.fields[fieldName];\n      return list;\n    }, []);\n\n    const values = [className, ...fieldNames];\n    const columns = fieldNames\n      .map((name, idx) => {\n        return `$${idx + 2}:name`;\n      })\n      .join(', DROP COLUMN');\n\n    await this._client.tx('delete-fields', async t => {\n      await t.none('UPDATE \"_SCHEMA\" SET \"schema\" = $<schema> WHERE \"className\" = $<className>', {\n        schema,\n        className,\n      });\n      if (values.length > 1) {\n        await t.none(`ALTER TABLE $1:name DROP COLUMN IF EXISTS ${columns}`, values);\n      }\n    });\n  }\n\n  // Return a promise for all schemas known to this adapter, in Parse format. In case the\n  // schemas cannot be retrieved, returns a promise that rejects. Requirements for the\n  // rejection reason are TBD.\n  async getAllClasses() {\n    const self = this;\n    return this._client.task('get-all-classes', async t => {\n      await self._ensureSchemaCollectionExists(t);\n      return await t.map('SELECT * FROM \"_SCHEMA\"', null, row =>\n        toParseSchema({ className: row.className, ...row.schema })\n      );\n    });\n  }\n\n  // Return a promise for the schema with the given name, in Parse format. If\n  // this adapter doesn't know about the schema, return a promise that rejects with\n  // undefined as the reason.\n  async getClass(className: string) {\n    debug('getClass', className);\n    return this._client\n      .any('SELECT * FROM \"_SCHEMA\" WHERE \"className\" = $<className>', {\n        className,\n      })\n      .then(result => {\n        if (result.length !== 1) {\n          throw undefined;\n        }\n        return result[0].schema;\n      })\n      .then(toParseSchema);\n  }\n\n  // TODO: remove the mongo format dependency in the return value\n  async createObject(\n    className: string,\n    schema: SchemaType,\n    object: any,\n    transactionalSession: ?any\n  ) {\n    debug('createObject', className, object);\n    let columnsArray = [];\n    const valuesArray = [];\n    schema = toPostgresSchema(schema);\n    const geoPoints = {};\n\n    object = handleDotFields(object);\n\n    validateKeys(object);\n\n    Object.keys(object).forEach(fieldName => {\n      if (object[fieldName] === null) {\n        return;\n      }\n      var authDataMatch = fieldName.match(/^_auth_data_([a-zA-Z0-9_]+)$/);\n      if (authDataMatch) {\n        var provider = authDataMatch[1];\n        object['authData'] = object['authData'] || {};\n        object['authData'][provider] = object[fieldName];\n        delete object[fieldName];\n        fieldName = 'authData';\n      }\n\n      columnsArray.push(fieldName);\n      if (!schema.fields[fieldName] && className === '_User') {\n        if (\n          fieldName === '_email_verify_token' ||\n          fieldName === '_failed_login_count' ||\n          fieldName === '_perishable_token' ||\n          fieldName === '_password_history'\n        ) {\n          valuesArray.push(object[fieldName]);\n        }\n\n        if (fieldName === '_email_verify_token_expires_at') {\n          if (object[fieldName]) {\n            valuesArray.push(object[fieldName].iso);\n          } else {\n            valuesArray.push(null);\n          }\n        }\n\n        if (\n          fieldName === '_account_lockout_expires_at' ||\n          fieldName === '_perishable_token_expires_at' ||\n          fieldName === '_password_changed_at'\n        ) {\n          if (object[fieldName]) {\n            valuesArray.push(object[fieldName].iso);\n          } else {\n            valuesArray.push(null);\n          }\n        }\n        return;\n      }\n      switch (schema.fields[fieldName].type) {\n        case 'Date':\n          if (object[fieldName]) {\n            valuesArray.push(object[fieldName].iso);\n          } else {\n            valuesArray.push(null);\n          }\n          break;\n        case 'Pointer':\n          valuesArray.push(object[fieldName].objectId);\n          break;\n        case 'Array':\n          if (['_rperm', '_wperm'].indexOf(fieldName) >= 0) {\n            valuesArray.push(object[fieldName]);\n          } else {\n            valuesArray.push(JSON.stringify(object[fieldName]));\n          }\n          break;\n        case 'Object':\n        case 'Bytes':\n        case 'String':\n        case 'Number':\n        case 'Boolean':\n          valuesArray.push(object[fieldName]);\n          break;\n        case 'File':\n          valuesArray.push(object[fieldName].name);\n          break;\n        case 'Polygon': {\n          const value = convertPolygonToSQL(object[fieldName].coordinates);\n          valuesArray.push(value);\n          break;\n        }\n        case 'GeoPoint':\n          // pop the point and process later\n          geoPoints[fieldName] = object[fieldName];\n          columnsArray.pop();\n          break;\n        default:\n          throw `Type ${schema.fields[fieldName].type} not supported yet`;\n      }\n    });\n\n    columnsArray = columnsArray.concat(Object.keys(geoPoints));\n    const initialValues = valuesArray.map((val, index) => {\n      let termination = '';\n      const fieldName = columnsArray[index];\n      if (['_rperm', '_wperm'].indexOf(fieldName) >= 0) {\n        termination = '::text[]';\n      } else if (schema.fields[fieldName] && schema.fields[fieldName].type === 'Array') {\n        termination = '::jsonb';\n      }\n      return `$${index + 2 + columnsArray.length}${termination}`;\n    });\n    const geoPointsInjects = Object.keys(geoPoints).map(key => {\n      const value = geoPoints[key];\n      valuesArray.push(value.longitude, value.latitude);\n      const l = valuesArray.length + columnsArray.length;\n      return `POINT($${l}, $${l + 1})`;\n    });\n\n    const columnsPattern = columnsArray.map((col, index) => `$${index + 2}:name`).join();\n    const valuesPattern = initialValues.concat(geoPointsInjects).join();\n\n    const qs = `INSERT INTO $1:name (${columnsPattern}) VALUES (${valuesPattern})`;\n    const values = [className, ...columnsArray, ...valuesArray];\n    debug(qs, values);\n    const promise = (transactionalSession ? transactionalSession.t : this._client)\n      .none(qs, values)\n      .then(() => ({ ops: [object] }))\n      .catch(error => {\n        if (error.code === PostgresUniqueIndexViolationError) {\n          const err = new Parse.Error(\n            Parse.Error.DUPLICATE_VALUE,\n            'A duplicate value for a field with unique values was provided'\n          );\n          err.underlyingError = error;\n          if (error.constraint) {\n            const matches = error.constraint.match(/unique_([a-zA-Z]+)/);\n            if (matches && Array.isArray(matches)) {\n              err.userInfo = { duplicated_field: matches[1] };\n            }\n          }\n          error = err;\n        }\n        throw error;\n      });\n    if (transactionalSession) {\n      transactionalSession.batch.push(promise);\n    }\n    return promise;\n  }\n\n  // Remove all objects that match the given Parse Query.\n  // If no objects match, reject with OBJECT_NOT_FOUND. If objects are found and deleted, resolve with undefined.\n  // If there is some other error, reject with INTERNAL_SERVER_ERROR.\n  async deleteObjectsByQuery(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    transactionalSession: ?any\n  ) {\n    debug('deleteObjectsByQuery', className, query);\n    const values = [className];\n    const index = 2;\n    const where = buildWhereClause({\n      schema,\n      index,\n      query,\n      caseInsensitive: false,\n    });\n    values.push(...where.values);\n    if (Object.keys(query).length === 0) {\n      where.pattern = 'TRUE';\n    }\n    const qs = `WITH deleted AS (DELETE FROM $1:name WHERE ${where.pattern} RETURNING *) SELECT count(*) FROM deleted`;\n    debug(qs, values);\n    const promise = (transactionalSession ? transactionalSession.t : this._client)\n      .one(qs, values, a => +a.count)\n      .then(count => {\n        if (count === 0) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        } else {\n          return count;\n        }\n      })\n      .catch(error => {\n        if (error.code !== PostgresRelationDoesNotExistError) {\n          throw error;\n        }\n        // ELSE: Don't delete anything if doesn't exist\n      });\n    if (transactionalSession) {\n      transactionalSession.batch.push(promise);\n    }\n    return promise;\n  }\n  // Return value not currently well specified.\n  async findOneAndUpdate(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ): Promise<any> {\n    debug('findOneAndUpdate', className, query, update);\n    return this.updateObjectsByQuery(className, schema, query, update, transactionalSession).then(\n      val => val[0]\n    );\n  }\n\n  // Apply the update to all objects that match the given Parse Query.\n  async updateObjectsByQuery(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ): Promise<[any]> {\n    debug('updateObjectsByQuery', className, query, update);\n    const updatePatterns = [];\n    const values = [className];\n    let index = 2;\n    schema = toPostgresSchema(schema);\n\n    const originalUpdate = { ...update };\n\n    // Set flag for dot notation fields\n    const dotNotationOptions = {};\n    Object.keys(update).forEach(fieldName => {\n      if (fieldName.indexOf('.') > -1) {\n        const components = fieldName.split('.');\n        const first = components.shift();\n        dotNotationOptions[first] = true;\n      } else {\n        dotNotationOptions[fieldName] = false;\n      }\n    });\n    update = handleDotFields(update);\n    // Resolve authData first,\n    // So we don't end up with multiple key updates\n    for (const fieldName in update) {\n      const authDataMatch = fieldName.match(/^_auth_data_([a-zA-Z0-9_]+)$/);\n      if (authDataMatch) {\n        var provider = authDataMatch[1];\n        const value = update[fieldName];\n        delete update[fieldName];\n        update['authData'] = update['authData'] || {};\n        update['authData'][provider] = value;\n      }\n    }\n\n    for (const fieldName in update) {\n      const fieldValue = update[fieldName];\n      // Drop any undefined values.\n      if (typeof fieldValue === 'undefined') {\n        delete update[fieldName];\n      } else if (fieldValue === null) {\n        updatePatterns.push(`$${index}:name = NULL`);\n        values.push(fieldName);\n        index += 1;\n      } else if (fieldName == 'authData') {\n        // This recursively sets the json_object\n        // Only 1 level deep\n        const generate = (jsonb: string, key: string, value: any) => {\n          return `json_object_set_key(COALESCE(${jsonb}, '{}'::jsonb), ${key}, ${value})::jsonb`;\n        };\n        const lastKey = `$${index}:name`;\n        const fieldNameIndex = index;\n        index += 1;\n        values.push(fieldName);\n        const update = Object.keys(fieldValue).reduce((lastKey: string, key: string) => {\n          const str = generate(lastKey, `$${index}::text`, `$${index + 1}::jsonb`);\n          index += 2;\n          let value = fieldValue[key];\n          if (value) {\n            if (value.__op === 'Delete') {\n              value = null;\n            } else {\n              value = JSON.stringify(value);\n            }\n          }\n          values.push(key, value);\n          return str;\n        }, lastKey);\n        updatePatterns.push(`$${fieldNameIndex}:name = ${update}`);\n      } else if (fieldValue.__op === 'Increment') {\n        updatePatterns.push(`$${index}:name = COALESCE($${index}:name, 0) + $${index + 1}`);\n        values.push(fieldName, fieldValue.amount);\n        index += 2;\n      } else if (fieldValue.__op === 'Add') {\n        updatePatterns.push(\n          `$${index}:name = array_add(COALESCE($${index}:name, '[]'::jsonb), $${index + 1}::jsonb)`\n        );\n        values.push(fieldName, JSON.stringify(fieldValue.objects));\n        index += 2;\n      } else if (fieldValue.__op === 'Delete') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, null);\n        index += 2;\n      } else if (fieldValue.__op === 'Remove') {\n        updatePatterns.push(\n          `$${index}:name = array_remove(COALESCE($${index}:name, '[]'::jsonb), $${\n            index + 1\n          }::jsonb)`\n        );\n        values.push(fieldName, JSON.stringify(fieldValue.objects));\n        index += 2;\n      } else if (fieldValue.__op === 'AddUnique') {\n        updatePatterns.push(\n          `$${index}:name = array_add_unique(COALESCE($${index}:name, '[]'::jsonb), $${\n            index + 1\n          }::jsonb)`\n        );\n        values.push(fieldName, JSON.stringify(fieldValue.objects));\n        index += 2;\n      } else if (fieldName === 'updatedAt') {\n        //TODO: stop special casing this. It should check for __type === 'Date' and use .iso\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else if (typeof fieldValue === 'string') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else if (typeof fieldValue === 'boolean') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else if (fieldValue.__type === 'Pointer') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue.objectId);\n        index += 2;\n      } else if (fieldValue.__type === 'Date') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, toPostgresValue(fieldValue));\n        index += 2;\n      } else if (fieldValue instanceof Date) {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else if (fieldValue.__type === 'File') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, toPostgresValue(fieldValue));\n        index += 2;\n      } else if (fieldValue.__type === 'GeoPoint') {\n        updatePatterns.push(`$${index}:name = POINT($${index + 1}, $${index + 2})`);\n        values.push(fieldName, fieldValue.longitude, fieldValue.latitude);\n        index += 3;\n      } else if (fieldValue.__type === 'Polygon') {\n        const value = convertPolygonToSQL(fieldValue.coordinates);\n        updatePatterns.push(`$${index}:name = $${index + 1}::polygon`);\n        values.push(fieldName, value);\n        index += 2;\n      } else if (fieldValue.__type === 'Relation') {\n        // noop\n      } else if (typeof fieldValue === 'number') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else if (\n        typeof fieldValue === 'object' &&\n        schema.fields[fieldName] &&\n        schema.fields[fieldName].type === 'Object'\n      ) {\n        // Gather keys to increment\n        const keysToIncrement = Object.keys(originalUpdate)\n          .filter(k => {\n            // choose top level fields that have a delete operation set\n            // Note that Object.keys is iterating over the **original** update object\n            // and that some of the keys of the original update could be null or undefined:\n            // (See the above check `if (fieldValue === null || typeof fieldValue == \"undefined\")`)\n            const value = originalUpdate[k];\n            return (\n              value &&\n              value.__op === 'Increment' &&\n              k.split('.').length === 2 &&\n              k.split('.')[0] === fieldName\n            );\n          })\n          .map(k => k.split('.')[1]);\n\n        let incrementPatterns = '';\n        if (keysToIncrement.length > 0) {\n          incrementPatterns =\n            ' || ' +\n            keysToIncrement\n              .map(c => {\n                const amount = fieldValue[c].amount;\n                return `CONCAT('{\"${c}\":', COALESCE($${index}:name->>'${c}','0')::int + ${amount}, '}')::jsonb`;\n              })\n              .join(' || ');\n          // Strip the keys\n          keysToIncrement.forEach(key => {\n            delete fieldValue[key];\n          });\n        }\n\n        const keysToDelete: Array<string> = Object.keys(originalUpdate)\n          .filter(k => {\n            // choose top level fields that have a delete operation set.\n            const value = originalUpdate[k];\n            return (\n              value &&\n              value.__op === 'Delete' &&\n              k.split('.').length === 2 &&\n              k.split('.')[0] === fieldName\n            );\n          })\n          .map(k => k.split('.')[1]);\n\n        const deletePatterns = keysToDelete.reduce((p: string, c: string, i: number) => {\n          return p + ` - '$${index + 1 + i}:value'`;\n        }, '');\n        // Override Object\n        let updateObject = \"'{}'::jsonb\";\n\n        if (dotNotationOptions[fieldName]) {\n          // Merge Object\n          updateObject = `COALESCE($${index}:name, '{}'::jsonb)`;\n        }\n        updatePatterns.push(\n          `$${index}:name = (${updateObject} ${deletePatterns} ${incrementPatterns} || $${\n            index + 1 + keysToDelete.length\n          }::jsonb )`\n        );\n        values.push(fieldName, ...keysToDelete, JSON.stringify(fieldValue));\n        index += 2 + keysToDelete.length;\n      } else if (\n        Array.isArray(fieldValue) &&\n        schema.fields[fieldName] &&\n        schema.fields[fieldName].type === 'Array'\n      ) {\n        const expectedType = parseTypeToPostgresType(schema.fields[fieldName]);\n        if (expectedType === 'text[]') {\n          updatePatterns.push(`$${index}:name = $${index + 1}::text[]`);\n          values.push(fieldName, fieldValue);\n          index += 2;\n        } else {\n          updatePatterns.push(`$${index}:name = $${index + 1}::jsonb`);\n          values.push(fieldName, JSON.stringify(fieldValue));\n          index += 2;\n        }\n      } else {\n        debug('Not supported update', fieldName, fieldValue);\n        return Promise.reject(\n          new Parse.Error(\n            Parse.Error.OPERATION_FORBIDDEN,\n            `Postgres doesn't support update ${JSON.stringify(fieldValue)} yet`\n          )\n        );\n      }\n    }\n\n    const where = buildWhereClause({\n      schema,\n      index,\n      query,\n      caseInsensitive: false,\n    });\n    values.push(...where.values);\n\n    const whereClause = where.pattern.length > 0 ? `WHERE ${where.pattern}` : '';\n    const qs = `UPDATE $1:name SET ${updatePatterns.join()} ${whereClause} RETURNING *`;\n    debug('update: ', qs, values);\n    const promise = (transactionalSession ? transactionalSession.t : this._client).any(qs, values);\n    if (transactionalSession) {\n      transactionalSession.batch.push(promise);\n    }\n    return promise;\n  }\n\n  // Hopefully, we can get rid of this. It's only used for config and hooks.\n  upsertOneObject(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    update: any,\n    transactionalSession: ?any\n  ) {\n    debug('upsertOneObject', { className, query, update });\n    const createValue = Object.assign({}, query, update);\n    return this.createObject(className, schema, createValue, transactionalSession).catch(error => {\n      // ignore duplicate value errors as it's upsert\n      if (error.code !== Parse.Error.DUPLICATE_VALUE) {\n        throw error;\n      }\n      return this.findOneAndUpdate(className, schema, query, update, transactionalSession);\n    });\n  }\n\n  find(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    { skip, limit, sort, keys, caseInsensitive, explain }: QueryOptions\n  ) {\n    debug('find', className, query, {\n      skip,\n      limit,\n      sort,\n      keys,\n      caseInsensitive,\n      explain,\n    });\n    const hasLimit = limit !== undefined;\n    const hasSkip = skip !== undefined;\n    let values = [className];\n    const where = buildWhereClause({\n      schema,\n      query,\n      index: 2,\n      caseInsensitive,\n    });\n    values.push(...where.values);\n\n    const wherePattern = where.pattern.length > 0 ? `WHERE ${where.pattern}` : '';\n    const limitPattern = hasLimit ? `LIMIT $${values.length + 1}` : '';\n    if (hasLimit) {\n      values.push(limit);\n    }\n    const skipPattern = hasSkip ? `OFFSET $${values.length + 1}` : '';\n    if (hasSkip) {\n      values.push(skip);\n    }\n\n    let sortPattern = '';\n    if (sort) {\n      const sortCopy: any = sort;\n      const sorting = Object.keys(sort)\n        .map(key => {\n          const transformKey = transformDotFieldToComponents(key).join('->');\n          // Using $idx pattern gives:  non-integer constant in ORDER BY\n          if (sortCopy[key] === 1) {\n            return `${transformKey} ASC`;\n          }\n          return `${transformKey} DESC`;\n        })\n        .join();\n      sortPattern = sort !== undefined && Object.keys(sort).length > 0 ? `ORDER BY ${sorting}` : '';\n    }\n    if (where.sorts && Object.keys((where.sorts: any)).length > 0) {\n      sortPattern = `ORDER BY ${where.sorts.join()}`;\n    }\n\n    let columns = '*';\n    if (keys) {\n      // Exclude empty keys\n      // Replace ACL by it's keys\n      keys = keys.reduce((memo, key) => {\n        if (key === 'ACL') {\n          memo.push('_rperm');\n          memo.push('_wperm');\n        } else if (key.length > 0) {\n          memo.push(key);\n        }\n        return memo;\n      }, []);\n      columns = keys\n        .map((key, index) => {\n          if (key === '$score') {\n            return `ts_rank_cd(to_tsvector($${2}, $${3}:name), to_tsquery($${4}, $${5}), 32) as score`;\n          }\n          return `$${index + values.length + 1}:name`;\n        })\n        .join();\n      values = values.concat(keys);\n    }\n\n    const originalQuery = `SELECT ${columns} FROM $1:name ${wherePattern} ${sortPattern} ${limitPattern} ${skipPattern}`;\n    const qs = explain ? this.createExplainableQuery(originalQuery) : originalQuery;\n    debug(qs, values);\n    return this._client\n      .any(qs, values)\n      .catch(error => {\n        // Query on non existing table, don't crash\n        if (error.code !== PostgresRelationDoesNotExistError) {\n          throw error;\n        }\n        return [];\n      })\n      .then(results => {\n        if (explain) {\n          return results;\n        }\n        return results.map(object => this.postgresObjectToParseObject(className, object, schema));\n      });\n  }\n\n  // Converts from a postgres-format object to a REST-format object.\n  // Does not strip out anything based on a lack of authentication.\n  postgresObjectToParseObject(className: string, object: any, schema: any) {\n    Object.keys(schema.fields).forEach(fieldName => {\n      if (schema.fields[fieldName].type === 'Pointer' && object[fieldName]) {\n        object[fieldName] = {\n          objectId: object[fieldName],\n          __type: 'Pointer',\n          className: schema.fields[fieldName].targetClass,\n        };\n      }\n      if (schema.fields[fieldName].type === 'Relation') {\n        object[fieldName] = {\n          __type: 'Relation',\n          className: schema.fields[fieldName].targetClass,\n        };\n      }\n      if (object[fieldName] && schema.fields[fieldName].type === 'GeoPoint') {\n        object[fieldName] = {\n          __type: 'GeoPoint',\n          latitude: object[fieldName].y,\n          longitude: object[fieldName].x,\n        };\n      }\n      if (object[fieldName] && schema.fields[fieldName].type === 'Polygon') {\n        let coords = object[fieldName];\n        coords = coords.substr(2, coords.length - 4).split('),(');\n        coords = coords.map(point => {\n          return [parseFloat(point.split(',')[1]), parseFloat(point.split(',')[0])];\n        });\n        object[fieldName] = {\n          __type: 'Polygon',\n          coordinates: coords,\n        };\n      }\n      if (object[fieldName] && schema.fields[fieldName].type === 'File') {\n        object[fieldName] = {\n          __type: 'File',\n          name: object[fieldName],\n        };\n      }\n    });\n    //TODO: remove this reliance on the mongo format. DB adapter shouldn't know there is a difference between created at and any other date field.\n    if (object.createdAt) {\n      object.createdAt = object.createdAt.toISOString();\n    }\n    if (object.updatedAt) {\n      object.updatedAt = object.updatedAt.toISOString();\n    }\n    if (object.expiresAt) {\n      object.expiresAt = {\n        __type: 'Date',\n        iso: object.expiresAt.toISOString(),\n      };\n    }\n    if (object._email_verify_token_expires_at) {\n      object._email_verify_token_expires_at = {\n        __type: 'Date',\n        iso: object._email_verify_token_expires_at.toISOString(),\n      };\n    }\n    if (object._account_lockout_expires_at) {\n      object._account_lockout_expires_at = {\n        __type: 'Date',\n        iso: object._account_lockout_expires_at.toISOString(),\n      };\n    }\n    if (object._perishable_token_expires_at) {\n      object._perishable_token_expires_at = {\n        __type: 'Date',\n        iso: object._perishable_token_expires_at.toISOString(),\n      };\n    }\n    if (object._password_changed_at) {\n      object._password_changed_at = {\n        __type: 'Date',\n        iso: object._password_changed_at.toISOString(),\n      };\n    }\n\n    for (const fieldName in object) {\n      if (object[fieldName] === null) {\n        delete object[fieldName];\n      }\n      if (object[fieldName] instanceof Date) {\n        object[fieldName] = {\n          __type: 'Date',\n          iso: object[fieldName].toISOString(),\n        };\n      }\n    }\n\n    return object;\n  }\n\n  // Create a unique index. Unique indexes on nullable fields are not allowed. Since we don't\n  // currently know which fields are nullable and which aren't, we ignore that criteria.\n  // As such, we shouldn't expose this function to users of parse until we have an out-of-band\n  // Way of determining if a field is nullable. Undefined doesn't count against uniqueness,\n  // which is why we use sparse indexes.\n  async ensureUniqueness(className: string, schema: SchemaType, fieldNames: string[]) {\n    const constraintName = `${className}_unique_${fieldNames.sort().join('_')}`;\n    const constraintPatterns = fieldNames.map((fieldName, index) => `$${index + 3}:name`);\n    const qs = `CREATE UNIQUE INDEX IF NOT EXISTS $2:name ON $1:name(${constraintPatterns.join()})`;\n    return this._client.none(qs, [className, constraintName, ...fieldNames]).catch(error => {\n      if (error.code === PostgresDuplicateRelationError && error.message.includes(constraintName)) {\n        // Index already exists. Ignore error.\n      } else if (\n        error.code === PostgresUniqueIndexViolationError &&\n        error.message.includes(constraintName)\n      ) {\n        // Cast the error into the proper parse error\n        throw new Parse.Error(\n          Parse.Error.DUPLICATE_VALUE,\n          'A duplicate value for a field with unique values was provided'\n        );\n      } else {\n        throw error;\n      }\n    });\n  }\n\n  // Executes a count.\n  async count(\n    className: string,\n    schema: SchemaType,\n    query: QueryType,\n    readPreference?: string,\n    estimate?: boolean = true\n  ) {\n    debug('count', className, query, readPreference, estimate);\n    const values = [className];\n    const where = buildWhereClause({\n      schema,\n      query,\n      index: 2,\n      caseInsensitive: false,\n    });\n    values.push(...where.values);\n\n    const wherePattern = where.pattern.length > 0 ? `WHERE ${where.pattern}` : '';\n    let qs = '';\n\n    if (where.pattern.length > 0 || !estimate) {\n      qs = `SELECT count(*) FROM $1:name ${wherePattern}`;\n    } else {\n      qs = 'SELECT reltuples AS approximate_row_count FROM pg_class WHERE relname = $1';\n    }\n\n    return this._client\n      .one(qs, values, a => {\n        if (a.approximate_row_count != null) {\n          return +a.approximate_row_count;\n        } else {\n          return +a.count;\n        }\n      })\n      .catch(error => {\n        if (error.code !== PostgresRelationDoesNotExistError) {\n          throw error;\n        }\n        return 0;\n      });\n  }\n\n  async distinct(className: string, schema: SchemaType, query: QueryType, fieldName: string) {\n    debug('distinct', className, query);\n    let field = fieldName;\n    let column = fieldName;\n    const isNested = fieldName.indexOf('.') >= 0;\n    if (isNested) {\n      field = transformDotFieldToComponents(fieldName).join('->');\n      column = fieldName.split('.')[0];\n    }\n    const isArrayField =\n      schema.fields && schema.fields[fieldName] && schema.fields[fieldName].type === 'Array';\n    const isPointerField =\n      schema.fields && schema.fields[fieldName] && schema.fields[fieldName].type === 'Pointer';\n    const values = [field, column, className];\n    const where = buildWhereClause({\n      schema,\n      query,\n      index: 4,\n      caseInsensitive: false,\n    });\n    values.push(...where.values);\n\n    const wherePattern = where.pattern.length > 0 ? `WHERE ${where.pattern}` : '';\n    const transformer = isArrayField ? 'jsonb_array_elements' : 'ON';\n    let qs = `SELECT DISTINCT ${transformer}($1:name) $2:name FROM $3:name ${wherePattern}`;\n    if (isNested) {\n      qs = `SELECT DISTINCT ${transformer}($1:raw) $2:raw FROM $3:name ${wherePattern}`;\n    }\n    debug(qs, values);\n    return this._client\n      .any(qs, values)\n      .catch(error => {\n        if (error.code === PostgresMissingColumnError) {\n          return [];\n        }\n        throw error;\n      })\n      .then(results => {\n        if (!isNested) {\n          results = results.filter(object => object[field] !== null);\n          return results.map(object => {\n            if (!isPointerField) {\n              return object[field];\n            }\n            return {\n              __type: 'Pointer',\n              className: schema.fields[fieldName].targetClass,\n              objectId: object[field],\n            };\n          });\n        }\n        const child = fieldName.split('.')[1];\n        return results.map(object => object[column][child]);\n      })\n      .then(results =>\n        results.map(object => this.postgresObjectToParseObject(className, object, schema))\n      );\n  }\n\n  async aggregate(\n    className: string,\n    schema: any,\n    pipeline: any,\n    readPreference: ?string,\n    hint: ?mixed,\n    explain?: boolean\n  ) {\n    debug('aggregate', className, pipeline, readPreference, hint, explain);\n    const values = [className];\n    let index: number = 2;\n    let columns: string[] = [];\n    let countField = null;\n    let groupValues = null;\n    let wherePattern = '';\n    let limitPattern = '';\n    let skipPattern = '';\n    let sortPattern = '';\n    let groupPattern = '';\n    for (let i = 0; i < pipeline.length; i += 1) {\n      const stage = pipeline[i];\n      if (stage.$group) {\n        for (const field in stage.$group) {\n          const value = stage.$group[field];\n          if (value === null || value === undefined) {\n            continue;\n          }\n          if (field === '_id' && typeof value === 'string' && value !== '') {\n            columns.push(`$${index}:name AS \"objectId\"`);\n            groupPattern = `GROUP BY $${index}:name`;\n            values.push(transformAggregateField(value));\n            index += 1;\n            continue;\n          }\n          if (field === '_id' && typeof value === 'object' && Object.keys(value).length !== 0) {\n            groupValues = value;\n            const groupByFields = [];\n            for (const alias in value) {\n              if (typeof value[alias] === 'string' && value[alias]) {\n                const source = transformAggregateField(value[alias]);\n                if (!groupByFields.includes(`\"${source}\"`)) {\n                  groupByFields.push(`\"${source}\"`);\n                }\n                values.push(source, alias);\n                columns.push(`$${index}:name AS $${index + 1}:name`);\n                index += 2;\n              } else {\n                const operation = Object.keys(value[alias])[0];\n                const source = transformAggregateField(value[alias][operation]);\n                if (mongoAggregateToPostgres[operation]) {\n                  if (!groupByFields.includes(`\"${source}\"`)) {\n                    groupByFields.push(`\"${source}\"`);\n                  }\n                  columns.push(\n                    `EXTRACT(${\n                      mongoAggregateToPostgres[operation]\n                    } FROM $${index}:name AT TIME ZONE 'UTC') AS $${index + 1}:name`\n                  );\n                  values.push(source, alias);\n                  index += 2;\n                }\n              }\n            }\n            groupPattern = `GROUP BY $${index}:raw`;\n            values.push(groupByFields.join());\n            index += 1;\n            continue;\n          }\n          if (typeof value === 'object') {\n            if (value.$sum) {\n              if (typeof value.$sum === 'string') {\n                columns.push(`SUM($${index}:name) AS $${index + 1}:name`);\n                values.push(transformAggregateField(value.$sum), field);\n                index += 2;\n              } else {\n                countField = field;\n                columns.push(`COUNT(*) AS $${index}:name`);\n                values.push(field);\n                index += 1;\n              }\n            }\n            if (value.$max) {\n              columns.push(`MAX($${index}:name) AS $${index + 1}:name`);\n              values.push(transformAggregateField(value.$max), field);\n              index += 2;\n            }\n            if (value.$min) {\n              columns.push(`MIN($${index}:name) AS $${index + 1}:name`);\n              values.push(transformAggregateField(value.$min), field);\n              index += 2;\n            }\n            if (value.$avg) {\n              columns.push(`AVG($${index}:name) AS $${index + 1}:name`);\n              values.push(transformAggregateField(value.$avg), field);\n              index += 2;\n            }\n          }\n        }\n      } else {\n        columns.push('*');\n      }\n      if (stage.$project) {\n        if (columns.includes('*')) {\n          columns = [];\n        }\n        for (const field in stage.$project) {\n          const value = stage.$project[field];\n          if (value === 1 || value === true) {\n            columns.push(`$${index}:name`);\n            values.push(field);\n            index += 1;\n          }\n        }\n      }\n      if (stage.$match) {\n        const patterns = [];\n        const orOrAnd = Object.prototype.hasOwnProperty.call(stage.$match, '$or')\n          ? ' OR '\n          : ' AND ';\n\n        if (stage.$match.$or) {\n          const collapse = {};\n          stage.$match.$or.forEach(element => {\n            for (const key in element) {\n              collapse[key] = element[key];\n            }\n          });\n          stage.$match = collapse;\n        }\n        for (const field in stage.$match) {\n          const value = stage.$match[field];\n          const matchPatterns = [];\n          Object.keys(ParseToPosgresComparator).forEach(cmp => {\n            if (value[cmp]) {\n              const pgComparator = ParseToPosgresComparator[cmp];\n              matchPatterns.push(`$${index}:name ${pgComparator} $${index + 1}`);\n              values.push(field, toPostgresValue(value[cmp]));\n              index += 2;\n            }\n          });\n          if (matchPatterns.length > 0) {\n            patterns.push(`(${matchPatterns.join(' AND ')})`);\n          }\n          if (schema.fields[field] && schema.fields[field].type && matchPatterns.length === 0) {\n            patterns.push(`$${index}:name = $${index + 1}`);\n            values.push(field, value);\n            index += 2;\n          }\n        }\n        wherePattern = patterns.length > 0 ? `WHERE ${patterns.join(` ${orOrAnd} `)}` : '';\n      }\n      if (stage.$limit) {\n        limitPattern = `LIMIT $${index}`;\n        values.push(stage.$limit);\n        index += 1;\n      }\n      if (stage.$skip) {\n        skipPattern = `OFFSET $${index}`;\n        values.push(stage.$skip);\n        index += 1;\n      }\n      if (stage.$sort) {\n        const sort = stage.$sort;\n        const keys = Object.keys(sort);\n        const sorting = keys\n          .map(key => {\n            const transformer = sort[key] === 1 ? 'ASC' : 'DESC';\n            const order = `$${index}:name ${transformer}`;\n            index += 1;\n            return order;\n          })\n          .join();\n        values.push(...keys);\n        sortPattern = sort !== undefined && sorting.length > 0 ? `ORDER BY ${sorting}` : '';\n      }\n    }\n\n    if (groupPattern) {\n      columns.forEach((e, i, a) => {\n        if (e && e.trim() === '*') {\n          a[i] = '';\n        }\n      });\n    }\n\n    const originalQuery = `SELECT ${columns\n      .filter(Boolean)\n      .join()} FROM $1:name ${wherePattern} ${skipPattern} ${groupPattern} ${sortPattern} ${limitPattern}`;\n    const qs = explain ? this.createExplainableQuery(originalQuery) : originalQuery;\n    debug(qs, values);\n    return this._client.any(qs, values).then(a => {\n      if (explain) {\n        return a;\n      }\n      const results = a.map(object => this.postgresObjectToParseObject(className, object, schema));\n      results.forEach(result => {\n        if (!Object.prototype.hasOwnProperty.call(result, 'objectId')) {\n          result.objectId = null;\n        }\n        if (groupValues) {\n          result.objectId = {};\n          for (const key in groupValues) {\n            result.objectId[key] = result[key];\n            delete result[key];\n          }\n        }\n        if (countField) {\n          result[countField] = parseInt(result[countField], 10);\n        }\n      });\n      return results;\n    });\n  }\n\n  async performInitialization({ VolatileClassesSchemas }: any) {\n    // TODO: This method needs to be rewritten to make proper use of connections (@vitaly-t)\n    debug('performInitialization');\n    const promises = VolatileClassesSchemas.map(schema => {\n      return this.createTable(schema.className, schema)\n        .catch(err => {\n          if (\n            err.code === PostgresDuplicateRelationError ||\n            err.code === Parse.Error.INVALID_CLASS_NAME\n          ) {\n            return Promise.resolve();\n          }\n          throw err;\n        })\n        .then(() => this.schemaUpgrade(schema.className, schema));\n    });\n    return Promise.all(promises)\n      .then(() => {\n        return this._client.tx('perform-initialization', async t => {\n          await t.none(sql.misc.jsonObjectSetKeys);\n          await t.none(sql.array.add);\n          await t.none(sql.array.addUnique);\n          await t.none(sql.array.remove);\n          await t.none(sql.array.containsAll);\n          await t.none(sql.array.containsAllRegex);\n          await t.none(sql.array.contains);\n          return t.ctx;\n        });\n      })\n      .then(ctx => {\n        debug(`initializationDone in ${ctx.duration}`);\n      })\n      .catch(error => {\n        /* eslint-disable no-console */\n        console.error(error);\n      });\n  }\n\n  async createIndexes(className: string, indexes: any, conn: ?any): Promise<void> {\n    return (conn || this._client).tx(t =>\n      t.batch(\n        indexes.map(i => {\n          return t.none('CREATE INDEX IF NOT EXISTS $1:name ON $2:name ($3:name)', [\n            i.name,\n            className,\n            i.key,\n          ]);\n        })\n      )\n    );\n  }\n\n  async createIndexesIfNeeded(\n    className: string,\n    fieldName: string,\n    type: any,\n    conn: ?any\n  ): Promise<void> {\n    await (conn || this._client).none('CREATE INDEX IF NOT EXISTS $1:name ON $2:name ($3:name)', [\n      fieldName,\n      className,\n      type,\n    ]);\n  }\n\n  async dropIndexes(className: string, indexes: any, conn: any): Promise<void> {\n    const queries = indexes.map(i => ({\n      query: 'DROP INDEX $1:name',\n      values: i,\n    }));\n    await (conn || this._client).tx(t => t.none(this._pgp.helpers.concat(queries)));\n  }\n\n  async getIndexes(className: string) {\n    const qs = 'SELECT * FROM pg_indexes WHERE tablename = ${className}';\n    return this._client.any(qs, { className });\n  }\n\n  async updateSchemaWithIndexes(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  // Used for testing purposes\n  async updateEstimatedCount(className: string) {\n    return this._client.none('ANALYZE $1:name', [className]);\n  }\n\n  async createTransactionalSession(): Promise<any> {\n    return new Promise(resolve => {\n      const transactionalSession = {};\n      transactionalSession.result = this._client.tx(t => {\n        transactionalSession.t = t;\n        transactionalSession.promise = new Promise(resolve => {\n          transactionalSession.resolve = resolve;\n        });\n        transactionalSession.batch = [];\n        resolve(transactionalSession);\n        return transactionalSession.promise;\n      });\n    });\n  }\n\n  commitTransactionalSession(transactionalSession: any): Promise<void> {\n    transactionalSession.resolve(transactionalSession.t.batch(transactionalSession.batch));\n    return transactionalSession.result;\n  }\n\n  abortTransactionalSession(transactionalSession: any): Promise<void> {\n    const result = transactionalSession.result.catch();\n    transactionalSession.batch.push(Promise.reject());\n    transactionalSession.resolve(transactionalSession.t.batch(transactionalSession.batch));\n    return result;\n  }\n\n  async ensureIndex(\n    className: string,\n    schema: SchemaType,\n    fieldNames: string[],\n    indexName: ?string,\n    caseInsensitive: boolean = false,\n    options?: Object = {}\n  ): Promise<any> {\n    const conn = options.conn !== undefined ? options.conn : this._client;\n    const defaultIndexName = `parse_default_${fieldNames.sort().join('_')}`;\n    const indexNameOptions: Object =\n      indexName != null ? { name: indexName } : { name: defaultIndexName };\n    const constraintPatterns = caseInsensitive\n      ? fieldNames.map((fieldName, index) => `lower($${index + 3}:name) varchar_pattern_ops`)\n      : fieldNames.map((fieldName, index) => `$${index + 3}:name`);\n    const qs = `CREATE INDEX IF NOT EXISTS $1:name ON $2:name (${constraintPatterns.join()})`;\n    await conn.none(qs, [indexNameOptions.name, className, ...fieldNames]).catch(error => {\n      if (\n        error.code === PostgresDuplicateRelationError &&\n        error.message.includes(indexNameOptions.name)\n      ) {\n        // Index already exists. Ignore error.\n      } else if (\n        error.code === PostgresUniqueIndexViolationError &&\n        error.message.includes(indexNameOptions.name)\n      ) {\n        // Cast the error into the proper parse error\n        throw new Parse.Error(\n          Parse.Error.DUPLICATE_VALUE,\n          'A duplicate value for a field with unique values was provided'\n        );\n      } else {\n        throw error;\n      }\n    });\n  }\n}\n\nfunction convertPolygonToSQL(polygon) {\n  if (polygon.length < 3) {\n    throw new Parse.Error(Parse.Error.INVALID_JSON, `Polygon must have at least 3 values`);\n  }\n  if (\n    polygon[0][0] !== polygon[polygon.length - 1][0] ||\n    polygon[0][1] !== polygon[polygon.length - 1][1]\n  ) {\n    polygon.push(polygon[0]);\n  }\n  const unique = polygon.filter((item, index, ar) => {\n    let foundIndex = -1;\n    for (let i = 0; i < ar.length; i += 1) {\n      const pt = ar[i];\n      if (pt[0] === item[0] && pt[1] === item[1]) {\n        foundIndex = i;\n        break;\n      }\n    }\n    return foundIndex === index;\n  });\n  if (unique.length < 3) {\n    throw new Parse.Error(\n      Parse.Error.INTERNAL_SERVER_ERROR,\n      'GeoJSON: Loop must have at least 3 different vertices'\n    );\n  }\n  const points = polygon\n    .map(point => {\n      Parse.GeoPoint._validate(parseFloat(point[1]), parseFloat(point[0]));\n      return `(${point[1]}, ${point[0]})`;\n    })\n    .join(', ');\n  return `(${points})`;\n}\n\nfunction removeWhiteSpace(regex) {\n  if (!regex.endsWith('\\n')) {\n    regex += '\\n';\n  }\n\n  // remove non escaped comments\n  return (\n    regex\n      .replace(/([^\\\\])#.*\\n/gim, '$1')\n      // remove lines starting with a comment\n      .replace(/^#.*\\n/gim, '')\n      // remove non escaped whitespace\n      .replace(/([^\\\\])\\s+/gim, '$1')\n      // remove whitespace at the beginning of a line\n      .replace(/^\\s+/, '')\n      .trim()\n  );\n}\n\nfunction processRegexPattern(s) {\n  if (s && s.startsWith('^')) {\n    // regex for startsWith\n    return '^' + literalizeRegexPart(s.slice(1));\n  } else if (s && s.endsWith('$')) {\n    // regex for endsWith\n    return literalizeRegexPart(s.slice(0, s.length - 1)) + '$';\n  }\n\n  // regex for contains\n  return literalizeRegexPart(s);\n}\n\nfunction isStartsWithRegex(value) {\n  if (!value || typeof value !== 'string' || !value.startsWith('^')) {\n    return false;\n  }\n\n  const matches = value.match(/\\^\\\\Q.*\\\\E/);\n  return !!matches;\n}\n\nfunction isAllValuesRegexOrNone(values) {\n  if (!values || !Array.isArray(values) || values.length === 0) {\n    return true;\n  }\n\n  const firstValuesIsRegex = isStartsWithRegex(values[0].$regex);\n  if (values.length === 1) {\n    return firstValuesIsRegex;\n  }\n\n  for (let i = 1, length = values.length; i < length; ++i) {\n    if (firstValuesIsRegex !== isStartsWithRegex(values[i].$regex)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isAnyValueRegexStartsWith(values) {\n  return values.some(function (value) {\n    return isStartsWithRegex(value.$regex);\n  });\n}\n\nfunction createLiteralRegex(remaining) {\n  return remaining\n    .split('')\n    .map(c => {\n      const regex = RegExp('[0-9 ]|\\\\p{L}', 'u'); // Support all unicode letter chars\n      if (c.match(regex) !== null) {\n        // don't escape alphanumeric characters\n        return c;\n      }\n      // escape everything else (single quotes with single quotes, everything else with a backslash)\n      return c === `'` ? `''` : `\\\\${c}`;\n    })\n    .join('');\n}\n\nfunction literalizeRegexPart(s: string) {\n  const matcher1 = /\\\\Q((?!\\\\E).*)\\\\E$/;\n  const result1: any = s.match(matcher1);\n  if (result1 && result1.length > 1 && result1.index > -1) {\n    // process regex that has a beginning and an end specified for the literal text\n    const prefix = s.substr(0, result1.index);\n    const remaining = result1[1];\n\n    return literalizeRegexPart(prefix) + createLiteralRegex(remaining);\n  }\n\n  // process regex that has a beginning specified for the literal text\n  const matcher2 = /\\\\Q((?!\\\\E).*)$/;\n  const result2: any = s.match(matcher2);\n  if (result2 && result2.length > 1 && result2.index > -1) {\n    const prefix = s.substr(0, result2.index);\n    const remaining = result2[1];\n\n    return literalizeRegexPart(prefix) + createLiteralRegex(remaining);\n  }\n\n  // remove all instances of \\Q and \\E from the remaining text & escape single quotes\n  return s\n    .replace(/([^\\\\])(\\\\E)/, '$1')\n    .replace(/([^\\\\])(\\\\Q)/, '$1')\n    .replace(/^\\\\E/, '')\n    .replace(/^\\\\Q/, '')\n    .replace(/([^'])'/, `$1''`)\n    .replace(/^'([^'])/, `''$1`);\n}\n\nvar GeoPointCoder = {\n  isValidJSON(value) {\n    return typeof value === 'object' && value !== null && value.__type === 'GeoPoint';\n  },\n};\n\nexport default PostgresStorageAdapter;\n"],"file":"PostgresStorageAdapter.js"}