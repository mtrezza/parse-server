{"version":3,"sources":["../../../src/Adapters/Auth/oauth2.js"],"names":["Parse","require","url","querystring","httpsRequest","INVALID_ACCESS","INVALID_ACCESS_APPID","MISSING_APPIDS","MISSING_URL","validateAuthData","authData","options","requestTokenInfo","access_token","then","response","active","useridField","id","Error","OBJECT_NOT_FOUND","validateAppId","appIds","appidField","Promise","resolve","length","responseValue","Array","isArray","includes","some","appId","tokenIntrospectionEndpointUrl","parsedUrl","parse","postData","stringify","token","headers","Buffer","byteLength","authorizationHeader","postOptions","hostname","path","pathname","method","request","module","exports"],"mappings":"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","sourcesContent":["/*\n * This auth adapter is based on the OAuth 2.0 Token Introspection specification.\n * See RFC 7662 for details (https://tools.ietf.org/html/rfc7662).\n * It's purpose is to validate OAuth2 access tokens using the OAuth2 provider's\n * token introspection endpoint (if implemented by the provider).\n *\n * The adapter accepts the following config parameters:\n *\n * 1. \"tokenIntrospectionEndpointUrl\" (string, required)\n *      The URL of the token introspection endpoint of the OAuth2 provider that\n *      issued the access token to the client that is to be validated.\n *\n * 2. \"useridField\" (string, optional)\n *      The name of the field in the token introspection response that contains\n *      the userid. If specified, it will be used to verify the value of the \"id\"\n *      field in the \"authData\" JSON that is coming from the client.\n *      This can be the \"aud\" (i.e. audience), the \"sub\" (i.e. subject) or the\n *      \"username\" field in the introspection response, but since only the\n *      \"active\" field is required and all other reponse fields are optional\n *      in the RFC, it has to be optional in this adapter as well.\n *      Default: - (undefined)\n *\n * 3. \"appidField\" (string, optional)\n *      The name of the field in the token introspection response that contains\n *      the appId of the client. If specified, it will be used to verify it's\n *      value against the set of appIds in the adapter config. The concept of\n *      appIds comes from the two major social login providers\n *      (Google and Facebook). They have not yet implemented the token\n *      introspection endpoint, but the concept can be valid for any OAuth2\n *      provider.\n *      Default: - (undefined)\n *\n * 4. \"appIds\" (array of strings, required if appidField is defined)\n *      A set of appIds that are used to restrict accepted access tokens based\n *      on a specific field's value in the token introspection response.\n *      Default: - (undefined)\n *\n * 5. \"authorizationHeader\" (string, optional)\n *      The value of the \"Authorization\" HTTP header in requests sent to the\n *      introspection endpoint. It must contain the raw value.\n *      Thus if HTTP Basic authorization is to be used, it must contain the\n *      \"Basic\" string, followed by whitespace, then by the base64 encoded\n *      version of the concatenated <username> + \":\" + <password> string.\n *      Eg. \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\"\n *\n * The adapter expects requests with the following authData JSON:\n *\n * {\n *   \"someadapter\": {\n *     \"id\": \"user's OAuth2 provider-specific id as a string\",\n *     \"access_token\": \"an authorized OAuth2 access token for the user\",\n *   }\n * }\n */\n\nconst Parse = require('parse/node').Parse;\nconst url = require('url');\nconst querystring = require('querystring');\nconst httpsRequest = require('./httpsRequest');\n\nconst INVALID_ACCESS = 'OAuth2 access token is invalid for this user.';\nconst INVALID_ACCESS_APPID =\n  \"OAuth2: the access_token's appID is empty or is not in the list of permitted appIDs in the auth configuration.\";\nconst MISSING_APPIDS =\n  'OAuth2 configuration is missing the client app IDs (\"appIds\" config parameter).';\nconst MISSING_URL = 'OAuth2 token introspection endpoint URL is missing from configuration!';\n\n// Returns a promise that fulfills if this user id is valid.\nfunction validateAuthData(authData, options) {\n  return requestTokenInfo(options, authData.access_token).then(response => {\n    if (\n      !response ||\n      !response.active ||\n      (options.useridField && authData.id !== response[options.useridField])\n    ) {\n      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, INVALID_ACCESS);\n    }\n  });\n}\n\nfunction validateAppId(appIds, authData, options) {\n  if (!options || !options.appidField) {\n    return Promise.resolve();\n  }\n  if (!appIds || appIds.length === 0) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, MISSING_APPIDS);\n  }\n  return requestTokenInfo(options, authData.access_token).then(response => {\n    if (!response || !response.active) {\n      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, INVALID_ACCESS);\n    }\n    const appidField = options.appidField;\n    if (!response[appidField]) {\n      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, INVALID_ACCESS_APPID);\n    }\n    const responseValue = response[appidField];\n    if (!Array.isArray(responseValue) && appIds.includes(responseValue)) {\n      return;\n    } else if (\n      Array.isArray(responseValue) &&\n      responseValue.some(appId => appIds.includes(appId))\n    ) {\n      return;\n    } else {\n      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, INVALID_ACCESS_APPID);\n    }\n  });\n}\n\n// A promise wrapper for requests to the OAuth2 token introspection endpoint.\nfunction requestTokenInfo(options, access_token) {\n  if (!options || !options.tokenIntrospectionEndpointUrl) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, MISSING_URL);\n  }\n  const parsedUrl = url.parse(options.tokenIntrospectionEndpointUrl);\n  const postData = querystring.stringify({\n    token: access_token,\n  });\n  const headers = {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(postData),\n  };\n  if (options.authorizationHeader) {\n    headers['Authorization'] = options.authorizationHeader;\n  }\n  const postOptions = {\n    hostname: parsedUrl.hostname,\n    path: parsedUrl.pathname,\n    method: 'POST',\n    headers: headers,\n  };\n  return httpsRequest.request(postOptions, postData);\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData,\n};\n"],"file":"oauth2.js"}