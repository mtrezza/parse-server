{"version":3,"sources":["../../../../src/Adapters/Cache/RedisCacheAdapter/KeyPromiseQueue.js"],"names":["KeyPromiseQueue","constructor","queue","enqueue","key","operation","tuple","beforeOp","toAwait","nextOperation","then","wrappedOperation","result","afterOp","Promise","resolve"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACO,MAAMA,eAAN,CAAsB;AAC3BC,EAAAA,WAAW,GAAG;AACZ,SAAKC,KAAL,GAAa,EAAb;AACD;;AAEDC,EAAAA,OAAO,CAACC,GAAD,EAAMC,SAAN,EAAiB;AACtB,UAAMC,KAAK,GAAG,KAAKC,QAAL,CAAcH,GAAd,CAAd;AACA,UAAMI,OAAO,GAAGF,KAAK,CAAC,CAAD,CAArB;AACA,UAAMG,aAAa,GAAGD,OAAO,CAACE,IAAR,CAAaL,SAAb,CAAtB;AACA,UAAMM,gBAAgB,GAAGF,aAAa,CAACC,IAAd,CAAmBE,MAAM,IAAI;AACpD,WAAKC,OAAL,CAAaT,GAAb;AACA,aAAOQ,MAAP;AACD,KAHwB,CAAzB;AAIAN,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAWK,gBAAX;AACA,WAAOA,gBAAP;AACD;;AAEDJ,EAAAA,QAAQ,CAACH,GAAD,EAAM;AACZ,QAAIE,KAAK,GAAG,KAAKJ,KAAL,CAAWE,GAAX,CAAZ;;AACA,QAAI,CAACE,KAAL,EAAY;AACVA,MAAAA,KAAK,GAAG,CAAC,CAAD,EAAIQ,OAAO,CAACC,OAAR,EAAJ,CAAR;AACA,WAAKb,KAAL,CAAWE,GAAX,IAAkBE,KAAlB;AACD;;AACDA,IAAAA,KAAK,CAAC,CAAD,CAAL;AACA,WAAOA,KAAP;AACD;;AAEDO,EAAAA,OAAO,CAACT,GAAD,EAAM;AACX,UAAME,KAAK,GAAG,KAAKJ,KAAL,CAAWE,GAAX,CAAd;;AACA,QAAI,CAACE,KAAL,EAAY;AACV;AACD;;AACDA,IAAAA,KAAK,CAAC,CAAD,CAAL;;AACA,QAAIA,KAAK,CAAC,CAAD,CAAL,IAAY,CAAhB,EAAmB;AACjB,aAAO,KAAKJ,KAAL,CAAWE,GAAX,CAAP;AACA;AACD;AACF;;AArC0B","sourcesContent":["// KeyPromiseQueue is a simple promise queue\n// used to queue operations per key basis.\n// Once the tail promise in the key-queue fulfills,\n// the chain on that key will be cleared.\nexport class KeyPromiseQueue {\n  constructor() {\n    this.queue = {};\n  }\n\n  enqueue(key, operation) {\n    const tuple = this.beforeOp(key);\n    const toAwait = tuple[1];\n    const nextOperation = toAwait.then(operation);\n    const wrappedOperation = nextOperation.then(result => {\n      this.afterOp(key);\n      return result;\n    });\n    tuple[1] = wrappedOperation;\n    return wrappedOperation;\n  }\n\n  beforeOp(key) {\n    let tuple = this.queue[key];\n    if (!tuple) {\n      tuple = [0, Promise.resolve()];\n      this.queue[key] = tuple;\n    }\n    tuple[0]++;\n    return tuple;\n  }\n\n  afterOp(key) {\n    const tuple = this.queue[key];\n    if (!tuple) {\n      return;\n    }\n    tuple[0]--;\n    if (tuple[0] <= 0) {\n      delete this.queue[key];\n      return;\n    }\n  }\n}\n"],"file":"KeyPromiseQueue.js"}