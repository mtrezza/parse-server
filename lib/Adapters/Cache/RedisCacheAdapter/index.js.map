{"version":3,"sources":["../../../../src/Adapters/Cache/RedisCacheAdapter/index.js"],"names":["DEFAULT_REDIS_TTL","FLUSH_DB_KEY","debug","logger","apply","arguments","isValidTTL","ttl","RedisCacheAdapter","constructor","redisCtx","client","redis","createClient","queue","KeyPromiseQueue","handleShutdown","Promise","resolve","quit","err","error","get","key","enqueue","res","JSON","parse","put","value","stringify","Infinity","set","psetex","del","clear","flushdb","getAllKeys","reject","keys"],"mappings":"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","sourcesContent":["import redis from 'redis';\nimport logger from '../../../logger';\nimport { KeyPromiseQueue } from './KeyPromiseQueue';\n\nconst DEFAULT_REDIS_TTL = 30 * 1000; // 30 seconds in milliseconds\nconst FLUSH_DB_KEY = '__flush_db__';\n\nfunction debug() {\n  logger.debug.apply(logger, ['RedisCacheAdapter', ...arguments]);\n}\n\nconst isValidTTL = ttl => typeof ttl === 'number' && ttl > 0;\n\nexport class RedisCacheAdapter {\n  constructor(redisCtx, ttl = DEFAULT_REDIS_TTL) {\n    this.ttl = isValidTTL(ttl) ? ttl : DEFAULT_REDIS_TTL;\n    this.client = redis.createClient(redisCtx);\n    this.queue = new KeyPromiseQueue();\n  }\n\n  handleShutdown() {\n    if (!this.client) {\n      return Promise.resolve();\n    }\n    return new Promise(resolve => {\n      this.client.quit(err => {\n        if (err) {\n          logger.error('RedisCacheAdapter error on shutdown', { error: err });\n        }\n        resolve();\n      });\n    });\n  }\n\n  get(key) {\n    debug('get', key);\n    return this.queue.enqueue(\n      key,\n      () =>\n        new Promise(resolve => {\n          this.client.get(key, function (err, res) {\n            debug('-> get', key, res);\n            if (!res) {\n              return resolve(null);\n            }\n            resolve(JSON.parse(res));\n          });\n        })\n    );\n  }\n\n  put(key, value, ttl = this.ttl) {\n    value = JSON.stringify(value);\n    debug('put', key, value, ttl);\n\n    if (ttl === 0) {\n      // ttl of zero is a logical no-op, but redis cannot set expire time of zero\n      return this.queue.enqueue(key, () => Promise.resolve());\n    }\n\n    if (ttl === Infinity) {\n      return this.queue.enqueue(\n        key,\n        () =>\n          new Promise(resolve => {\n            this.client.set(key, value, function () {\n              resolve();\n            });\n          })\n      );\n    }\n\n    if (!isValidTTL(ttl)) {\n      ttl = this.ttl;\n    }\n\n    return this.queue.enqueue(\n      key,\n      () =>\n        new Promise(resolve => {\n          this.client.psetex(key, ttl, value, function () {\n            resolve();\n          });\n        })\n    );\n  }\n\n  del(key) {\n    debug('del', key);\n    return this.queue.enqueue(\n      key,\n      () =>\n        new Promise(resolve => {\n          this.client.del(key, function () {\n            resolve();\n          });\n        })\n    );\n  }\n\n  clear() {\n    debug('clear');\n    return this.queue.enqueue(\n      FLUSH_DB_KEY,\n      () =>\n        new Promise(resolve => {\n          this.client.flushdb(function () {\n            resolve();\n          });\n        })\n    );\n  }\n\n  // Used for testing\n  async getAllKeys() {\n    return new Promise((resolve, reject) => {\n      this.client.keys('*', (err, keys) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(keys);\n        }\n      });\n    });\n  }\n}\n\nexport default RedisCacheAdapter;\n"],"file":"index.js"}