{"version":3,"sources":["../../src/Routers/PushRouter.js"],"names":["PushRouter","PromiseRouter","mountRoutes","route","middleware","promiseEnforceMasterKeyAccess","handlePOST","req","auth","isReadOnly","Parse","Error","OPERATION_FORBIDDEN","pushController","config","PUSH_MISCONFIGURED","where","getQueryCondition","resolve","promise","Promise","_resolve","pushStatusId","sendPush","body","objectId","headers","response","result","catch","err","loggerController","error","hasWhere","hasChannels","channels","$in"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;;;;;AAEO,MAAMA,UAAN,SAAyBC,sBAAzB,CAAuC;AAC5CC,EAAAA,WAAW,GAAG;AACZ,SAAKC,KAAL,CAAW,MAAX,EAAmB,OAAnB,EAA4BC,UAAU,CAACC,6BAAvC,EAAsEL,UAAU,CAACM,UAAjF;AACD;;AAED,SAAOA,UAAP,CAAkBC,GAAlB,EAAuB;AACrB,QAAIA,GAAG,CAACC,IAAJ,CAASC,UAAb,EAAyB;AACvB,YAAM,IAAIC,YAAMC,KAAV,CACJD,YAAMC,KAAN,CAAYC,mBADR,EAEJ,+DAFI,CAAN;AAID;;AACD,UAAMC,cAAc,GAAGN,GAAG,CAACO,MAAJ,CAAWD,cAAlC;;AACA,QAAI,CAACA,cAAL,EAAqB;AACnB,YAAM,IAAIH,YAAMC,KAAV,CAAgBD,YAAMC,KAAN,CAAYI,kBAA5B,EAAgD,4BAAhD,CAAN;AACD;;AAED,UAAMC,KAAK,GAAGhB,UAAU,CAACiB,iBAAX,CAA6BV,GAA7B,CAAd;AACA,QAAIW,OAAJ;AACA,UAAMC,OAAO,GAAG,IAAIC,OAAJ,CAAYC,QAAQ,IAAI;AACtCH,MAAAA,OAAO,GAAGG,QAAV;AACD,KAFe,CAAhB;AAGA,QAAIC,YAAJ;AACAT,IAAAA,cAAc,CACXU,QADH,CACYhB,GAAG,CAACiB,IADhB,EACsBR,KADtB,EAC6BT,GAAG,CAACO,MADjC,EACyCP,GAAG,CAACC,IAD7C,EACmDiB,QAAQ,IAAI;AAC3DH,MAAAA,YAAY,GAAGG,QAAf;AACAP,MAAAA,OAAO,CAAC;AACNQ,QAAAA,OAAO,EAAE;AACP,oCAA0BJ;AADnB,SADH;AAINK,QAAAA,QAAQ,EAAE;AACRC,UAAAA,MAAM,EAAE;AADA;AAJJ,OAAD,CAAP;AAQD,KAXH,EAYGC,KAZH,CAYSC,GAAG,IAAI;AACZvB,MAAAA,GAAG,CAACO,MAAJ,CAAWiB,gBAAX,CAA4BC,KAA5B,CACG,eAAcV,YAAa,4BAD9B,EAEEQ,GAFF;AAID,KAjBH;AAkBA,WAAOX,OAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,SAAOF,iBAAP,CAAyBV,GAAzB,EAA8B;AAC5B,UAAMiB,IAAI,GAAGjB,GAAG,CAACiB,IAAJ,IAAY,EAAzB;AACA,UAAMS,QAAQ,GAAG,OAAOT,IAAI,CAACR,KAAZ,KAAsB,WAAvC;AACA,UAAMkB,WAAW,GAAG,OAAOV,IAAI,CAACW,QAAZ,KAAyB,WAA7C;AAEA,QAAInB,KAAJ;;AACA,QAAIiB,QAAQ,IAAIC,WAAhB,EAA6B;AAC3B,YAAM,IAAIxB,YAAMC,KAAV,CACJD,YAAMC,KAAN,CAAYI,kBADR,EAEJ,qDAFI,CAAN;AAID,KALD,MAKO,IAAIkB,QAAJ,EAAc;AACnBjB,MAAAA,KAAK,GAAGQ,IAAI,CAACR,KAAb;AACD,KAFM,MAEA,IAAIkB,WAAJ,EAAiB;AACtBlB,MAAAA,KAAK,GAAG;AACNmB,QAAAA,QAAQ,EAAE;AACRC,UAAAA,GAAG,EAAEZ,IAAI,CAACW;AADF;AADJ,OAAR;AAKD,KANM,MAMA;AACL,YAAM,IAAIzB,YAAMC,KAAV,CACJD,YAAMC,KAAN,CAAYI,kBADR,EAEJ,+DAFI,CAAN;AAID;;AACD,WAAOC,KAAP;AACD;;AA3E2C;;;eA8E/BhB,U","sourcesContent":["import PromiseRouter from '../PromiseRouter';\nimport * as middleware from '../middlewares';\nimport { Parse } from 'parse/node';\n\nexport class PushRouter extends PromiseRouter {\n  mountRoutes() {\n    this.route('POST', '/push', middleware.promiseEnforceMasterKeyAccess, PushRouter.handlePOST);\n  }\n\n  static handlePOST(req) {\n    if (req.auth.isReadOnly) {\n      throw new Parse.Error(\n        Parse.Error.OPERATION_FORBIDDEN,\n        \"read-only masterKey isn't allowed to send push notifications.\"\n      );\n    }\n    const pushController = req.config.pushController;\n    if (!pushController) {\n      throw new Parse.Error(Parse.Error.PUSH_MISCONFIGURED, 'Push controller is not set');\n    }\n\n    const where = PushRouter.getQueryCondition(req);\n    let resolve;\n    const promise = new Promise(_resolve => {\n      resolve = _resolve;\n    });\n    let pushStatusId;\n    pushController\n      .sendPush(req.body, where, req.config, req.auth, objectId => {\n        pushStatusId = objectId;\n        resolve({\n          headers: {\n            'X-Parse-Push-Status-Id': pushStatusId,\n          },\n          response: {\n            result: true,\n          },\n        });\n      })\n      .catch(err => {\n        req.config.loggerController.error(\n          `_PushStatus ${pushStatusId}: error while sending push`,\n          err\n        );\n      });\n    return promise;\n  }\n\n  /**\n   * Get query condition from the request body.\n   * @param {Object} req A request object\n   * @returns {Object} The query condition, the where field in a query api call\n   */\n  static getQueryCondition(req) {\n    const body = req.body || {};\n    const hasWhere = typeof body.where !== 'undefined';\n    const hasChannels = typeof body.channels !== 'undefined';\n\n    let where;\n    if (hasWhere && hasChannels) {\n      throw new Parse.Error(\n        Parse.Error.PUSH_MISCONFIGURED,\n        'Channels and query can not be set at the same time.'\n      );\n    } else if (hasWhere) {\n      where = body.where;\n    } else if (hasChannels) {\n      where = {\n        channels: {\n          $in: body.channels,\n        },\n      };\n    } else {\n      throw new Parse.Error(\n        Parse.Error.PUSH_MISCONFIGURED,\n        'Sending a push requires either \"channels\" or a \"where\" query.'\n      );\n    }\n    return where;\n  }\n}\n\nexport default PushRouter;\n"],"file":"PushRouter.js"}