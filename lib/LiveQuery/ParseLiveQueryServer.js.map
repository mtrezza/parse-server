{"version":3,"sources":["../../src/LiveQuery/ParseLiveQueryServer.js"],"names":["ParseLiveQueryServer","constructor","server","config","parseServerConfig","clients","Map","subscriptions","appId","Parse","applicationId","masterKey","keyPairs","key","Object","keys","set","logger","verbose","disableSingleInstance","serverURL","initialize","javaScriptKey","cacheController","cacheTimeout","authCache","LRU","max","maxAge","parseWebSocketServer","ParseWebSocketServer","parseWebsocket","_onConnect","subscriber","ParsePubSub","createSubscriber","subscribe","on","channel","messageStr","message","JSON","parse","e","error","_inflateParseObject","_onAfterSave","_onAfterDelete","currentParseObject","UserRouter","removeHiddenProperties","className","parseObject","_finishFetch","originalParseObject","deletedParseObject","toJSON","classLevelPermissions","id","size","classSubscriptions","get","debug","subscription","values","isSubscriptionMatched","_matchesSubscription","clientId","requestIds","_","entries","clientRequestIds","client","requestId","acl","getACL","op","_getCLPOperation","query","res","_matchesCLP","then","_matchesACL","isMatched","event","sessionToken","object","useMasterKey","hasMasterKey","installationId","sendEvent","pushDelete","catch","Client","pushError","parseWebSocket","code","stringify","isOriginalSubscriptionMatched","isCurrentSubscriptionMatched","originalACLCheckingPromise","Promise","resolve","originalACL","currentACLCheckingPromise","currentACL","all","isOriginalMatched","isCurrentMatched","hash","type","original","functionName","charAt","toUpperCase","slice","request","tv4","validate","RequestSchema","_handleConnect","_handleSubscribe","_handleUpdateSubscription","_handleUnsubscribe","info","has","delete","subscriptionInfo","subscriptionInfos","deleteClientSubscription","hasSubscribingClient","getAuthForSessionToken","fromCache","authPromise","auth","userId","user","result","Error","INVALID_SESSION_TOKEN","del","getSubscriptionInfo","aclGroup","push","SchemaController","validatePermission","length","objectId","_verifyACL","token","isSubscriptionSessionTokenMatched","getReadAccess","acl_has_roles","permissionsById","some","startsWith","roleNames","getUserRoles","role","getPublicReadAccess","subscriptionToken","clientSessionToken","_validateKeys","_hasMasterKey","req","pushConnect","validKeyPairs","prototype","hasOwnProperty","call","isValid","secret","subscriptionHash","Subscription","where","fields","addSubscriptionInfo","addClientSubscription","pushSubscribe","notifyClient","deleteSubscriptionInfo","pushUnsubscribe"],"mappings":"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","sourcesContent":["import tv4 from 'tv4';\nimport Parse from 'parse/node';\nimport { Subscription } from './Subscription';\nimport { Client } from './Client';\nimport { ParseWebSocketServer } from './ParseWebSocketServer';\nimport logger from '../logger';\nimport RequestSchema from './RequestSchema';\nimport { matchesQuery, queryHash } from './QueryTools';\nimport { ParsePubSub } from './ParsePubSub';\nimport SchemaController from '../Controllers/SchemaController';\nimport _ from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  runLiveQueryEventHandlers,\n  maybeRunConnectTrigger,\n  maybeRunSubscribeTrigger,\n  maybeRunAfterEventTrigger,\n} from '../triggers';\nimport { getAuthForSessionToken, Auth } from '../Auth';\nimport { getCacheController } from '../Controllers';\nimport LRU from 'lru-cache';\nimport UserRouter from '../Routers/UsersRouter';\n\nclass ParseLiveQueryServer {\n  clients: Map;\n  // className -> (queryHash -> subscription)\n  subscriptions: Object;\n  parseWebSocketServer: Object;\n  keyPairs: any;\n  // The subscriber we use to get object update from publisher\n  subscriber: Object;\n\n  constructor(server: any, config: any = {}, parseServerConfig: any = {}) {\n    this.server = server;\n    this.clients = new Map();\n    this.subscriptions = new Map();\n    this.config = config;\n\n    config.appId = config.appId || Parse.applicationId;\n    config.masterKey = config.masterKey || Parse.masterKey;\n\n    // Store keys, convert obj to map\n    const keyPairs = config.keyPairs || {};\n    this.keyPairs = new Map();\n    for (const key of Object.keys(keyPairs)) {\n      this.keyPairs.set(key, keyPairs[key]);\n    }\n    logger.verbose('Support key pairs', this.keyPairs);\n\n    // Initialize Parse\n    Parse.Object.disableSingleInstance();\n    const serverURL = config.serverURL || Parse.serverURL;\n    Parse.serverURL = serverURL;\n    Parse.initialize(config.appId, Parse.javaScriptKey, config.masterKey);\n\n    // The cache controller is a proper cache controller\n    // with access to User and Roles\n    this.cacheController = getCacheController(parseServerConfig);\n\n    config.cacheTimeout = config.cacheTimeout || 5 * 1000; // 5s\n\n    // This auth cache stores the promises for each auth resolution.\n    // The main benefit is to be able to reuse the same user / session token resolution.\n    this.authCache = new LRU({\n      max: 500, // 500 concurrent\n      maxAge: config.cacheTimeout,\n    });\n    // Initialize websocket server\n    this.parseWebSocketServer = new ParseWebSocketServer(\n      server,\n      parseWebsocket => this._onConnect(parseWebsocket),\n      config\n    );\n\n    // Initialize subscriber\n    this.subscriber = ParsePubSub.createSubscriber(config);\n    this.subscriber.subscribe(Parse.applicationId + 'afterSave');\n    this.subscriber.subscribe(Parse.applicationId + 'afterDelete');\n    // Register message handler for subscriber. When publisher get messages, it will publish message\n    // to the subscribers and the handler will be called.\n    this.subscriber.on('message', (channel, messageStr) => {\n      logger.verbose('Subscribe message %j', messageStr);\n      let message;\n      try {\n        message = JSON.parse(messageStr);\n      } catch (e) {\n        logger.error('unable to parse message', messageStr, e);\n        return;\n      }\n      this._inflateParseObject(message);\n      if (channel === Parse.applicationId + 'afterSave') {\n        this._onAfterSave(message);\n      } else if (channel === Parse.applicationId + 'afterDelete') {\n        this._onAfterDelete(message);\n      } else {\n        logger.error('Get message %s from unknown channel %j', message, channel);\n      }\n    });\n  }\n\n  // Message is the JSON object from publisher. Message.currentParseObject is the ParseObject JSON after changes.\n  // Message.originalParseObject is the original ParseObject JSON.\n  _inflateParseObject(message: any): void {\n    // Inflate merged object\n    const currentParseObject = message.currentParseObject;\n    UserRouter.removeHiddenProperties(currentParseObject);\n    let className = currentParseObject.className;\n    let parseObject = new Parse.Object(className);\n    parseObject._finishFetch(currentParseObject);\n    message.currentParseObject = parseObject;\n    // Inflate original object\n    const originalParseObject = message.originalParseObject;\n    if (originalParseObject) {\n      UserRouter.removeHiddenProperties(originalParseObject);\n      className = originalParseObject.className;\n      parseObject = new Parse.Object(className);\n      parseObject._finishFetch(originalParseObject);\n      message.originalParseObject = parseObject;\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  _onAfterDelete(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterDelete is triggered');\n\n    let deletedParseObject = message.currentParseObject.toJSON();\n    const classLevelPermissions = message.classLevelPermissions;\n    const className = deletedParseObject.className;\n    logger.verbose('ClassName: %j | ObjectId: %s', className, deletedParseObject.id);\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isSubscriptionMatched = this._matchesSubscription(deletedParseObject, subscription);\n      if (!isSubscriptionMatched) {\n        continue;\n      }\n      for (const [clientId, requestIds] of _.entries(subscription.clientRequestIds)) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        for (const requestId of requestIds) {\n          const acl = message.currentParseObject.getACL();\n          // Check CLP\n          const op = this._getCLPOperation(subscription.query);\n          let res = {};\n          this._matchesCLP(classLevelPermissions, message.currentParseObject, client, requestId, op)\n            .then(() => {\n              // Check ACL\n              return this._matchesACL(acl, client, requestId);\n            })\n            .then(isMatched => {\n              if (!isMatched) {\n                return null;\n              }\n              res = {\n                event: 'delete',\n                sessionToken: client.sessionToken,\n                object: deletedParseObject,\n                clients: this.clients.size,\n                subscriptions: this.subscriptions.size,\n                useMasterKey: client.hasMasterKey,\n                installationId: client.installationId,\n                sendEvent: true,\n              };\n              return maybeRunAfterEventTrigger('afterEvent', className, res);\n            })\n            .then(() => {\n              if (!res.sendEvent) {\n                return;\n              }\n              if (res.object && typeof res.object.toJSON === 'function') {\n                deletedParseObject = res.object.toJSON();\n                deletedParseObject.className = className;\n              }\n              client.pushDelete(requestId, deletedParseObject);\n            })\n            .catch(error => {\n              Client.pushError(\n                client.parseWebSocket,\n                error.code || 141,\n                error.message || error,\n                false,\n                requestId\n              );\n              logger.error(\n                `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                  JSON.stringify(error)\n              );\n            });\n        }\n      }\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  _onAfterSave(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterSave is triggered');\n\n    let originalParseObject = null;\n    if (message.originalParseObject) {\n      originalParseObject = message.originalParseObject.toJSON();\n    }\n    const classLevelPermissions = message.classLevelPermissions;\n    let currentParseObject = message.currentParseObject.toJSON();\n    const className = currentParseObject.className;\n    logger.verbose('ClassName: %s | ObjectId: %s', className, currentParseObject.id);\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isOriginalSubscriptionMatched = this._matchesSubscription(\n        originalParseObject,\n        subscription\n      );\n      const isCurrentSubscriptionMatched = this._matchesSubscription(\n        currentParseObject,\n        subscription\n      );\n      for (const [clientId, requestIds] of _.entries(subscription.clientRequestIds)) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        for (const requestId of requestIds) {\n          // Set orignal ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let originalACLCheckingPromise;\n          if (!isOriginalSubscriptionMatched) {\n            originalACLCheckingPromise = Promise.resolve(false);\n          } else {\n            let originalACL;\n            if (message.originalParseObject) {\n              originalACL = message.originalParseObject.getACL();\n            }\n            originalACLCheckingPromise = this._matchesACL(originalACL, client, requestId);\n          }\n          // Set current ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let currentACLCheckingPromise;\n          let res = {};\n          if (!isCurrentSubscriptionMatched) {\n            currentACLCheckingPromise = Promise.resolve(false);\n          } else {\n            const currentACL = message.currentParseObject.getACL();\n            currentACLCheckingPromise = this._matchesACL(currentACL, client, requestId);\n          }\n          const op = this._getCLPOperation(subscription.query);\n          this._matchesCLP(classLevelPermissions, message.currentParseObject, client, requestId, op)\n            .then(() => {\n              return Promise.all([originalACLCheckingPromise, currentACLCheckingPromise]);\n            })\n            .then(([isOriginalMatched, isCurrentMatched]) => {\n              logger.verbose(\n                'Original %j | Current %j | Match: %s, %s, %s, %s | Query: %s',\n                originalParseObject,\n                currentParseObject,\n                isOriginalSubscriptionMatched,\n                isCurrentSubscriptionMatched,\n                isOriginalMatched,\n                isCurrentMatched,\n                subscription.hash\n              );\n              // Decide event type\n              let type;\n              if (isOriginalMatched && isCurrentMatched) {\n                type = 'update';\n              } else if (isOriginalMatched && !isCurrentMatched) {\n                type = 'leave';\n              } else if (!isOriginalMatched && isCurrentMatched) {\n                if (originalParseObject) {\n                  type = 'enter';\n                } else {\n                  type = 'create';\n                }\n              } else {\n                return null;\n              }\n              message.event = type;\n              res = {\n                event: type,\n                sessionToken: client.sessionToken,\n                object: currentParseObject,\n                original: originalParseObject,\n                clients: this.clients.size,\n                subscriptions: this.subscriptions.size,\n                useMasterKey: client.hasMasterKey,\n                installationId: client.installationId,\n                sendEvent: true,\n              };\n              return maybeRunAfterEventTrigger('afterEvent', className, res);\n            })\n            .then(\n              () => {\n                if (!res.sendEvent) {\n                  return;\n                }\n                if (res.object && typeof res.object.toJSON === 'function') {\n                  currentParseObject = res.object.toJSON();\n                  currentParseObject.className = res.object.className || className;\n                }\n\n                if (res.original && typeof res.original.toJSON === 'function') {\n                  originalParseObject = res.original.toJSON();\n                  originalParseObject.className = res.original.className || className;\n                }\n                const functionName =\n                  'push' + message.event.charAt(0).toUpperCase() + message.event.slice(1);\n                if (client[functionName]) {\n                  client[functionName](requestId, currentParseObject, originalParseObject);\n                }\n              },\n              error => {\n                Client.pushError(\n                  client.parseWebSocket,\n                  error.code || 141,\n                  error.message || error,\n                  false,\n                  requestId\n                );\n                logger.error(\n                  `Failed running afterLiveQueryEvent on class ${className} for event ${res.event} with session ${res.sessionToken} with:\\n Error: ` +\n                    JSON.stringify(error)\n                );\n              }\n            );\n        }\n      }\n    }\n  }\n\n  _onConnect(parseWebsocket: any): void {\n    parseWebsocket.on('message', request => {\n      if (typeof request === 'string') {\n        try {\n          request = JSON.parse(request);\n        } catch (e) {\n          logger.error('unable to parse request', request, e);\n          return;\n        }\n      }\n      logger.verbose('Request: %j', request);\n\n      // Check whether this request is a valid request, return error directly if not\n      if (\n        !tv4.validate(request, RequestSchema['general']) ||\n        !tv4.validate(request, RequestSchema[request.op])\n      ) {\n        Client.pushError(parseWebsocket, 1, tv4.error.message);\n        logger.error('Connect message error %s', tv4.error.message);\n        return;\n      }\n\n      switch (request.op) {\n        case 'connect':\n          this._handleConnect(parseWebsocket, request);\n          break;\n        case 'subscribe':\n          this._handleSubscribe(parseWebsocket, request);\n          break;\n        case 'update':\n          this._handleUpdateSubscription(parseWebsocket, request);\n          break;\n        case 'unsubscribe':\n          this._handleUnsubscribe(parseWebsocket, request);\n          break;\n        default:\n          Client.pushError(parseWebsocket, 3, 'Get unknown operation');\n          logger.error('Get unknown operation', request.op);\n      }\n    });\n\n    parseWebsocket.on('disconnect', () => {\n      logger.info(`Client disconnect: ${parseWebsocket.clientId}`);\n      const clientId = parseWebsocket.clientId;\n      if (!this.clients.has(clientId)) {\n        runLiveQueryEventHandlers({\n          event: 'ws_disconnect_error',\n          clients: this.clients.size,\n          subscriptions: this.subscriptions.size,\n          error: `Unable to find client ${clientId}`,\n        });\n        logger.error(`Can not find client ${clientId} on disconnect`);\n        return;\n      }\n\n      // Delete client\n      const client = this.clients.get(clientId);\n      this.clients.delete(clientId);\n\n      // Delete client from subscriptions\n      for (const [requestId, subscriptionInfo] of _.entries(client.subscriptionInfos)) {\n        const subscription = subscriptionInfo.subscription;\n        subscription.deleteClientSubscription(clientId, requestId);\n\n        // If there is no client which is subscribing this subscription, remove it from subscriptions\n        const classSubscriptions = this.subscriptions.get(subscription.className);\n        if (!subscription.hasSubscribingClient()) {\n          classSubscriptions.delete(subscription.hash);\n        }\n        // If there is no subscriptions under this class, remove it from subscriptions\n        if (classSubscriptions.size === 0) {\n          this.subscriptions.delete(subscription.className);\n        }\n      }\n\n      logger.verbose('Current clients %d', this.clients.size);\n      logger.verbose('Current subscriptions %d', this.subscriptions.size);\n      runLiveQueryEventHandlers({\n        event: 'ws_disconnect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n        sessionToken: client.sessionToken,\n      });\n    });\n\n    runLiveQueryEventHandlers({\n      event: 'ws_connect',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n    });\n  }\n\n  _matchesSubscription(parseObject: any, subscription: any): boolean {\n    // Object is undefined or null, not match\n    if (!parseObject) {\n      return false;\n    }\n    return matchesQuery(parseObject, subscription.query);\n  }\n\n  getAuthForSessionToken(sessionToken: ?string): Promise<{ auth: ?Auth, userId: ?string }> {\n    if (!sessionToken) {\n      return Promise.resolve({});\n    }\n    const fromCache = this.authCache.get(sessionToken);\n    if (fromCache) {\n      return fromCache;\n    }\n    const authPromise = getAuthForSessionToken({\n      cacheController: this.cacheController,\n      sessionToken: sessionToken,\n    })\n      .then(auth => {\n        return { auth, userId: auth && auth.user && auth.user.id };\n      })\n      .catch(error => {\n        // There was an error with the session token\n        const result = {};\n        if (error && error.code === Parse.Error.INVALID_SESSION_TOKEN) {\n          result.error = error;\n          this.authCache.set(sessionToken, Promise.resolve(result), this.config.cacheTimeout);\n        } else {\n          this.authCache.del(sessionToken);\n        }\n        return result;\n      });\n    this.authCache.set(sessionToken, authPromise);\n    return authPromise;\n  }\n\n  async _matchesCLP(\n    classLevelPermissions: ?any,\n    object: any,\n    client: any,\n    requestId: number,\n    op: string\n  ): any {\n    // try to match on user first, less expensive than with roles\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    const aclGroup = ['*'];\n    let userId;\n    if (typeof subscriptionInfo !== 'undefined') {\n      const { userId } = await this.getAuthForSessionToken(subscriptionInfo.sessionToken);\n      if (userId) {\n        aclGroup.push(userId);\n      }\n    }\n    try {\n      await SchemaController.validatePermission(\n        classLevelPermissions,\n        object.className,\n        aclGroup,\n        op\n      );\n      return true;\n    } catch (e) {\n      logger.verbose(`Failed matching CLP for ${object.id} ${userId} ${e}`);\n      return false;\n    }\n    // TODO: handle roles permissions\n    // Object.keys(classLevelPermissions).forEach((key) => {\n    //   const perm = classLevelPermissions[key];\n    //   Object.keys(perm).forEach((key) => {\n    //     if (key.indexOf('role'))\n    //   });\n    // })\n    // // it's rejected here, check the roles\n    // var rolesQuery = new Parse.Query(Parse.Role);\n    // rolesQuery.equalTo(\"users\", user);\n    // return rolesQuery.find({useMasterKey:true});\n  }\n\n  _getCLPOperation(query: any) {\n    return typeof query === 'object' &&\n      Object.keys(query).length == 1 &&\n      typeof query.objectId === 'string'\n      ? 'get'\n      : 'find';\n  }\n\n  async _verifyACL(acl: any, token: string) {\n    if (!token) {\n      return false;\n    }\n\n    const { auth, userId } = await this.getAuthForSessionToken(token);\n\n    // Getting the session token failed\n    // This means that no additional auth is available\n    // At this point, just bail out as no additional visibility can be inferred.\n    if (!auth || !userId) {\n      return false;\n    }\n    const isSubscriptionSessionTokenMatched = acl.getReadAccess(userId);\n    if (isSubscriptionSessionTokenMatched) {\n      return true;\n    }\n\n    // Check if the user has any roles that match the ACL\n    return Promise.resolve()\n      .then(async () => {\n        // Resolve false right away if the acl doesn't have any roles\n        const acl_has_roles = Object.keys(acl.permissionsById).some(key => key.startsWith('role:'));\n        if (!acl_has_roles) {\n          return false;\n        }\n\n        const roleNames = await auth.getUserRoles();\n        // Finally, see if any of the user's roles allow them read access\n        for (const role of roleNames) {\n          // We use getReadAccess as `role` is in the form `role:roleName`\n          if (acl.getReadAccess(role)) {\n            return true;\n          }\n        }\n        return false;\n      })\n      .catch(() => {\n        return false;\n      });\n  }\n\n  async _matchesACL(acl: any, client: any, requestId: number): Promise<boolean> {\n    // Return true directly if ACL isn't present, ACL is public read, or client has master key\n    if (!acl || acl.getPublicReadAccess() || client.hasMasterKey) {\n      return true;\n    }\n    // Check subscription sessionToken matches ACL first\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      return false;\n    }\n\n    const subscriptionToken = subscriptionInfo.sessionToken;\n    const clientSessionToken = client.sessionToken;\n\n    if (await this._verifyACL(acl, subscriptionToken)) {\n      return true;\n    }\n\n    if (await this._verifyACL(acl, clientSessionToken)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  async _handleConnect(parseWebsocket: any, request: any): any {\n    if (!this._validateKeys(request, this.keyPairs)) {\n      Client.pushError(parseWebsocket, 4, 'Key in request is not valid');\n      logger.error('Key in request is not valid');\n      return;\n    }\n    const hasMasterKey = this._hasMasterKey(request, this.keyPairs);\n    const clientId = uuidv4();\n    const client = new Client(\n      clientId,\n      parseWebsocket,\n      hasMasterKey,\n      request.sessionToken,\n      request.installationId\n    );\n    try {\n      const req = {\n        client,\n        event: 'connect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: request.installationId,\n      };\n      await maybeRunConnectTrigger('beforeConnect', req);\n      parseWebsocket.clientId = clientId;\n      this.clients.set(parseWebsocket.clientId, client);\n      logger.info(`Create new client: ${parseWebsocket.clientId}`);\n      client.pushConnect();\n      runLiveQueryEventHandlers(req);\n    } catch (error) {\n      Client.pushError(parseWebsocket, error.code || 141, error.message || error, false);\n      logger.error(\n        `Failed running beforeConnect for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(error)\n      );\n    }\n  }\n\n  _hasMasterKey(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0 || !validKeyPairs.has('masterKey')) {\n      return false;\n    }\n    if (!request || !Object.prototype.hasOwnProperty.call(request, 'masterKey')) {\n      return false;\n    }\n    return request.masterKey === validKeyPairs.get('masterKey');\n  }\n\n  _validateKeys(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0) {\n      return true;\n    }\n    let isValid = false;\n    for (const [key, secret] of validKeyPairs) {\n      if (!request[key] || request[key] !== secret) {\n        continue;\n      }\n      isValid = true;\n      break;\n    }\n    return isValid;\n  }\n\n  async _handleSubscribe(parseWebsocket: any, request: any): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before subscribing'\n      );\n      logger.error('Can not find this client, make sure you connect to server before subscribing');\n      return;\n    }\n    const client = this.clients.get(parseWebsocket.clientId);\n    const className = request.query.className;\n    try {\n      await maybeRunSubscribeTrigger('beforeSubscribe', className, request);\n\n      // Get subscription from subscriptions, create one if necessary\n      const subscriptionHash = queryHash(request.query);\n      // Add className to subscriptions if necessary\n\n      if (!this.subscriptions.has(className)) {\n        this.subscriptions.set(className, new Map());\n      }\n      const classSubscriptions = this.subscriptions.get(className);\n      let subscription;\n      if (classSubscriptions.has(subscriptionHash)) {\n        subscription = classSubscriptions.get(subscriptionHash);\n      } else {\n        subscription = new Subscription(className, request.query.where, subscriptionHash);\n        classSubscriptions.set(subscriptionHash, subscription);\n      }\n\n      // Add subscriptionInfo to client\n      const subscriptionInfo = {\n        subscription: subscription,\n      };\n      // Add selected fields, sessionToken and installationId for this subscription if necessary\n      if (request.query.fields) {\n        subscriptionInfo.fields = request.query.fields;\n      }\n      if (request.sessionToken) {\n        subscriptionInfo.sessionToken = request.sessionToken;\n      }\n      client.addSubscriptionInfo(request.requestId, subscriptionInfo);\n\n      // Add clientId to subscription\n      subscription.addClientSubscription(parseWebsocket.clientId, request.requestId);\n\n      client.pushSubscribe(request.requestId);\n\n      logger.verbose(\n        `Create client ${parseWebsocket.clientId} new subscription: ${request.requestId}`\n      );\n      logger.verbose('Current client number: %d', this.clients.size);\n      runLiveQueryEventHandlers({\n        client,\n        event: 'subscribe',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size,\n        sessionToken: request.sessionToken,\n        useMasterKey: client.hasMasterKey,\n        installationId: client.installationId,\n      });\n    } catch (e) {\n      Client.pushError(parseWebsocket, e.code || 141, e.message || e, false, request.requestId);\n      logger.error(\n        `Failed running beforeSubscribe on ${className} for session ${request.sessionToken} with:\\n Error: ` +\n          JSON.stringify(e)\n      );\n    }\n  }\n\n  _handleUpdateSubscription(parseWebsocket: any, request: any): any {\n    this._handleUnsubscribe(parseWebsocket, request, false);\n    this._handleSubscribe(parseWebsocket, request);\n  }\n\n  _handleUnsubscribe(parseWebsocket: any, request: any, notifyClient: boolean = true): any {\n    // If we can not find this client, return error to client\n    if (!Object.prototype.hasOwnProperty.call(parseWebsocket, 'clientId')) {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      logger.error(\n        'Can not find this client, make sure you connect to server before unsubscribing'\n      );\n      return;\n    }\n    const requestId = request.requestId;\n    const client = this.clients.get(parseWebsocket.clientId);\n    if (typeof client === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find client with clientId ' +\n          parseWebsocket.clientId +\n          '. Make sure you connect to live query server before unsubscribing.'\n      );\n      logger.error('Can not find this client ' + parseWebsocket.clientId);\n      return;\n    }\n\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      Client.pushError(\n        parseWebsocket,\n        2,\n        'Cannot find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId +\n          '. Make sure you subscribe to live query server before unsubscribing.'\n      );\n      logger.error(\n        'Can not find subscription with clientId ' +\n          parseWebsocket.clientId +\n          ' subscriptionId ' +\n          requestId\n      );\n      return;\n    }\n\n    // Remove subscription from client\n    client.deleteSubscriptionInfo(requestId);\n    // Remove client from subscription\n    const subscription = subscriptionInfo.subscription;\n    const className = subscription.className;\n    subscription.deleteClientSubscription(parseWebsocket.clientId, requestId);\n    // If there is no client which is subscribing this subscription, remove it from subscriptions\n    const classSubscriptions = this.subscriptions.get(className);\n    if (!subscription.hasSubscribingClient()) {\n      classSubscriptions.delete(subscription.hash);\n    }\n    // If there is no subscriptions under this class, remove it from subscriptions\n    if (classSubscriptions.size === 0) {\n      this.subscriptions.delete(className);\n    }\n    runLiveQueryEventHandlers({\n      client,\n      event: 'unsubscribe',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size,\n      sessionToken: subscriptionInfo.sessionToken,\n      useMasterKey: client.hasMasterKey,\n      installationId: client.installationId,\n    });\n\n    if (!notifyClient) {\n      return;\n    }\n\n    client.pushUnsubscribe(request.requestId);\n\n    logger.verbose(\n      `Delete client: ${parseWebsocket.clientId} | subscription: ${request.requestId}`\n    );\n  }\n}\n\nexport { ParseLiveQueryServer };\n"],"file":"ParseLiveQueryServer.js"}