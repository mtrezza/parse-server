{"version":3,"sources":["../../src/LiveQuery/QueryTools.js"],"names":["equalObjects","require","Id","Parse","flattenOrQueries","where","Object","prototype","hasOwnProperty","call","accum","i","$or","length","concat","stringify","object","replace","Array","isArray","copy","map","sort","join","sections","keys","k","push","queryHash","query","Query","className","_where","columns","values","uniqueColumns","subValues","j","contains","haystack","needle","__type","ptr","objectId","indexOf","matchesQuery","id","field","matchesKeyConstraints","equalObjectsGeneric","obj","compareTo","eqlFn","key","constraints","keyComponents","split","subObjectKey","keyRemainder","slice","Date","iso","_decode","condition","propertyExists","existenceIsRequired","test","expString","escapeEnd","escapeStart","substring","Math","max","exp","RegExp","$options","distance","radiansTo","$maxDistance","Infinity","southWest","$box","northEast","latitude","longitude","value","points","$polygon","geoPoint","polygon","Polygon","containsPoint","coordinates","point","GeoPoint","$point","QueryTools","module","exports"],"mappings":"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","sourcesContent":["var equalObjects = require('./equalObjects');\nvar Id = require('./Id');\nvar Parse = require('parse/node');\n\n/**\n * Query Hashes are deterministic hashes for Parse Queries.\n * Any two queries that have the same set of constraints will produce the same\n * hash. This lets us reliably group components by the queries they depend upon,\n * and quickly determine if a query has changed.\n */\n\n/**\n * Convert $or queries into an array of where conditions\n */\nfunction flattenOrQueries(where) {\n  if (!Object.prototype.hasOwnProperty.call(where, '$or')) {\n    return where;\n  }\n  var accum = [];\n  for (var i = 0; i < where.$or.length; i++) {\n    accum = accum.concat(where.$or[i]);\n  }\n  return accum;\n}\n\n/**\n * Deterministically turns an object into a string. Disregards ordering\n */\nfunction stringify(object): string {\n  if (typeof object !== 'object' || object === null) {\n    if (typeof object === 'string') {\n      return '\"' + object.replace(/\\|/g, '%|') + '\"';\n    }\n    return object + '';\n  }\n  if (Array.isArray(object)) {\n    var copy = object.map(stringify);\n    copy.sort();\n    return '[' + copy.join(',') + ']';\n  }\n  var sections = [];\n  var keys = Object.keys(object);\n  keys.sort();\n  for (var k = 0; k < keys.length; k++) {\n    sections.push(stringify(keys[k]) + ':' + stringify(object[keys[k]]));\n  }\n  return '{' + sections.join(',') + '}';\n}\n\n/**\n * Generate a hash from a query, with unique fields for columns, values, order,\n * skip, and limit.\n */\nfunction queryHash(query) {\n  if (query instanceof Parse.Query) {\n    query = {\n      className: query.className,\n      where: query._where,\n    };\n  }\n  var where = flattenOrQueries(query.where || {});\n  var columns = [];\n  var values = [];\n  var i;\n  if (Array.isArray(where)) {\n    var uniqueColumns = {};\n    for (i = 0; i < where.length; i++) {\n      var subValues = {};\n      var keys = Object.keys(where[i]);\n      keys.sort();\n      for (var j = 0; j < keys.length; j++) {\n        subValues[keys[j]] = where[i][keys[j]];\n        uniqueColumns[keys[j]] = true;\n      }\n      values.push(subValues);\n    }\n    columns = Object.keys(uniqueColumns);\n    columns.sort();\n  } else {\n    columns = Object.keys(where);\n    columns.sort();\n    for (i = 0; i < columns.length; i++) {\n      values.push(where[columns[i]]);\n    }\n  }\n\n  var sections = [columns.join(','), stringify(values)];\n\n  return query.className + ':' + sections.join('|');\n}\n\n/**\n * contains -- Determines if an object is contained in a list with special handling for Parse pointers.\n */\nfunction contains(haystack: Array, needle: any): boolean {\n  if (needle && needle.__type && needle.__type === 'Pointer') {\n    for (const i in haystack) {\n      const ptr = haystack[i];\n      if (typeof ptr === 'string' && ptr === needle.objectId) {\n        return true;\n      }\n      if (ptr.className === needle.className && ptr.objectId === needle.objectId) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return haystack.indexOf(needle) > -1;\n}\n/**\n * matchesQuery -- Determines if an object would be returned by a Parse Query\n * It's a lightweight, where-clause only implementation of a full query engine.\n * Since we find queries that match objects, rather than objects that match\n * queries, we can avoid building a full-blown query tool.\n */\nfunction matchesQuery(object: any, query: any): boolean {\n  if (query instanceof Parse.Query) {\n    var className = object.id instanceof Id ? object.id.className : object.className;\n    if (className !== query.className) {\n      return false;\n    }\n    return matchesQuery(object, query._where);\n  }\n  for (var field in query) {\n    if (!matchesKeyConstraints(object, field, query[field])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction equalObjectsGeneric(obj, compareTo, eqlFn) {\n  if (Array.isArray(obj)) {\n    for (var i = 0; i < obj.length; i++) {\n      if (eqlFn(obj[i], compareTo)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  return eqlFn(obj, compareTo);\n}\n\n/**\n * Determines whether an object matches a single key's constraints\n */\nfunction matchesKeyConstraints(object, key, constraints) {\n  if (constraints === null) {\n    return false;\n  }\n  if (key.indexOf('.') >= 0) {\n    // Key references a subobject\n    var keyComponents = key.split('.');\n    var subObjectKey = keyComponents[0];\n    var keyRemainder = keyComponents.slice(1).join('.');\n    return matchesKeyConstraints(object[subObjectKey] || {}, keyRemainder, constraints);\n  }\n  var i;\n  if (key === '$or') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(object, constraints[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if (key === '$and') {\n    for (i = 0; i < constraints.length; i++) {\n      if (!matchesQuery(object, constraints[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (key === '$nor') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(object, constraints[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (key === '$relatedTo') {\n    // Bail! We can't handle relational queries locally\n    return false;\n  }\n  // Decode Date JSON value\n  if (object[key] && object[key].__type == 'Date') {\n    object[key] = new Date(object[key].iso);\n  }\n  // Equality (or Array contains) cases\n  if (typeof constraints !== 'object') {\n    if (Array.isArray(object[key])) {\n      return object[key].indexOf(constraints) > -1;\n    }\n    return object[key] === constraints;\n  }\n  var compareTo;\n  if (constraints.__type) {\n    if (constraints.__type === 'Pointer') {\n      return equalObjectsGeneric(object[key], constraints, function (obj, ptr) {\n        return (\n          typeof obj !== 'undefined' &&\n          ptr.className === obj.className &&\n          ptr.objectId === obj.objectId\n        );\n      });\n    }\n\n    return equalObjectsGeneric(object[key], Parse._decode(key, constraints), equalObjects);\n  }\n  // More complex cases\n  for (var condition in constraints) {\n    compareTo = constraints[condition];\n    if (compareTo.__type) {\n      compareTo = Parse._decode(key, compareTo);\n    }\n    switch (condition) {\n      case '$lt':\n        if (object[key] >= compareTo) {\n          return false;\n        }\n        break;\n      case '$lte':\n        if (object[key] > compareTo) {\n          return false;\n        }\n        break;\n      case '$gt':\n        if (object[key] <= compareTo) {\n          return false;\n        }\n        break;\n      case '$gte':\n        if (object[key] < compareTo) {\n          return false;\n        }\n        break;\n      case '$ne':\n        if (equalObjects(object[key], compareTo)) {\n          return false;\n        }\n        break;\n      case '$in':\n        if (!contains(compareTo, object[key])) {\n          return false;\n        }\n        break;\n      case '$nin':\n        if (contains(compareTo, object[key])) {\n          return false;\n        }\n        break;\n      case '$all':\n        for (i = 0; i < compareTo.length; i++) {\n          if (object[key].indexOf(compareTo[i]) < 0) {\n            return false;\n          }\n        }\n        break;\n      case '$exists': {\n        const propertyExists = typeof object[key] !== 'undefined';\n        const existenceIsRequired = constraints['$exists'];\n        if (typeof constraints['$exists'] !== 'boolean') {\n          // The SDK will never submit a non-boolean for $exists, but if someone\n          // tries to submit a non-boolean for $exits outside the SDKs, just ignore it.\n          break;\n        }\n        if ((!propertyExists && existenceIsRequired) || (propertyExists && !existenceIsRequired)) {\n          return false;\n        }\n        break;\n      }\n      case '$regex':\n        if (typeof compareTo === 'object') {\n          return compareTo.test(object[key]);\n        }\n        // JS doesn't support perl-style escaping\n        var expString = '';\n        var escapeEnd = -2;\n        var escapeStart = compareTo.indexOf('\\\\Q');\n        while (escapeStart > -1) {\n          // Add the unescaped portion\n          expString += compareTo.substring(escapeEnd + 2, escapeStart);\n          escapeEnd = compareTo.indexOf('\\\\E', escapeStart);\n          if (escapeEnd > -1) {\n            expString += compareTo\n              .substring(escapeStart + 2, escapeEnd)\n              .replace(/\\\\\\\\\\\\\\\\E/g, '\\\\E')\n              .replace(/\\W/g, '\\\\$&');\n          }\n\n          escapeStart = compareTo.indexOf('\\\\Q', escapeEnd);\n        }\n        expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));\n        var exp = new RegExp(expString, constraints.$options || '');\n        if (!exp.test(object[key])) {\n          return false;\n        }\n        break;\n      case '$nearSphere':\n        if (!compareTo || !object[key]) {\n          return false;\n        }\n        var distance = compareTo.radiansTo(object[key]);\n        var max = constraints.$maxDistance || Infinity;\n        return distance <= max;\n      case '$within':\n        if (!compareTo || !object[key]) {\n          return false;\n        }\n        var southWest = compareTo.$box[0];\n        var northEast = compareTo.$box[1];\n        if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {\n          // Invalid box, crosses the date line\n          return false;\n        }\n        return (\n          object[key].latitude > southWest.latitude &&\n          object[key].latitude < northEast.latitude &&\n          object[key].longitude > southWest.longitude &&\n          object[key].longitude < northEast.longitude\n        );\n      case '$containedBy': {\n        for (const value of object[key]) {\n          if (!contains(compareTo, value)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      case '$geoWithin': {\n        const points = compareTo.$polygon.map(geoPoint => [geoPoint.latitude, geoPoint.longitude]);\n        const polygon = new Parse.Polygon(points);\n        return polygon.containsPoint(object[key]);\n      }\n      case '$geoIntersects': {\n        const polygon = new Parse.Polygon(object[key].coordinates);\n        const point = new Parse.GeoPoint(compareTo.$point);\n        return polygon.containsPoint(point);\n      }\n      case '$options':\n        // Not a query type, but a way to add options to $regex. Ignore and\n        // avoid the default\n        break;\n      case '$maxDistance':\n        // Not a query type, but a way to add a cap to $nearSphere. Ignore and\n        // avoid the default\n        break;\n      case '$select':\n        return false;\n      case '$dontSelect':\n        return false;\n      default:\n        return false;\n    }\n  }\n  return true;\n}\n\nvar QueryTools = {\n  queryHash: queryHash,\n  matchesQuery: matchesQuery,\n};\n\nmodule.exports = QueryTools;\n"],"file":"QueryTools.js"}