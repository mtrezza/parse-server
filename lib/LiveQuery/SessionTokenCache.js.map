{"version":3,"sources":["../../src/LiveQuery/SessionTokenCache.js"],"names":["userForSessionToken","sessionToken","q","Parse","Query","equalTo","first","useMasterKey","then","session","Promise","reject","get","SessionTokenCache","constructor","timeout","maxSize","cache","LRU","max","maxAge","getUserId","userId","logger","verbose","resolve","user","id","set","error"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;AAEA,SAASA,mBAAT,CAA6BC,YAA7B,EAA2C;AACzC,MAAIC,CAAC,GAAG,IAAIC,cAAMC,KAAV,CAAgB,UAAhB,CAAR;AACAF,EAAAA,CAAC,CAACG,OAAF,CAAU,cAAV,EAA0BJ,YAA1B;AACA,SAAOC,CAAC,CAACI,KAAF,CAAQ;AAAEC,IAAAA,YAAY,EAAE;AAAhB,GAAR,EAAgCC,IAAhC,CAAqC,UAAUC,OAAV,EAAmB;AAC7D,QAAI,CAACA,OAAL,EAAc;AACZ,aAAOC,OAAO,CAACC,MAAR,CAAe,oCAAf,CAAP;AACD;;AACD,WAAOF,OAAO,CAACG,GAAR,CAAY,MAAZ,CAAP;AACD,GALM,CAAP;AAMD;;AAED,MAAMC,iBAAN,CAAwB;AAGtBC,EAAAA,WAAW,CAACC,OAAe,GAAG,KAAK,EAAL,GAAU,EAAV,GAAe,EAAf,GAAoB,IAAvC,EAA6CC,OAAe,GAAG,KAA/D,EAAsE;AAC/E,SAAKC,KAAL,GAAa,IAAIC,iBAAJ,CAAQ;AACnBC,MAAAA,GAAG,EAAEH,OADc;AAEnBI,MAAAA,MAAM,EAAEL;AAFW,KAAR,CAAb;AAID;;AAEDM,EAAAA,SAAS,CAACpB,YAAD,EAA4B;AACnC,QAAI,CAACA,YAAL,EAAmB;AACjB,aAAOS,OAAO,CAACC,MAAR,CAAe,oBAAf,CAAP;AACD;;AACD,UAAMW,MAAM,GAAG,KAAKL,KAAL,CAAWL,GAAX,CAAeX,YAAf,CAAf;;AACA,QAAIqB,MAAJ,EAAY;AACVC,sBAAOC,OAAP,CAAe,+CAAf,EAAgEF,MAAhE,EAAwErB,YAAxE;;AACA,aAAOS,OAAO,CAACe,OAAR,CAAgBH,MAAhB,CAAP;AACD;;AACD,WAAOtB,mBAAmB,CAACC,YAAD,CAAnB,CAAkCO,IAAlC,CACLkB,IAAI,IAAI;AACNH,sBAAOC,OAAP,CAAe,+CAAf,EAAgEE,IAAI,CAACC,EAArE,EAAyE1B,YAAzE;;AACA,YAAMqB,MAAM,GAAGI,IAAI,CAACC,EAApB;AACA,WAAKV,KAAL,CAAWW,GAAX,CAAe3B,YAAf,EAA6BqB,MAA7B;AACA,aAAOZ,OAAO,CAACe,OAAR,CAAgBH,MAAhB,CAAP;AACD,KANI,EAOLO,KAAK,IAAI;AACPN,sBAAOM,KAAP,CAAa,oDAAb,EAAmE5B,YAAnE,EAAiF4B,KAAjF;;AACA,aAAOnB,OAAO,CAACC,MAAR,CAAekB,KAAf,CAAP;AACD,KAVI,CAAP;AAYD;;AA/BqB","sourcesContent":["import Parse from 'parse/node';\nimport LRU from 'lru-cache';\nimport logger from '../logger';\n\nfunction userForSessionToken(sessionToken) {\n  var q = new Parse.Query('_Session');\n  q.equalTo('sessionToken', sessionToken);\n  return q.first({ useMasterKey: true }).then(function (session) {\n    if (!session) {\n      return Promise.reject('No session found for session token');\n    }\n    return session.get('user');\n  });\n}\n\nclass SessionTokenCache {\n  cache: Object;\n\n  constructor(timeout: number = 30 * 24 * 60 * 60 * 1000, maxSize: number = 10000) {\n    this.cache = new LRU({\n      max: maxSize,\n      maxAge: timeout,\n    });\n  }\n\n  getUserId(sessionToken: string): any {\n    if (!sessionToken) {\n      return Promise.reject('Empty sessionToken');\n    }\n    const userId = this.cache.get(sessionToken);\n    if (userId) {\n      logger.verbose('Fetch userId %s of sessionToken %s from Cache', userId, sessionToken);\n      return Promise.resolve(userId);\n    }\n    return userForSessionToken(sessionToken).then(\n      user => {\n        logger.verbose('Fetch userId %s of sessionToken %s from Parse', user.id, sessionToken);\n        const userId = user.id;\n        this.cache.set(sessionToken, userId);\n        return Promise.resolve(userId);\n      },\n      error => {\n        logger.error('Can not fetch userId for sessionToken %j, error %j', sessionToken, error);\n        return Promise.reject(error);\n      }\n    );\n  }\n}\n\nexport { SessionTokenCache };\n"],"file":"SessionTokenCache.js"}