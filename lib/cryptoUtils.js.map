{"version":3,"sources":["../src/cryptoUtils.js"],"names":["randomHexString","size","Error","toString","randomString","chars","objectId","bytes","i","length","readUInt8","newObjectId","newToken","md5Hash","string","update","digest"],"mappings":";;;;;;;;;;;AAEA;;AAEA;AACO,SAASA,eAAT,CAAyBC,IAAzB,EAA+C;AACpD,MAAIA,IAAI,KAAK,CAAb,EAAgB;AACd,UAAM,IAAIC,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,MAAID,IAAI,GAAG,CAAP,KAAa,CAAjB,EAAoB;AAClB,UAAM,IAAIC,KAAJ,CAAU,8CAAV,CAAN;AACD;;AACD,SAAO,yBAAYD,IAAI,GAAG,CAAnB,EAAsBE,QAAtB,CAA+B,KAA/B,CAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASC,YAAT,CAAsBH,IAAtB,EAA4C;AACjD,MAAIA,IAAI,KAAK,CAAb,EAAgB;AACd,UAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;AACD;;AACD,QAAMG,KAAK,GAAG,+BAA+B,4BAA/B,GAA8D,YAA5E;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,QAAMC,KAAK,GAAG,yBAAYN,IAAZ,CAAd;;AACA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACrCF,IAAAA,QAAQ,IAAID,KAAK,CAACE,KAAK,CAACG,SAAN,CAAgBF,CAAhB,IAAqBH,KAAK,CAACI,MAA5B,CAAjB;AACD;;AACD,SAAOH,QAAP;AACD,C,CAED;;;AACO,SAASK,WAAT,CAAqBV,IAAY,GAAG,EAApC,EAAgD;AACrD,SAAOG,YAAY,CAACH,IAAD,CAAnB;AACD,C,CAED;;;AACO,SAASW,QAAT,GAA4B;AACjC,SAAOZ,eAAe,CAAC,EAAD,CAAtB;AACD;;AAEM,SAASa,OAAT,CAAiBC,MAAjB,EAAyC;AAC9C,SAAO,wBAAW,KAAX,EAAkBC,MAAlB,CAAyBD,MAAzB,EAAiCE,MAAjC,CAAwC,KAAxC,CAAP;AACD","sourcesContent":["/* @flow */\n\nimport { randomBytes, createHash } from 'crypto';\n\n// Returns a new random hex string of the given even size.\nexport function randomHexString(size: number): string {\n  if (size === 0) {\n    throw new Error('Zero-length randomHexString is useless.');\n  }\n  if (size % 2 !== 0) {\n    throw new Error('randomHexString size must be divisible by 2.');\n  }\n  return randomBytes(size / 2).toString('hex');\n}\n\n// Returns a new random alphanumeric string of the given size.\n//\n// Note: to simplify implementation, the result has slight modulo bias,\n// because chars length of 62 doesn't divide the number of all bytes\n// (256) evenly. Such bias is acceptable for most cases when the output\n// length is long enough and doesn't need to be uniform.\nexport function randomString(size: number): string {\n  if (size === 0) {\n    throw new Error('Zero-length randomString is useless.');\n  }\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789';\n  let objectId = '';\n  const bytes = randomBytes(size);\n  for (let i = 0; i < bytes.length; ++i) {\n    objectId += chars[bytes.readUInt8(i) % chars.length];\n  }\n  return objectId;\n}\n\n// Returns a new random alphanumeric string suitable for object ID.\nexport function newObjectId(size: number = 10): string {\n  return randomString(size);\n}\n\n// Returns a new random hex string suitable for secure tokens.\nexport function newToken(): string {\n  return randomHexString(32);\n}\n\nexport function md5Hash(string: string): string {\n  return createHash('md5').update(string).digest('hex');\n}\n"],"file":"cryptoUtils.js"}