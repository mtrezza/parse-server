{"version":3,"sources":["../../src/Push/PushQueue.js"],"names":["PUSH_CHANNEL","DEFAULT_BATCH_SIZE","PushQueue","constructor","config","channel","defaultPushChannel","batchSize","parsePublisher","ParseMessageQueue","createPublisher","Parse","applicationId","enqueue","body","where","auth","pushStatus","limit","order","Promise","resolve","then","rest","find","count","results","complete","setRunning","Math","ceil","skip","query","pushWorkItem","objectId","publish","JSON","stringify"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;AAEA,MAAMA,YAAY,GAAG,mBAArB;AACA,MAAMC,kBAAkB,GAAG,GAA3B;;AAEO,MAAMC,SAAN,CAAgB;AAKrB;AACA;AACAC,EAAAA,WAAW,CAACC,MAAW,GAAG,EAAf,EAAmB;AAC5B,SAAKC,OAAL,GAAeD,MAAM,CAACC,OAAP,IAAkBH,SAAS,CAACI,kBAAV,EAAjC;AACA,SAAKC,SAAL,GAAiBH,MAAM,CAACG,SAAP,IAAoBN,kBAArC;AACA,SAAKO,cAAL,GAAsBC,qCAAkBC,eAAlB,CAAkCN,MAAlC,CAAtB;AACD;;AAED,SAAOE,kBAAP,GAA4B;AAC1B,WAAQ,GAAEK,cAAMC,aAAc,IAAGZ,YAAa,EAA9C;AACD;;AAEDa,EAAAA,OAAO,CAACC,IAAD,EAAOC,KAAP,EAAcX,MAAd,EAAsBY,IAAtB,EAA4BC,UAA5B,EAAwC;AAC7C,UAAMC,KAAK,GAAG,KAAKX,SAAnB;AAEAQ,IAAAA,KAAK,GAAG,mCAAuBA,KAAvB,CAAR,CAH6C,CAK7C;;AACA,UAAMI,KAAK,GAAG,UAAd;AACA,WAAOC,OAAO,CAACC,OAAR,GACJC,IADI,CACC,MAAM;AACV,aAAOC,cAAKC,IAAL,CAAUpB,MAAV,EAAkBY,IAAlB,EAAwB,eAAxB,EAAyCD,KAAzC,EAAgD;AACrDG,QAAAA,KAAK,EAAE,CAD8C;AAErDO,QAAAA,KAAK,EAAE;AAF8C,OAAhD,CAAP;AAID,KANI,EAOJH,IAPI,CAOC,CAAC;AAAEI,MAAAA,OAAF;AAAWD,MAAAA;AAAX,KAAD,KAAwB;AAC5B,UAAI,CAACC,OAAD,IAAYD,KAAK,IAAI,CAAzB,EAA4B;AAC1B,eAAOR,UAAU,CAACU,QAAX,EAAP;AACD;;AACDV,MAAAA,UAAU,CAACW,UAAX,CAAsBC,IAAI,CAACC,IAAL,CAAUL,KAAK,GAAGP,KAAlB,CAAtB;AACA,UAAIa,IAAI,GAAG,CAAX;;AACA,aAAOA,IAAI,GAAGN,KAAd,EAAqB;AACnB,cAAMO,KAAK,GAAG;AACZjB,UAAAA,KADY;AAEZG,UAAAA,KAFY;AAGZa,UAAAA,IAHY;AAIZZ,UAAAA;AAJY,SAAd;AAOA,cAAMc,YAAY,GAAG;AACnBnB,UAAAA,IADmB;AAEnBkB,UAAAA,KAFmB;AAGnBf,UAAAA,UAAU,EAAE;AAAEiB,YAAAA,QAAQ,EAAEjB,UAAU,CAACiB;AAAvB,WAHO;AAInBtB,UAAAA,aAAa,EAAER,MAAM,CAACQ;AAJH,SAArB;AAMA,aAAKJ,cAAL,CAAoB2B,OAApB,CAA4B,KAAK9B,OAAjC,EAA0C+B,IAAI,CAACC,SAAL,CAAeJ,YAAf,CAA1C;AACAF,QAAAA,IAAI,IAAIb,KAAR;AACD;AACF,KA9BI,CAAP;AA+BD;;AAvDoB","sourcesContent":["import { ParseMessageQueue } from '../ParseMessageQueue';\nimport rest from '../rest';\nimport { applyDeviceTokenExists } from './utils';\nimport Parse from 'parse/node';\n\nconst PUSH_CHANNEL = 'parse-server-push';\nconst DEFAULT_BATCH_SIZE = 100;\n\nexport class PushQueue {\n  parsePublisher: Object;\n  channel: String;\n  batchSize: Number;\n\n  // config object of the publisher, right now it only contains the redisURL,\n  // but we may extend it later.\n  constructor(config: any = {}) {\n    this.channel = config.channel || PushQueue.defaultPushChannel();\n    this.batchSize = config.batchSize || DEFAULT_BATCH_SIZE;\n    this.parsePublisher = ParseMessageQueue.createPublisher(config);\n  }\n\n  static defaultPushChannel() {\n    return `${Parse.applicationId}-${PUSH_CHANNEL}`;\n  }\n\n  enqueue(body, where, config, auth, pushStatus) {\n    const limit = this.batchSize;\n\n    where = applyDeviceTokenExists(where);\n\n    // Order by objectId so no impact on the DB\n    const order = 'objectId';\n    return Promise.resolve()\n      .then(() => {\n        return rest.find(config, auth, '_Installation', where, {\n          limit: 0,\n          count: true,\n        });\n      })\n      .then(({ results, count }) => {\n        if (!results || count == 0) {\n          return pushStatus.complete();\n        }\n        pushStatus.setRunning(Math.ceil(count / limit));\n        let skip = 0;\n        while (skip < count) {\n          const query = {\n            where,\n            limit,\n            skip,\n            order,\n          };\n\n          const pushWorkItem = {\n            body,\n            query,\n            pushStatus: { objectId: pushStatus.objectId },\n            applicationId: config.applicationId,\n          };\n          this.parsePublisher.publish(this.channel, JSON.stringify(pushWorkItem));\n          skip += limit;\n        }\n      });\n  }\n}\n"],"file":"PushQueue.js"}