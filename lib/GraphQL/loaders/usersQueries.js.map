{"version":3,"sources":["../../../src/GraphQL/loaders/usersQueries.js"],"names":["getUserFromSessionToken","context","queryInfo","keysPrefix","userId","info","config","sessionToken","Parse","Error","INVALID_SESSION_TOKEN","selectedFields","filter","field","startsWith","map","replace","keysAndInclude","keys","include","auth","Auth","isMaster","user","id","options","split","key","join","included","response","rest","find","objectId","clientVersion","results","length","load","parseGraphQLSchema","isUsersClassDisabled","addGraphQLQuery","description","type","GraphQLNonNull","viewerType","resolve","_source","_args","e","handleError"],"mappings":"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","sourcesContent":["import { GraphQLNonNull } from 'graphql';\nimport getFieldNames from 'graphql-list-fields';\nimport Parse from 'parse/node';\nimport rest from '../../rest';\nimport { extractKeysAndInclude } from './parseClassTypes';\nimport { Auth } from '../../Auth';\n\nconst getUserFromSessionToken = async (context, queryInfo, keysPrefix, userId) => {\n  const { info, config } = context;\n  if (!info || !info.sessionToken) {\n    throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');\n  }\n  const sessionToken = info.sessionToken;\n  const selectedFields = getFieldNames(queryInfo)\n    .filter(field => field.startsWith(keysPrefix))\n    .map(field => field.replace(keysPrefix, ''));\n\n  const keysAndInclude = extractKeysAndInclude(selectedFields);\n  const { keys } = keysAndInclude;\n  let { include } = keysAndInclude;\n\n  if (userId && !keys && !include) {\n    return {\n      sessionToken,\n    };\n  } else if (keys && !include) {\n    include = 'user';\n  }\n\n  if (userId) {\n    // We need to re create the auth context\n    // to avoid security breach if userId is provided\n    context.auth = new Auth({\n      config,\n      isMaster: context.auth.isMaster,\n      user: { id: userId },\n    });\n  }\n\n  const options = {};\n  if (keys) {\n    options.keys = keys\n      .split(',')\n      .map(key => `${key}`)\n      .join(',');\n  }\n  if (include) {\n    options.include = include\n      .split(',')\n      .map(included => `${included}`)\n      .join(',');\n  }\n\n  const response = await rest.find(\n    config,\n    context.auth,\n    '_User',\n    // Get the user it self from auth object\n    { objectId: context.auth.user.id },\n    options,\n    info.clientVersion,\n    info.context\n  );\n  if (!response.results || response.results.length == 0) {\n    throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');\n  } else {\n    const user = response.results[0];\n    return {\n      sessionToken,\n      user,\n    };\n  }\n};\n\nconst load = parseGraphQLSchema => {\n  if (parseGraphQLSchema.isUsersClassDisabled) {\n    return;\n  }\n\n  parseGraphQLSchema.addGraphQLQuery(\n    'viewer',\n    {\n      description: 'The viewer query can be used to return the current user data.',\n      type: new GraphQLNonNull(parseGraphQLSchema.viewerType),\n      async resolve(_source, _args, context, queryInfo) {\n        try {\n          return await getUserFromSessionToken(context, queryInfo, 'user.', false);\n        } catch (e) {\n          parseGraphQLSchema.handleError(e);\n        }\n      },\n    },\n    true,\n    true\n  );\n};\n\nexport { load, getUserFromSessionToken };\n"],"file":"usersQueries.js"}