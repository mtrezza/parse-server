{"version":3,"sources":["../../../src/GraphQL/transformers/query.js"],"names":["parseQueryMap","OR","AND","NOR","parseConstraintMap","equalTo","notEqualTo","lessThan","lessThanOrEqualTo","greaterThan","greaterThanOrEqualTo","in","notIn","exists","inQueryKey","notInQueryKey","inQuery","notInQuery","containedBy","contains","matchesRegex","options","text","search","term","language","caseSensitive","diacriticSensitive","nearSphere","maxDistance","maxDistanceInRadians","maxDistanceInMiles","maxDistanceInKilometers","within","box","geoWithin","polygon","centerSphere","geoIntersects","point","transformQueryConstraintInputToParse","constraints","parentFieldName","className","parentConstraints","parseClasses","fields","find","parseClass","Object","keys","forEach","constraintName","constraintValue","globalIdObject","type","id","Array","isArray","map","value","objectId","fieldName","fieldValue","key","targetClass","whereTarget","$exists","parseWhereTarget","where","$inQuery","transformQueryInputToParse","$notInQuery","__type","bottomLeft","upperRight","geoPoint","center","distance","fieldValueItem"],"mappings":"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","sourcesContent":["import { fromGlobalId } from 'graphql-relay';\n\nconst parseQueryMap = {\n  OR: '$or',\n  AND: '$and',\n  NOR: '$nor',\n};\n\nconst parseConstraintMap = {\n  equalTo: '$eq',\n  notEqualTo: '$ne',\n  lessThan: '$lt',\n  lessThanOrEqualTo: '$lte',\n  greaterThan: '$gt',\n  greaterThanOrEqualTo: '$gte',\n  in: '$in',\n  notIn: '$nin',\n  exists: '$exists',\n  inQueryKey: '$select',\n  notInQueryKey: '$dontSelect',\n  inQuery: '$inQuery',\n  notInQuery: '$notInQuery',\n  containedBy: '$containedBy',\n  contains: '$all',\n  matchesRegex: '$regex',\n  options: '$options',\n  text: '$text',\n  search: '$search',\n  term: '$term',\n  language: '$language',\n  caseSensitive: '$caseSensitive',\n  diacriticSensitive: '$diacriticSensitive',\n  nearSphere: '$nearSphere',\n  maxDistance: '$maxDistance',\n  maxDistanceInRadians: '$maxDistanceInRadians',\n  maxDistanceInMiles: '$maxDistanceInMiles',\n  maxDistanceInKilometers: '$maxDistanceInKilometers',\n  within: '$within',\n  box: '$box',\n  geoWithin: '$geoWithin',\n  polygon: '$polygon',\n  centerSphere: '$centerSphere',\n  geoIntersects: '$geoIntersects',\n  point: '$point',\n};\n\nconst transformQueryConstraintInputToParse = (\n  constraints,\n  parentFieldName,\n  className,\n  parentConstraints,\n  parseClasses\n) => {\n  const fields = parseClasses.find(parseClass => parseClass.className === className).fields;\n  if (parentFieldName === 'id' && className) {\n    Object.keys(constraints).forEach(constraintName => {\n      const constraintValue = constraints[constraintName];\n      if (typeof constraintValue === 'string') {\n        const globalIdObject = fromGlobalId(constraintValue);\n\n        if (globalIdObject.type === className) {\n          constraints[constraintName] = globalIdObject.id;\n        }\n      } else if (Array.isArray(constraintValue)) {\n        constraints[constraintName] = constraintValue.map(value => {\n          const globalIdObject = fromGlobalId(value);\n\n          if (globalIdObject.type === className) {\n            return globalIdObject.id;\n          }\n\n          return value;\n        });\n      }\n    });\n    parentConstraints.objectId = constraints;\n    delete parentConstraints.id;\n  }\n  Object.keys(constraints).forEach(fieldName => {\n    let fieldValue = constraints[fieldName];\n    if (parseConstraintMap[fieldName]) {\n      constraints[parseConstraintMap[fieldName]] = constraints[fieldName];\n      delete constraints[fieldName];\n    }\n    /**\n     * If we have a key-value pair, we need to change the way the constraint is structured.\n     *\n     * Example:\n     *   From:\n     *   {\n     *     \"someField\": {\n     *       \"lessThan\": {\n     *         \"key\":\"foo.bar\",\n     *         \"value\": 100\n     *       },\n     *       \"greaterThan\": {\n     *         \"key\":\"foo.bar\",\n     *         \"value\": 10\n     *       }\n     *     }\n     *   }\n     *\n     *   To:\n     *   {\n     *     \"someField.foo.bar\": {\n     *       \"$lt\": 100,\n     *       \"$gt\": 10\n     *      }\n     *   }\n     */\n    if (fieldValue.key && fieldValue.value && parentConstraints && parentFieldName) {\n      delete parentConstraints[parentFieldName];\n      parentConstraints[`${parentFieldName}.${fieldValue.key}`] = {\n        ...parentConstraints[`${parentFieldName}.${fieldValue.key}`],\n        [parseConstraintMap[fieldName]]: fieldValue.value,\n      };\n    } else if (\n      fields[parentFieldName] &&\n      (fields[parentFieldName].type === 'Pointer' || fields[parentFieldName].type === 'Relation')\n    ) {\n      const { targetClass } = fields[parentFieldName];\n      if (fieldName === 'exists') {\n        if (fields[parentFieldName].type === 'Relation') {\n          const whereTarget = fieldValue ? 'where' : 'notWhere';\n          if (constraints[whereTarget]) {\n            if (constraints[whereTarget].objectId) {\n              constraints[whereTarget].objectId = {\n                ...constraints[whereTarget].objectId,\n                $exists: fieldValue,\n              };\n            } else {\n              constraints[whereTarget].objectId = {\n                $exists: fieldValue,\n              };\n            }\n          } else {\n            const parseWhereTarget = fieldValue ? '$inQuery' : '$notInQuery';\n            parentConstraints[parentFieldName][parseWhereTarget] = {\n              where: { objectId: { $exists: true } },\n              className: targetClass,\n            };\n          }\n          delete constraints.$exists;\n        } else {\n          parentConstraints[parentFieldName].$exists = fieldValue;\n        }\n        return;\n      }\n      switch (fieldName) {\n        case 'have':\n          parentConstraints[parentFieldName].$inQuery = {\n            where: fieldValue,\n            className: targetClass,\n          };\n          transformQueryInputToParse(\n            parentConstraints[parentFieldName].$inQuery.where,\n            targetClass,\n            parseClasses\n          );\n          break;\n        case 'haveNot':\n          parentConstraints[parentFieldName].$notInQuery = {\n            where: fieldValue,\n            className: targetClass,\n          };\n          transformQueryInputToParse(\n            parentConstraints[parentFieldName].$notInQuery.where,\n            targetClass,\n            parseClasses\n          );\n          break;\n      }\n      delete constraints[fieldName];\n      return;\n    }\n    switch (fieldName) {\n      case 'point':\n        if (typeof fieldValue === 'object' && !fieldValue.__type) {\n          fieldValue.__type = 'GeoPoint';\n        }\n        break;\n      case 'nearSphere':\n        if (typeof fieldValue === 'object' && !fieldValue.__type) {\n          fieldValue.__type = 'GeoPoint';\n        }\n        break;\n      case 'box':\n        if (typeof fieldValue === 'object' && fieldValue.bottomLeft && fieldValue.upperRight) {\n          fieldValue = [\n            {\n              __type: 'GeoPoint',\n              ...fieldValue.bottomLeft,\n            },\n            {\n              __type: 'GeoPoint',\n              ...fieldValue.upperRight,\n            },\n          ];\n          constraints[parseConstraintMap[fieldName]] = fieldValue;\n        }\n        break;\n      case 'polygon':\n        if (fieldValue instanceof Array) {\n          fieldValue.forEach(geoPoint => {\n            if (typeof geoPoint === 'object' && !geoPoint.__type) {\n              geoPoint.__type = 'GeoPoint';\n            }\n          });\n        }\n        break;\n      case 'centerSphere':\n        if (typeof fieldValue === 'object' && fieldValue.center && fieldValue.distance) {\n          fieldValue = [\n            {\n              __type: 'GeoPoint',\n              ...fieldValue.center,\n            },\n            fieldValue.distance,\n          ];\n          constraints[parseConstraintMap[fieldName]] = fieldValue;\n        }\n        break;\n    }\n    if (typeof fieldValue === 'object') {\n      if (fieldName === 'where') {\n        transformQueryInputToParse(fieldValue, className, parseClasses);\n      } else {\n        transformQueryConstraintInputToParse(\n          fieldValue,\n          fieldName,\n          className,\n          constraints,\n          parseClasses\n        );\n      }\n    }\n  });\n};\n\nconst transformQueryInputToParse = (constraints, className, parseClasses) => {\n  if (!constraints || typeof constraints !== 'object') {\n    return;\n  }\n\n  Object.keys(constraints).forEach(fieldName => {\n    const fieldValue = constraints[fieldName];\n\n    if (parseQueryMap[fieldName]) {\n      delete constraints[fieldName];\n      fieldName = parseQueryMap[fieldName];\n      constraints[fieldName] = fieldValue;\n      fieldValue.forEach(fieldValueItem => {\n        transformQueryInputToParse(fieldValueItem, className, parseClasses);\n      });\n      return;\n    } else {\n      transformQueryConstraintInputToParse(\n        fieldValue,\n        fieldName,\n        className,\n        constraints,\n        parseClasses\n      );\n    }\n  });\n};\n\nexport { transformQueryConstraintInputToParse, transformQueryInputToParse };\n"],"file":"query.js"}