"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AdaptableController = void 0;

var _Config = _interopRequireDefault(require("../Config"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
AdaptableController.js

AdaptableController is the base class for all controllers
that support adapter,
The super class takes care of creating the right instance for the adapter
based on the parameters passed

 */
// _adapter is private, use Symbol
var _adapter = Symbol();

class AdaptableController {
  constructor(adapter, appId, options) {
    this.options = options;
    this.appId = appId;
    this.adapter = adapter;
  }

  set adapter(adapter) {
    this.validateAdapter(adapter);
    this[_adapter] = adapter;
  }

  get adapter() {
    return this[_adapter];
  }

  get config() {
    return _Config.default.get(this.appId);
  }

  expectedAdapterType() {
    throw new Error('Subclasses should implement expectedAdapterType()');
  }

  validateAdapter(adapter) {
    AdaptableController.validateAdapter(adapter, this);
  }

  static validateAdapter(adapter, self, ExpectedType) {
    if (!adapter) {
      throw new Error(this.constructor.name + ' requires an adapter');
    }

    const Type = ExpectedType || self.expectedAdapterType(); // Allow skipping for testing

    if (!Type) {
      return;
    } // Makes sure the prototype matches


    const mismatches = Object.getOwnPropertyNames(Type.prototype).reduce((obj, key) => {
      const adapterType = typeof adapter[key];
      const expectedType = typeof Type.prototype[key];

      if (adapterType !== expectedType) {
        obj[key] = {
          expected: expectedType,
          actual: adapterType
        };
      }

      return obj;
    }, {});

    if (Object.keys(mismatches).length > 0) {
      throw new Error("Adapter prototype don't match expected prototype", adapter, mismatches);
    }
  }

}

exports.AdaptableController = AdaptableController;
var _default = AdaptableController;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9Db250cm9sbGVycy9BZGFwdGFibGVDb250cm9sbGVyLmpzIl0sIm5hbWVzIjpbIl9hZGFwdGVyIiwiU3ltYm9sIiwiQWRhcHRhYmxlQ29udHJvbGxlciIsImNvbnN0cnVjdG9yIiwiYWRhcHRlciIsImFwcElkIiwib3B0aW9ucyIsInZhbGlkYXRlQWRhcHRlciIsImNvbmZpZyIsIkNvbmZpZyIsImdldCIsImV4cGVjdGVkQWRhcHRlclR5cGUiLCJFcnJvciIsInNlbGYiLCJFeHBlY3RlZFR5cGUiLCJuYW1lIiwiVHlwZSIsIm1pc21hdGNoZXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicHJvdG90eXBlIiwicmVkdWNlIiwib2JqIiwia2V5IiwiYWRhcHRlclR5cGUiLCJleHBlY3RlZFR5cGUiLCJleHBlY3RlZCIsImFjdHVhbCIsImtleXMiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFZQTs7OztBQVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EsSUFBSUEsUUFBUSxHQUFHQyxNQUFNLEVBQXJCOztBQUdPLE1BQU1DLG1CQUFOLENBQTBCO0FBQy9CQyxFQUFBQSxXQUFXLENBQUNDLE9BQUQsRUFBVUMsS0FBVixFQUFpQkMsT0FBakIsRUFBMEI7QUFDbkMsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS0QsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS0QsT0FBTCxHQUFlQSxPQUFmO0FBQ0Q7O0FBRVUsTUFBUEEsT0FBTyxDQUFDQSxPQUFELEVBQVU7QUFDbkIsU0FBS0csZUFBTCxDQUFxQkgsT0FBckI7QUFDQSxTQUFLSixRQUFMLElBQWlCSSxPQUFqQjtBQUNEOztBQUVVLE1BQVBBLE9BQU8sR0FBRztBQUNaLFdBQU8sS0FBS0osUUFBTCxDQUFQO0FBQ0Q7O0FBRVMsTUFBTlEsTUFBTSxHQUFHO0FBQ1gsV0FBT0MsZ0JBQU9DLEdBQVAsQ0FBVyxLQUFLTCxLQUFoQixDQUFQO0FBQ0Q7O0FBRURNLEVBQUFBLG1CQUFtQixHQUFHO0FBQ3BCLFVBQU0sSUFBSUMsS0FBSixDQUFVLG1EQUFWLENBQU47QUFDRDs7QUFFREwsRUFBQUEsZUFBZSxDQUFDSCxPQUFELEVBQVU7QUFDdkJGLElBQUFBLG1CQUFtQixDQUFDSyxlQUFwQixDQUFvQ0gsT0FBcEMsRUFBNkMsSUFBN0M7QUFDRDs7QUFFcUIsU0FBZkcsZUFBZSxDQUFDSCxPQUFELEVBQVVTLElBQVYsRUFBZ0JDLFlBQWhCLEVBQThCO0FBQ2xELFFBQUksQ0FBQ1YsT0FBTCxFQUFjO0FBQ1osWUFBTSxJQUFJUSxLQUFKLENBQVUsS0FBS1QsV0FBTCxDQUFpQlksSUFBakIsR0FBd0Isc0JBQWxDLENBQU47QUFDRDs7QUFFRCxVQUFNQyxJQUFJLEdBQUdGLFlBQVksSUFBSUQsSUFBSSxDQUFDRixtQkFBTCxFQUE3QixDQUxrRCxDQU1sRDs7QUFDQSxRQUFJLENBQUNLLElBQUwsRUFBVztBQUNUO0FBQ0QsS0FUaUQsQ0FXbEQ7OztBQUNBLFVBQU1DLFVBQVUsR0FBR0MsTUFBTSxDQUFDQyxtQkFBUCxDQUEyQkgsSUFBSSxDQUFDSSxTQUFoQyxFQUEyQ0MsTUFBM0MsQ0FBa0QsQ0FBQ0MsR0FBRCxFQUFNQyxHQUFOLEtBQWM7QUFDakYsWUFBTUMsV0FBVyxHQUFHLE9BQU9wQixPQUFPLENBQUNtQixHQUFELENBQWxDO0FBQ0EsWUFBTUUsWUFBWSxHQUFHLE9BQU9ULElBQUksQ0FBQ0ksU0FBTCxDQUFlRyxHQUFmLENBQTVCOztBQUNBLFVBQUlDLFdBQVcsS0FBS0MsWUFBcEIsRUFBa0M7QUFDaENILFFBQUFBLEdBQUcsQ0FBQ0MsR0FBRCxDQUFILEdBQVc7QUFDVEcsVUFBQUEsUUFBUSxFQUFFRCxZQUREO0FBRVRFLFVBQUFBLE1BQU0sRUFBRUg7QUFGQyxTQUFYO0FBSUQ7O0FBQ0QsYUFBT0YsR0FBUDtBQUNELEtBVmtCLEVBVWhCLEVBVmdCLENBQW5COztBQVlBLFFBQUlKLE1BQU0sQ0FBQ1UsSUFBUCxDQUFZWCxVQUFaLEVBQXdCWSxNQUF4QixHQUFpQyxDQUFyQyxFQUF3QztBQUN0QyxZQUFNLElBQUlqQixLQUFKLENBQVUsa0RBQVYsRUFBOERSLE9BQTlELEVBQXVFYSxVQUF2RSxDQUFOO0FBQ0Q7QUFDRjs7QUF2RDhCOzs7ZUEwRGxCZixtQiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5BZGFwdGFibGVDb250cm9sbGVyLmpzXG5cbkFkYXB0YWJsZUNvbnRyb2xsZXIgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBjb250cm9sbGVyc1xudGhhdCBzdXBwb3J0IGFkYXB0ZXIsXG5UaGUgc3VwZXIgY2xhc3MgdGFrZXMgY2FyZSBvZiBjcmVhdGluZyB0aGUgcmlnaHQgaW5zdGFuY2UgZm9yIHRoZSBhZGFwdGVyXG5iYXNlZCBvbiB0aGUgcGFyYW1ldGVycyBwYXNzZWRcblxuICovXG5cbi8vIF9hZGFwdGVyIGlzIHByaXZhdGUsIHVzZSBTeW1ib2xcbnZhciBfYWRhcHRlciA9IFN5bWJvbCgpO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuLi9Db25maWcnO1xuXG5leHBvcnQgY2xhc3MgQWRhcHRhYmxlQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIGFwcElkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmFwcElkID0gYXBwSWQ7XG4gICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcbiAgfVxuXG4gIHNldCBhZGFwdGVyKGFkYXB0ZXIpIHtcbiAgICB0aGlzLnZhbGlkYXRlQWRhcHRlcihhZGFwdGVyKTtcbiAgICB0aGlzW19hZGFwdGVyXSA9IGFkYXB0ZXI7XG4gIH1cblxuICBnZXQgYWRhcHRlcigpIHtcbiAgICByZXR1cm4gdGhpc1tfYWRhcHRlcl07XG4gIH1cblxuICBnZXQgY29uZmlnKCkge1xuICAgIHJldHVybiBDb25maWcuZ2V0KHRoaXMuYXBwSWQpO1xuICB9XG5cbiAgZXhwZWN0ZWRBZGFwdGVyVHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudCBleHBlY3RlZEFkYXB0ZXJUeXBlKCknKTtcbiAgfVxuXG4gIHZhbGlkYXRlQWRhcHRlcihhZGFwdGVyKSB7XG4gICAgQWRhcHRhYmxlQ29udHJvbGxlci52YWxpZGF0ZUFkYXB0ZXIoYWRhcHRlciwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgdmFsaWRhdGVBZGFwdGVyKGFkYXB0ZXIsIHNlbGYsIEV4cGVjdGVkVHlwZSkge1xuICAgIGlmICghYWRhcHRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgcmVxdWlyZXMgYW4gYWRhcHRlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IFR5cGUgPSBFeHBlY3RlZFR5cGUgfHwgc2VsZi5leHBlY3RlZEFkYXB0ZXJUeXBlKCk7XG4gICAgLy8gQWxsb3cgc2tpcHBpbmcgZm9yIHRlc3RpbmdcbiAgICBpZiAoIVR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlcyBzdXJlIHRoZSBwcm90b3R5cGUgbWF0Y2hlc1xuICAgIGNvbnN0IG1pc21hdGNoZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhUeXBlLnByb3RvdHlwZSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgY29uc3QgYWRhcHRlclR5cGUgPSB0eXBlb2YgYWRhcHRlcltrZXldO1xuICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gdHlwZW9mIFR5cGUucHJvdG90eXBlW2tleV07XG4gICAgICBpZiAoYWRhcHRlclR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICBvYmpba2V5XSA9IHtcbiAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRUeXBlLFxuICAgICAgICAgIGFjdHVhbDogYWRhcHRlclR5cGUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhtaXNtYXRjaGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGFwdGVyIHByb3RvdHlwZSBkb24ndCBtYXRjaCBleHBlY3RlZCBwcm90b3R5cGVcIiwgYWRhcHRlciwgbWlzbWF0Y2hlcyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFkYXB0YWJsZUNvbnRyb2xsZXI7XG4iXX0=