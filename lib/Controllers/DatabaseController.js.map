{"version":3,"sources":["../../src/Controllers/DatabaseController.js"],"names":["addWriteACL","query","acl","newQuery","_","cloneDeep","_wperm","$in","addReadACL","_rperm","transformObjectACL","ACL","result","entry","read","push","write","specialQuerykeys","isSpecialQueryKey","key","indexOf","validateQuery","Parse","Error","INVALID_QUERY","$or","Array","forEach","$and","$nor","length","Object","keys","$regex","$options","match","INVALID_KEY_NAME","filterSensitiveData","isMaster","aclGroup","auth","operation","schema","className","protectedFields","object","userId","user","id","perms","getClassLevelPermissions","isReadOperation","protectedFieldsPointerPerm","filter","startsWith","map","substring","value","newProtectedFields","overrideProtectedFields","pointerPerm","pointerPermIncludesUser","readUserFieldValue","isArray","some","objectId","fields","v","includes","isUserClass","k","temporaryKeys","password","_hashed_password","sessionToken","_email_verify_token","_perishable_token","_perishable_token_expires_at","_tombstone","_email_verify_token_expires_at","_failed_login_count","_account_lockout_expires_at","_password_changed_at","_password_history","authData","specialKeysForUpdate","isSpecialUpdateKey","expandResultOnKeyPath","path","split","firstKey","nextPath","slice","join","sanitizeDatabaseResult","originalObject","response","Promise","resolve","keyUpdate","__op","joinTableName","flattenUpdateOperatorsForCreate","amount","INVALID_JSON","objects","COMMAND_UNAVAILABLE","transformAuthData","provider","providerData","fieldName","type","untransformObjectACL","output","getRootFieldName","relationSchema","relatedId","owningId","DatabaseController","constructor","adapter","schemaCache","schemaPromise","_transactionalSession","collectionExists","classExists","purgeCollection","loadSchema","then","schemaController","getOneSchema","deleteObjectsByQuery","validateClassName","SchemaController","classNameIsValid","reject","INVALID_CLASS_NAME","options","clearCache","load","loadSchemaIfNeeded","redirectClassNameForKey","t","getExpectedType","targetClass","validateObject","runOptions","undefined","s","canAddField","update","many","upsert","addsField","skipSanitization","validateOnly","validSchemaController","originalQuery","originalUpdate","relationUpdates","validatePermission","collectRelationUpdates","addPointerPermissions","catch","error","rootFieldName","fieldNameIsValid","updateOperation","innerKey","INVALID_NESTED_KEY","find","OBJECT_NOT_FOUND","updateObjectsByQuery","upsertOneObject","findOneAndUpdate","handleRelationUpdates","ops","deleteMe","process","op","x","pending","addRelation","removeRelation","all","fromClassName","fromId","toId","doc","code","destroy","parseFormatSchema","create","createdAt","iso","__type","updatedAt","enforceClassExists","createObject","convertSchemaToAdapterSchema","classSchema","schemaData","schemaFields","newKeys","field","action","deleteEverything","fast","deleteAllClasses","clear","relatedIds","queryOptions","skip","limit","sort","findOptions","canSortOnJoinTables","_id","results","owningIds","reduceInRelation","ors","aQuery","index","promises","queries","constraintKey","isNegation","r","q","ids","addNotInObjectIdsIds","addInObjectIdsIds","reduceRelationKeys","relatedTo","idsFromString","idsFromEq","idsFromIn","allIds","list","totalLength","reduce","memo","idsIntersection","intersect","big","$eq","idsFromNin","Set","$nin","count","distinct","pipeline","readPreference","hint","caseInsensitive","explain","_created_at","_updated_at","addProtectedFields","aggregate","INTERNAL_SERVER_ERROR","deleteSchema","deleteClass","wasParseCollection","relationFieldNames","name","objectToEntriesStrings","entries","a","JSON","stringify","reduceOrOperation","repeat","i","j","shorter","longer","foundEntries","acc","shorterEntries","splice","reduceAndOperation","testPermissionsForClassName","userACL","groupKey","permFields","pointerFields","userPointer","fieldDescriptor","fieldType","prototype","hasOwnProperty","call","queryClause","$all","assign","preserveKeys","serverOnlyKeys","authenticated","roles","userRoles","protectedKeysSets","protectedKeys","next","createTransactionalSession","transactionalSession","commitTransactionalSession","abortTransactionalSession","performInitialization","requiredUserFields","defaultColumns","_Default","_User","requiredRoleFields","_Role","requiredIdempotencyFields","_Idempotency","userClassPromise","roleClassPromise","idempotencyClassPromise","MongoStorageAdapter","usernameUniqueness","ensureUniqueness","logger","warn","usernameCaseInsensitiveIndex","ensureIndex","emailUniqueness","emailCaseInsensitiveIndex","roleUniqueness","idempotencyRequestIdIndex","idempotencyExpireIndex","ttl","indexPromise","updateSchemaWithIndexes","adapterInit","VolatileClassesSchemas","module","exports","_validateQuery"],"mappings":"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","sourcesContent":["// @flow\n// A database adapter that works with data exported from the hosted\n// Parse database.\n\n// @flow-disable-next\nimport { Parse } from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\n// @flow-disable-next\nimport intersect from 'intersect';\n// @flow-disable-next\nimport deepcopy from 'deepcopy';\nimport logger from '../logger';\nimport * as SchemaController from './SchemaController';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport type { QueryOptions, FullQueryOptions } from '../Adapters/Storage/StorageAdapter';\n\nfunction addWriteACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_wperm' query, we don't allow client queries on that, no need to $and\n  newQuery._wperm = { $in: [null, ...acl] };\n  return newQuery;\n}\n\nfunction addReadACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_rperm' query, we don't allow client queries on that, no need to $and\n  newQuery._rperm = { $in: [null, '*', ...acl] };\n  return newQuery;\n}\n\n// Transforms a REST API formatted ACL object to our two-field mongo format.\nconst transformObjectACL = ({ ACL, ...result }) => {\n  if (!ACL) {\n    return result;\n  }\n\n  result._wperm = [];\n  result._rperm = [];\n\n  for (const entry in ACL) {\n    if (ACL[entry].read) {\n      result._rperm.push(entry);\n    }\n    if (ACL[entry].write) {\n      result._wperm.push(entry);\n    }\n  }\n  return result;\n};\n\nconst specialQuerykeys = [\n  '$and',\n  '$or',\n  '$nor',\n  '_rperm',\n  '_wperm',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n];\n\nconst isSpecialQueryKey = key => {\n  return specialQuerykeys.indexOf(key) >= 0;\n};\n\nconst validateQuery = (query: any): void => {\n  if (query.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Cannot query on ACL.');\n  }\n\n  if (query.$or) {\n    if (query.$or instanceof Array) {\n      query.$or.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $or format - use an array value.');\n    }\n  }\n\n  if (query.$and) {\n    if (query.$and instanceof Array) {\n      query.$and.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $and format - use an array value.');\n    }\n  }\n\n  if (query.$nor) {\n    if (query.$nor instanceof Array && query.$nor.length > 0) {\n      query.$nor.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(\n        Parse.Error.INVALID_QUERY,\n        'Bad $nor format - use an array of at least 1 value.'\n      );\n    }\n  }\n\n  Object.keys(query).forEach(key => {\n    if (query && query[key] && query[key].$regex) {\n      if (typeof query[key].$options === 'string') {\n        if (!query[key].$options.match(/^[imxs]+$/)) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_QUERY,\n            `Bad $options value for query: ${query[key].$options}`\n          );\n        }\n      }\n    }\n    if (!isSpecialQueryKey(key) && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n};\n\n// Filters out any data that shouldn't be on this REST-formatted object.\nconst filterSensitiveData = (\n  isMaster: boolean,\n  aclGroup: any[],\n  auth: any,\n  operation: any,\n  schema: SchemaController.SchemaController,\n  className: string,\n  protectedFields: null | Array<any>,\n  object: any\n) => {\n  let userId = null;\n  if (auth && auth.user) userId = auth.user.id;\n\n  // replace protectedFields when using pointer-permissions\n  const perms = schema.getClassLevelPermissions(className);\n  if (perms) {\n    const isReadOperation = ['get', 'find'].indexOf(operation) > -1;\n\n    if (isReadOperation && perms.protectedFields) {\n      // extract protectedFields added with the pointer-permission prefix\n      const protectedFieldsPointerPerm = Object.keys(perms.protectedFields)\n        .filter(key => key.startsWith('userField:'))\n        .map(key => {\n          return { key: key.substring(10), value: perms.protectedFields[key] };\n        });\n\n      const newProtectedFields: Array<string>[] = [];\n      let overrideProtectedFields = false;\n\n      // check if the object grants the current user access based on the extracted fields\n      protectedFieldsPointerPerm.forEach(pointerPerm => {\n        let pointerPermIncludesUser = false;\n        const readUserFieldValue = object[pointerPerm.key];\n        if (readUserFieldValue) {\n          if (Array.isArray(readUserFieldValue)) {\n            pointerPermIncludesUser = readUserFieldValue.some(\n              user => user.objectId && user.objectId === userId\n            );\n          } else {\n            pointerPermIncludesUser =\n              readUserFieldValue.objectId && readUserFieldValue.objectId === userId;\n          }\n        }\n\n        if (pointerPermIncludesUser) {\n          overrideProtectedFields = true;\n          newProtectedFields.push(pointerPerm.value);\n        }\n      });\n\n      // if at least one pointer-permission affected the current user\n      // intersect vs protectedFields from previous stage (@see addProtectedFields)\n      // Sets theory (intersections): A x (B x C) == (A x B) x C\n      if (overrideProtectedFields && protectedFields) {\n        newProtectedFields.push(protectedFields);\n      }\n      // intersect all sets of protectedFields\n      newProtectedFields.forEach(fields => {\n        if (fields) {\n          // if there're no protctedFields by other criteria ( id / role / auth)\n          // then we must intersect each set (per userField)\n          if (!protectedFields) {\n            protectedFields = fields;\n          } else {\n            protectedFields = protectedFields.filter(v => fields.includes(v));\n          }\n        }\n      });\n    }\n  }\n\n  const isUserClass = className === '_User';\n\n  /* special treat for the user class: don't filter protectedFields if currently loggedin user is\n  the retrieved user */\n  if (!(isUserClass && userId && object.objectId === userId)) {\n    protectedFields && protectedFields.forEach(k => delete object[k]);\n\n    // fields not requested by client (excluded),\n    //but were needed to apply protecttedFields\n    perms.protectedFields &&\n      perms.protectedFields.temporaryKeys &&\n      perms.protectedFields.temporaryKeys.forEach(k => delete object[k]);\n  }\n\n  if (!isUserClass) {\n    return object;\n  }\n\n  object.password = object._hashed_password;\n  delete object._hashed_password;\n\n  delete object.sessionToken;\n\n  if (isMaster) {\n    return object;\n  }\n  delete object._email_verify_token;\n  delete object._perishable_token;\n  delete object._perishable_token_expires_at;\n  delete object._tombstone;\n  delete object._email_verify_token_expires_at;\n  delete object._failed_login_count;\n  delete object._account_lockout_expires_at;\n  delete object._password_changed_at;\n  delete object._password_history;\n\n  if (aclGroup.indexOf(object.objectId) > -1) {\n    return object;\n  }\n  delete object.authData;\n  return object;\n};\n\nimport type { LoadSchemaOptions } from './types';\nimport MongoStorageAdapter from '../Adapters/Storage/Mongo/MongoStorageAdapter';\n\n// Runs an update on the database.\n// Returns a promise for an object with the new values for field\n// modifications that don't know their results ahead of time, like\n// 'increment'.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nconst specialKeysForUpdate = [\n  '_hashed_password',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n  '_perishable_token_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst isSpecialUpdateKey = key => {\n  return specialKeysForUpdate.indexOf(key) >= 0;\n};\n\nfunction expandResultOnKeyPath(object, key, value) {\n  if (key.indexOf('.') < 0) {\n    object[key] = value[key];\n    return object;\n  }\n  const path = key.split('.');\n  const firstKey = path[0];\n  const nextPath = path.slice(1).join('.');\n  object[firstKey] = expandResultOnKeyPath(object[firstKey] || {}, nextPath, value[firstKey]);\n  delete object[key];\n  return object;\n}\n\nfunction sanitizeDatabaseResult(originalObject, result): Promise<any> {\n  const response = {};\n  if (!result) {\n    return Promise.resolve(response);\n  }\n  Object.keys(originalObject).forEach(key => {\n    const keyUpdate = originalObject[key];\n    // determine if that was an op\n    if (\n      keyUpdate &&\n      typeof keyUpdate === 'object' &&\n      keyUpdate.__op &&\n      ['Add', 'AddUnique', 'Remove', 'Increment'].indexOf(keyUpdate.__op) > -1\n    ) {\n      // only valid ops that produce an actionable result\n      // the op may have happend on a keypath\n      expandResultOnKeyPath(response, key, result);\n    }\n  });\n  return Promise.resolve(response);\n}\n\nfunction joinTableName(className, key) {\n  return `_Join:${key}:${className}`;\n}\n\nconst flattenUpdateOperatorsForCreate = object => {\n  for (const key in object) {\n    if (object[key] && object[key].__op) {\n      switch (object[key].__op) {\n        case 'Increment':\n          if (typeof object[key].amount !== 'number') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].amount;\n          break;\n        case 'Add':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'AddUnique':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'Remove':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = [];\n          break;\n        case 'Delete':\n          delete object[key];\n          break;\n        default:\n          throw new Parse.Error(\n            Parse.Error.COMMAND_UNAVAILABLE,\n            `The ${object[key].__op} operator is not supported yet.`\n          );\n      }\n    }\n  }\n};\n\nconst transformAuthData = (className, object, schema) => {\n  if (object.authData && className === '_User') {\n    Object.keys(object.authData).forEach(provider => {\n      const providerData = object.authData[provider];\n      const fieldName = `_auth_data_${provider}`;\n      if (providerData == null) {\n        object[fieldName] = {\n          __op: 'Delete',\n        };\n      } else {\n        object[fieldName] = providerData;\n        schema.fields[fieldName] = { type: 'Object' };\n      }\n    });\n    delete object.authData;\n  }\n};\n// Transforms a Database format ACL to a REST API format ACL\nconst untransformObjectACL = ({ _rperm, _wperm, ...output }) => {\n  if (_rperm || _wperm) {\n    output.ACL = {};\n\n    (_rperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { read: true };\n      } else {\n        output.ACL[entry]['read'] = true;\n      }\n    });\n\n    (_wperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { write: true };\n      } else {\n        output.ACL[entry]['write'] = true;\n      }\n    });\n  }\n  return output;\n};\n\n/**\n * When querying, the fieldName may be compound, extract the root fieldName\n *     `temperature.celsius` becomes `temperature`\n * @param {string} fieldName that may be a compound field name\n * @returns {string} the root name of the field\n */\nconst getRootFieldName = (fieldName: string): string => {\n  return fieldName.split('.')[0];\n};\n\nconst relationSchema = {\n  fields: { relatedId: { type: 'String' }, owningId: { type: 'String' } },\n};\n\nclass DatabaseController {\n  adapter: StorageAdapter;\n  schemaCache: any;\n  schemaPromise: ?Promise<SchemaController.SchemaController>;\n  _transactionalSession: ?any;\n\n  constructor(adapter: StorageAdapter, schemaCache: any) {\n    this.adapter = adapter;\n    this.schemaCache = schemaCache;\n    // We don't want a mutable this.schema, because then you could have\n    // one request that uses different schemas for different parts of\n    // it. Instead, use loadSchema to get a schema.\n    this.schemaPromise = null;\n    this._transactionalSession = null;\n  }\n\n  collectionExists(className: string): Promise<boolean> {\n    return this.adapter.classExists(className);\n  }\n\n  purgeCollection(className: string): Promise<void> {\n    return this.loadSchema()\n      .then(schemaController => schemaController.getOneSchema(className))\n      .then(schema => this.adapter.deleteObjectsByQuery(className, schema, {}));\n  }\n\n  validateClassName(className: string): Promise<void> {\n    if (!SchemaController.classNameIsValid(className)) {\n      return Promise.reject(\n        new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'invalid className: ' + className)\n      );\n    }\n    return Promise.resolve();\n  }\n\n  // Returns a promise for a schemaController.\n  loadSchema(\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    if (this.schemaPromise != null) {\n      return this.schemaPromise;\n    }\n    this.schemaPromise = SchemaController.load(this.adapter, this.schemaCache, options);\n    this.schemaPromise.then(\n      () => delete this.schemaPromise,\n      () => delete this.schemaPromise\n    );\n    return this.loadSchema(options);\n  }\n\n  loadSchemaIfNeeded(\n    schemaController: SchemaController.SchemaController,\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    return schemaController ? Promise.resolve(schemaController) : this.loadSchema(options);\n  }\n\n  // Returns a promise for the classname that is related to the given\n  // classname through the key.\n  // TODO: make this not in the DatabaseController interface\n  redirectClassNameForKey(className: string, key: string): Promise<?string> {\n    return this.loadSchema().then(schema => {\n      var t = schema.getExpectedType(className, key);\n      if (t != null && typeof t !== 'string' && t.type === 'Relation') {\n        return t.targetClass;\n      }\n      return className;\n    });\n  }\n\n  // Uses the schema to validate the object (REST API format).\n  // Returns a promise that resolves to the new schema.\n  // This does not update this.schema, because in a situation like a\n  // batch request, that could confuse other users of the schema.\n  validateObject(\n    className: string,\n    object: any,\n    query: any,\n    runOptions: QueryOptions\n  ): Promise<boolean> {\n    let schema;\n    const acl = runOptions.acl;\n    const isMaster = acl === undefined;\n    var aclGroup: string[] = acl || [];\n    return this.loadSchema()\n      .then(s => {\n        schema = s;\n        if (isMaster) {\n          return Promise.resolve();\n        }\n        return this.canAddField(schema, className, object, aclGroup, runOptions);\n      })\n      .then(() => {\n        return schema.validateObject(className, object, query);\n      });\n  }\n\n  update(\n    className: string,\n    query: any,\n    update: any,\n    { acl, many, upsert, addsField }: FullQueryOptions = {},\n    skipSanitization: boolean = false,\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const originalQuery = query;\n    const originalUpdate = update;\n    // Make a copy of the object, so we don't mutate the incoming data.\n    update = deepcopy(update);\n    var relationUpdates = [];\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'update')\n      )\n        .then(() => {\n          relationUpdates = this.collectRelationUpdates(className, originalQuery.objectId, update);\n          if (!isMaster) {\n            query = this.addPointerPermissions(\n              schemaController,\n              className,\n              'update',\n              query,\n              aclGroup\n            );\n\n            if (addsField) {\n              query = {\n                $and: [\n                  query,\n                  this.addPointerPermissions(\n                    schemaController,\n                    className,\n                    'addField',\n                    query,\n                    aclGroup\n                  ),\n                ],\n              };\n            }\n          }\n          if (!query) {\n            return Promise.resolve();\n          }\n          if (acl) {\n            query = addWriteACL(query, acl);\n          }\n          validateQuery(query);\n          return schemaController\n            .getOneSchema(className, true)\n            .catch(error => {\n              // If the schema doesn't exist, pretend it exists with no fields. This behavior\n              // will likely need revisiting.\n              if (error === undefined) {\n                return { fields: {} };\n              }\n              throw error;\n            })\n            .then(schema => {\n              Object.keys(update).forEach(fieldName => {\n                if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n                const rootFieldName = getRootFieldName(fieldName);\n                if (\n                  !SchemaController.fieldNameIsValid(rootFieldName, className) &&\n                  !isSpecialUpdateKey(rootFieldName)\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n              });\n              for (const updateOperation in update) {\n                if (\n                  update[updateOperation] &&\n                  typeof update[updateOperation] === 'object' &&\n                  Object.keys(update[updateOperation]).some(\n                    innerKey => innerKey.includes('$') || innerKey.includes('.')\n                  )\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_NESTED_KEY,\n                    \"Nested keys should not contain the '$' or '.' characters\"\n                  );\n                }\n              }\n              update = transformObjectACL(update);\n              transformAuthData(className, update, schema);\n              if (validateOnly) {\n                return this.adapter.find(className, schema, query, {}).then(result => {\n                  if (!result || !result.length) {\n                    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                  }\n                  return {};\n                });\n              }\n              if (many) {\n                return this.adapter.updateObjectsByQuery(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else if (upsert) {\n                return this.adapter.upsertOneObject(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else {\n                return this.adapter.findOneAndUpdate(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              }\n            });\n        })\n        .then((result: any) => {\n          if (!result) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          if (validateOnly) {\n            return result;\n          }\n          return this.handleRelationUpdates(\n            className,\n            originalQuery.objectId,\n            update,\n            relationUpdates\n          ).then(() => {\n            return result;\n          });\n        })\n        .then(result => {\n          if (skipSanitization) {\n            return Promise.resolve(result);\n          }\n          return sanitizeDatabaseResult(originalUpdate, result);\n        });\n    });\n  }\n\n  // Collect all relation-updating operations from a REST-format update.\n  // Returns a list of all relation updates to perform\n  // This mutates update.\n  collectRelationUpdates(className: string, objectId: ?string, update: any) {\n    var ops = [];\n    var deleteMe = [];\n    objectId = update.objectId || objectId;\n\n    var process = (op, key) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'Batch') {\n        for (var x of op.ops) {\n          process(x, key);\n        }\n      }\n    };\n\n    for (const key in update) {\n      process(update[key], key);\n    }\n    for (const key of deleteMe) {\n      delete update[key];\n    }\n    return ops;\n  }\n\n  // Processes relation-updating operations from a REST-format update.\n  // Returns a promise that resolves when all updates have been performed\n  handleRelationUpdates(className: string, objectId: string, update: any, ops: any) {\n    var pending = [];\n    objectId = update.objectId || objectId;\n    ops.forEach(({ key, op }) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        for (const object of op.objects) {\n          pending.push(this.addRelation(key, className, objectId, object.objectId));\n        }\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        for (const object of op.objects) {\n          pending.push(this.removeRelation(key, className, objectId, object.objectId));\n        }\n      }\n    });\n\n    return Promise.all(pending);\n  }\n\n  // Adds a relation.\n  // Returns a promise that resolves successfully iff the add was successful.\n  addRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    const doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter.upsertOneObject(\n      `_Join:${key}:${fromClassName}`,\n      relationSchema,\n      doc,\n      doc,\n      this._transactionalSession\n    );\n  }\n\n  // Removes a relation.\n  // Returns a promise that resolves successfully iff the remove was\n  // successful.\n  removeRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    var doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter\n      .deleteObjectsByQuery(\n        `_Join:${key}:${fromClassName}`,\n        relationSchema,\n        doc,\n        this._transactionalSession\n      )\n      .catch(error => {\n        // We don't care if they try to delete a non-existent relation.\n        if (error.code == Parse.Error.OBJECT_NOT_FOUND) {\n          return;\n        }\n        throw error;\n      });\n  }\n\n  // Removes objects matches this query from the database.\n  // Returns a promise that resolves successfully iff the object was\n  // deleted.\n  // Options:\n  //   acl:  a list of strings. If the object to be updated has an ACL,\n  //         one of the provided strings must provide the caller with\n  //         write permissions.\n  destroy(\n    className: string,\n    query: any,\n    { acl }: QueryOptions = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'delete')\n      ).then(() => {\n        if (!isMaster) {\n          query = this.addPointerPermissions(\n            schemaController,\n            className,\n            'delete',\n            query,\n            aclGroup\n          );\n          if (!query) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n        }\n        // delete by query\n        if (acl) {\n          query = addWriteACL(query, acl);\n        }\n        validateQuery(query);\n        return schemaController\n          .getOneSchema(className)\n          .catch(error => {\n            // If the schema doesn't exist, pretend it exists with no fields. This behavior\n            // will likely need revisiting.\n            if (error === undefined) {\n              return { fields: {} };\n            }\n            throw error;\n          })\n          .then(parseFormatSchema =>\n            this.adapter.deleteObjectsByQuery(\n              className,\n              parseFormatSchema,\n              query,\n              this._transactionalSession\n            )\n          )\n          .catch(error => {\n            // When deleting sessions while changing passwords, don't throw an error if they don't have any sessions.\n            if (className === '_Session' && error.code === Parse.Error.OBJECT_NOT_FOUND) {\n              return Promise.resolve({});\n            }\n            throw error;\n          });\n      });\n    });\n  }\n\n  // Inserts an object into the database.\n  // Returns a promise that resolves successfully iff the object saved.\n  create(\n    className: string,\n    object: any,\n    { acl }: QueryOptions = {},\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    // Make a copy of the object, so we don't mutate the incoming data.\n    const originalObject = object;\n    object = transformObjectACL(object);\n\n    object.createdAt = { iso: object.createdAt, __type: 'Date' };\n    object.updatedAt = { iso: object.updatedAt, __type: 'Date' };\n\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n    const relationUpdates = this.collectRelationUpdates(className, null, object);\n\n    return this.validateClassName(className)\n      .then(() => this.loadSchemaIfNeeded(validSchemaController))\n      .then(schemaController => {\n        return (isMaster\n          ? Promise.resolve()\n          : schemaController.validatePermission(className, aclGroup, 'create')\n        )\n          .then(() => schemaController.enforceClassExists(className))\n          .then(() => schemaController.getOneSchema(className, true))\n          .then(schema => {\n            transformAuthData(className, object, schema);\n            flattenUpdateOperatorsForCreate(object);\n            if (validateOnly) {\n              return {};\n            }\n            return this.adapter.createObject(\n              className,\n              SchemaController.convertSchemaToAdapterSchema(schema),\n              object,\n              this._transactionalSession\n            );\n          })\n          .then(result => {\n            if (validateOnly) {\n              return originalObject;\n            }\n            return this.handleRelationUpdates(\n              className,\n              object.objectId,\n              object,\n              relationUpdates\n            ).then(() => {\n              return sanitizeDatabaseResult(originalObject, result.ops[0]);\n            });\n          });\n      });\n  }\n\n  canAddField(\n    schema: SchemaController.SchemaController,\n    className: string,\n    object: any,\n    aclGroup: string[],\n    runOptions: QueryOptions\n  ): Promise<void> {\n    const classSchema = schema.schemaData[className];\n    if (!classSchema) {\n      return Promise.resolve();\n    }\n    const fields = Object.keys(object);\n    const schemaFields = Object.keys(classSchema.fields);\n    const newKeys = fields.filter(field => {\n      // Skip fields that are unset\n      if (object[field] && object[field].__op && object[field].__op === 'Delete') {\n        return false;\n      }\n      return schemaFields.indexOf(field) < 0;\n    });\n    if (newKeys.length > 0) {\n      // adds a marker that new field is being adding during update\n      runOptions.addsField = true;\n\n      const action = runOptions.action;\n      return schema.validatePermission(className, aclGroup, 'addField', action);\n    }\n    return Promise.resolve();\n  }\n\n  // Won't delete collections in the system namespace\n  /**\n   * Delete all classes and clears the schema cache\n   *\n   * @param {boolean} fast set to true if it's ok to just delete rows and not indexes\n   * @returns {Promise<void>} when the deletions completes\n   */\n  deleteEverything(fast: boolean = false): Promise<any> {\n    this.schemaPromise = null;\n    return Promise.all([this.adapter.deleteAllClasses(fast), this.schemaCache.clear()]);\n  }\n\n  // Returns a promise for a list of related ids given an owning id.\n  // className here is the owning className.\n  relatedIds(\n    className: string,\n    key: string,\n    owningId: string,\n    queryOptions: QueryOptions\n  ): Promise<Array<string>> {\n    const { skip, limit, sort } = queryOptions;\n    const findOptions = {};\n    if (sort && sort.createdAt && this.adapter.canSortOnJoinTables) {\n      findOptions.sort = { _id: sort.createdAt };\n      findOptions.limit = limit;\n      findOptions.skip = skip;\n      queryOptions.skip = 0;\n    }\n    return this.adapter\n      .find(joinTableName(className, key), relationSchema, { owningId }, findOptions)\n      .then(results => results.map(result => result.relatedId));\n  }\n\n  // Returns a promise for a list of owning ids given some related ids.\n  // className here is the owning className.\n  owningIds(className: string, key: string, relatedIds: string[]): Promise<string[]> {\n    return this.adapter\n      .find(\n        joinTableName(className, key),\n        relationSchema,\n        { relatedId: { $in: relatedIds } },\n        { keys: ['owningId'] }\n      )\n      .then(results => results.map(result => result.owningId));\n  }\n\n  // Modifies query so that it no longer has $in on relation fields, or\n  // equal-to-pointer constraints on relation fields.\n  // Returns a promise that resolves when query is mutated\n  reduceInRelation(className: string, query: any, schema: any): Promise<any> {\n    // Search for an in-relation or equal-to-relation\n    // Make it sequential for now, not sure of paralleization side effects\n    if (query['$or']) {\n      const ors = query['$or'];\n      return Promise.all(\n        ors.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$or'][index] = aQuery;\n          });\n        })\n      ).then(() => {\n        return Promise.resolve(query);\n      });\n    }\n\n    const promises = Object.keys(query).map(key => {\n      const t = schema.getExpectedType(className, key);\n      if (!t || t.type !== 'Relation') {\n        return Promise.resolve(query);\n      }\n      let queries: ?(any[]) = null;\n      if (\n        query[key] &&\n        (query[key]['$in'] ||\n          query[key]['$ne'] ||\n          query[key]['$nin'] ||\n          query[key].__type == 'Pointer')\n      ) {\n        // Build the list of queries\n        queries = Object.keys(query[key]).map(constraintKey => {\n          let relatedIds;\n          let isNegation = false;\n          if (constraintKey === 'objectId') {\n            relatedIds = [query[key].objectId];\n          } else if (constraintKey == '$in') {\n            relatedIds = query[key]['$in'].map(r => r.objectId);\n          } else if (constraintKey == '$nin') {\n            isNegation = true;\n            relatedIds = query[key]['$nin'].map(r => r.objectId);\n          } else if (constraintKey == '$ne') {\n            isNegation = true;\n            relatedIds = [query[key]['$ne'].objectId];\n          } else {\n            return;\n          }\n          return {\n            isNegation,\n            relatedIds,\n          };\n        });\n      } else {\n        queries = [{ isNegation: false, relatedIds: [] }];\n      }\n\n      // remove the current queryKey as we don,t need it anymore\n      delete query[key];\n      // execute each query independently to build the list of\n      // $in / $nin\n      const promises = queries.map(q => {\n        if (!q) {\n          return Promise.resolve();\n        }\n        return this.owningIds(className, key, q.relatedIds).then(ids => {\n          if (q.isNegation) {\n            this.addNotInObjectIdsIds(ids, query);\n          } else {\n            this.addInObjectIdsIds(ids, query);\n          }\n          return Promise.resolve();\n        });\n      });\n\n      return Promise.all(promises).then(() => {\n        return Promise.resolve();\n      });\n    });\n\n    return Promise.all(promises).then(() => {\n      return Promise.resolve(query);\n    });\n  }\n\n  // Modifies query so that it no longer has $relatedTo\n  // Returns a promise that resolves when query is mutated\n  reduceRelationKeys(className: string, query: any, queryOptions: any): ?Promise<void> {\n    if (query['$or']) {\n      return Promise.all(\n        query['$or'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n\n    var relatedTo = query['$relatedTo'];\n    if (relatedTo) {\n      return this.relatedIds(\n        relatedTo.object.className,\n        relatedTo.key,\n        relatedTo.object.objectId,\n        queryOptions\n      )\n        .then(ids => {\n          delete query['$relatedTo'];\n          this.addInObjectIdsIds(ids, query);\n          return this.reduceRelationKeys(className, query, queryOptions);\n        })\n        .then(() => {});\n    }\n  }\n\n  addInObjectIdsIds(ids: ?Array<string> = null, query: any) {\n    const idsFromString: ?Array<string> =\n      typeof query.objectId === 'string' ? [query.objectId] : null;\n    const idsFromEq: ?Array<string> =\n      query.objectId && query.objectId['$eq'] ? [query.objectId['$eq']] : null;\n    const idsFromIn: ?Array<string> =\n      query.objectId && query.objectId['$in'] ? query.objectId['$in'] : null;\n\n    // @flow-disable-next\n    const allIds: Array<Array<string>> = [idsFromString, idsFromEq, idsFromIn, ids].filter(\n      list => list !== null\n    );\n    const totalLength = allIds.reduce((memo, list) => memo + list.length, 0);\n\n    let idsIntersection = [];\n    if (totalLength > 125) {\n      idsIntersection = intersect.big(allIds);\n    } else {\n      idsIntersection = intersect(allIds);\n    }\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $in: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $in: undefined,\n        $eq: query.objectId,\n      };\n    }\n    query.objectId['$in'] = idsIntersection;\n\n    return query;\n  }\n\n  addNotInObjectIdsIds(ids: string[] = [], query: any) {\n    const idsFromNin = query.objectId && query.objectId['$nin'] ? query.objectId['$nin'] : [];\n    let allIds = [...idsFromNin, ...ids].filter(list => list !== null);\n\n    // make a set and spread to remove duplicates\n    allIds = [...new Set(allIds)];\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $nin: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $nin: undefined,\n        $eq: query.objectId,\n      };\n    }\n\n    query.objectId['$nin'] = allIds;\n    return query;\n  }\n\n  // Runs a query on the database.\n  // Returns a promise that resolves to a list of items.\n  // Options:\n  //   skip    number of results to skip.\n  //   limit   limit to this number of results.\n  //   sort    an object where keys are the fields to sort by.\n  //           the value is +1 for ascending, -1 for descending.\n  //   count   run a count instead of returning results.\n  //   acl     restrict this operation with an ACL for the provided array\n  //           of user objectIds and roles. acl: null means no user.\n  //           when this field is not present, don't do anything regarding ACLs.\n  //  caseInsensitive make string comparisons case insensitive\n  // TODO: make userIds not needed here. The db adapter shouldn't know\n  // anything about users, ideally. Then, improve the format of the ACL\n  // arg to work like the others.\n  find(\n    className: string,\n    query: any,\n    {\n      skip,\n      limit,\n      acl,\n      sort = {},\n      count,\n      keys,\n      op,\n      distinct,\n      pipeline,\n      readPreference,\n      hint,\n      caseInsensitive = false,\n      explain,\n    }: any = {},\n    auth: any = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n    op =\n      op || (typeof query.objectId == 'string' && Object.keys(query).length === 1 ? 'get' : 'find');\n    // Count operation if counting\n    op = count === true ? 'count' : op;\n\n    let classExists = true;\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      //Allow volatile classes if querying with Master (for _PushStatus)\n      //TODO: Move volatile classes concept into mongo adapter, postgres adapter shouldn't care\n      //that api.parse.com breaks when _PushStatus exists in mongo.\n      return schemaController\n        .getOneSchema(className, isMaster)\n        .catch(error => {\n          // Behavior for non-existent classes is kinda weird on Parse.com. Probably doesn't matter too much.\n          // For now, pretend the class exists but has no objects,\n          if (error === undefined) {\n            classExists = false;\n            return { fields: {} };\n          }\n          throw error;\n        })\n        .then(schema => {\n          // Parse.com treats queries on _created_at and _updated_at as if they were queries on createdAt and updatedAt,\n          // so duplicate that behavior here. If both are specified, the correct behavior to match Parse.com is to\n          // use the one that appears first in the sort list.\n          if (sort._created_at) {\n            sort.createdAt = sort._created_at;\n            delete sort._created_at;\n          }\n          if (sort._updated_at) {\n            sort.updatedAt = sort._updated_at;\n            delete sort._updated_at;\n          }\n          const queryOptions = {\n            skip,\n            limit,\n            sort,\n            keys,\n            readPreference,\n            hint,\n            caseInsensitive,\n            explain,\n          };\n          Object.keys(sort).forEach(fieldName => {\n            if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n              throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Cannot sort by ${fieldName}`);\n            }\n            const rootFieldName = getRootFieldName(fieldName);\n            if (!SchemaController.fieldNameIsValid(rootFieldName, className)) {\n              throw new Parse.Error(\n                Parse.Error.INVALID_KEY_NAME,\n                `Invalid field name: ${fieldName}.`\n              );\n            }\n          });\n          return (isMaster\n            ? Promise.resolve()\n            : schemaController.validatePermission(className, aclGroup, op)\n          )\n            .then(() => this.reduceRelationKeys(className, query, queryOptions))\n            .then(() => this.reduceInRelation(className, query, schemaController))\n            .then(() => {\n              let protectedFields;\n              if (!isMaster) {\n                query = this.addPointerPermissions(\n                  schemaController,\n                  className,\n                  op,\n                  query,\n                  aclGroup\n                );\n                /* Don't use projections to optimize the protectedFields since the protectedFields\n                  based on pointer-permissions are determined after querying. The filtering can\n                  overwrite the protected fields. */\n                protectedFields = this.addProtectedFields(\n                  schemaController,\n                  className,\n                  query,\n                  aclGroup,\n                  auth,\n                  queryOptions\n                );\n              }\n              if (!query) {\n                if (op === 'get') {\n                  throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                } else {\n                  return [];\n                }\n              }\n              if (!isMaster) {\n                if (op === 'update' || op === 'delete') {\n                  query = addWriteACL(query, aclGroup);\n                } else {\n                  query = addReadACL(query, aclGroup);\n                }\n              }\n              validateQuery(query);\n              if (count) {\n                if (!classExists) {\n                  return 0;\n                } else {\n                  return this.adapter.count(\n                    className,\n                    schema,\n                    query,\n                    readPreference,\n                    undefined,\n                    hint\n                  );\n                }\n              } else if (distinct) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.distinct(className, schema, query, distinct);\n                }\n              } else if (pipeline) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.aggregate(\n                    className,\n                    schema,\n                    pipeline,\n                    readPreference,\n                    hint,\n                    explain\n                  );\n                }\n              } else if (explain) {\n                return this.adapter.find(className, schema, query, queryOptions);\n              } else {\n                return this.adapter\n                  .find(className, schema, query, queryOptions)\n                  .then(objects =>\n                    objects.map(object => {\n                      object = untransformObjectACL(object);\n                      return filterSensitiveData(\n                        isMaster,\n                        aclGroup,\n                        auth,\n                        op,\n                        schemaController,\n                        className,\n                        protectedFields,\n                        object\n                      );\n                    })\n                  )\n                  .catch(error => {\n                    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, error);\n                  });\n              }\n            });\n        });\n    });\n  }\n\n  deleteSchema(className: string): Promise<void> {\n    return this.loadSchema({ clearCache: true })\n      .then(schemaController => schemaController.getOneSchema(className, true))\n      .catch(error => {\n        if (error === undefined) {\n          return { fields: {} };\n        } else {\n          throw error;\n        }\n      })\n      .then((schema: any) => {\n        return this.collectionExists(className)\n          .then(() => this.adapter.count(className, { fields: {} }, null, '', false))\n          .then(count => {\n            if (count > 0) {\n              throw new Parse.Error(\n                255,\n                `Class ${className} is not empty, contains ${count} objects, cannot drop schema.`\n              );\n            }\n            return this.adapter.deleteClass(className);\n          })\n          .then(wasParseCollection => {\n            if (wasParseCollection) {\n              const relationFieldNames = Object.keys(schema.fields).filter(\n                fieldName => schema.fields[fieldName].type === 'Relation'\n              );\n              return Promise.all(\n                relationFieldNames.map(name =>\n                  this.adapter.deleteClass(joinTableName(className, name))\n                )\n              ).then(() => {\n                return;\n              });\n            } else {\n              return Promise.resolve();\n            }\n          });\n      });\n  }\n\n  // This helps to create intermediate objects for simpler comparison of\n  // key value pairs used in query objects. Each key value pair will represented\n  // in a similar way to json\n  objectToEntriesStrings(query: any): Array<string> {\n    return Object.entries(query).map(a => a.map(s => JSON.stringify(s)).join(':'));\n  }\n\n  // Naive logic reducer for OR operations meant to be used only for pointer permissions.\n  reduceOrOperation(query: { $or: Array<any> }): any {\n    if (!query.$or) {\n      return query;\n    }\n    const queries = query.$or.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the longer query.\n            query.$or.splice(longer, 1);\n            queries.splice(longer, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$or.length === 1) {\n      query = { ...query, ...query.$or[0] };\n      delete query.$or;\n    }\n    return query;\n  }\n\n  // Naive logic reducer for AND operations meant to be used only for pointer permissions.\n  reduceAndOperation(query: { $and: Array<any> }): any {\n    if (!query.$and) {\n      return query;\n    }\n    const queries = query.$and.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the shorter query.\n            query.$and.splice(shorter, 1);\n            queries.splice(shorter, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$and.length === 1) {\n      query = { ...query, ...query.$and[0] };\n      delete query.$and;\n    }\n    return query;\n  }\n\n  // Constraints query using CLP's pointer permissions (PP) if any.\n  // 1. Etract the user id from caller's ACLgroup;\n  // 2. Exctract a list of field names that are PP for target collection and operation;\n  // 3. Constraint the original query so that each PP field must\n  // point to caller's id (or contain it in case of PP field being an array)\n  addPointerPermissions(\n    schema: SchemaController.SchemaController,\n    className: string,\n    operation: string,\n    query: any,\n    aclGroup: any[] = []\n  ): any {\n    // Check if class has public permission for operation\n    // If the BaseCLP pass, let go through\n    if (schema.testPermissionsForClassName(className, aclGroup, operation)) {\n      return query;\n    }\n    const perms = schema.getClassLevelPermissions(className);\n\n    const userACL = aclGroup.filter(acl => {\n      return acl.indexOf('role:') != 0 && acl != '*';\n    });\n\n    const groupKey =\n      ['get', 'find', 'count'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n    const permFields = [];\n\n    if (perms[operation] && perms[operation].pointerFields) {\n      permFields.push(...perms[operation].pointerFields);\n    }\n\n    if (perms[groupKey]) {\n      for (const field of perms[groupKey]) {\n        if (!permFields.includes(field)) {\n          permFields.push(field);\n        }\n      }\n    }\n    // the ACL should have exactly 1 user\n    if (permFields.length > 0) {\n      // the ACL should have exactly 1 user\n      // No user set return undefined\n      // If the length is > 1, that means we didn't de-dupe users correctly\n      if (userACL.length != 1) {\n        return;\n      }\n      const userId = userACL[0];\n      const userPointer = {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: userId,\n      };\n\n      const queries = permFields.map(key => {\n        const fieldDescriptor = schema.getExpectedType(className, key);\n        const fieldType =\n          fieldDescriptor &&\n          typeof fieldDescriptor === 'object' &&\n          Object.prototype.hasOwnProperty.call(fieldDescriptor, 'type')\n            ? fieldDescriptor.type\n            : null;\n\n        let queryClause;\n\n        if (fieldType === 'Pointer') {\n          // constraint for single pointer setup\n          queryClause = { [key]: userPointer };\n        } else if (fieldType === 'Array') {\n          // constraint for users-array setup\n          queryClause = { [key]: { $all: [userPointer] } };\n        } else if (fieldType === 'Object') {\n          // constraint for object setup\n          queryClause = { [key]: userPointer };\n        } else {\n          // This means that there is a CLP field of an unexpected type. This condition should not happen, which is\n          // why is being treated as an error.\n          throw Error(\n            `An unexpected condition occurred when resolving pointer permissions: ${className} ${key}`\n          );\n        }\n        // if we already have a constraint on the key, use the $and\n        if (Object.prototype.hasOwnProperty.call(query, key)) {\n          return this.reduceAndOperation({ $and: [queryClause, query] });\n        }\n        // otherwise just add the constaint\n        return Object.assign({}, query, queryClause);\n      });\n\n      return queries.length === 1 ? queries[0] : this.reduceOrOperation({ $or: queries });\n    } else {\n      return query;\n    }\n  }\n\n  addProtectedFields(\n    schema: SchemaController.SchemaController,\n    className: string,\n    query: any = {},\n    aclGroup: any[] = [],\n    auth: any = {},\n    queryOptions: FullQueryOptions = {}\n  ): null | string[] {\n    const perms = schema.getClassLevelPermissions(className);\n    if (!perms) return null;\n\n    const protectedFields = perms.protectedFields;\n    if (!protectedFields) return null;\n\n    if (aclGroup.indexOf(query.objectId) > -1) return null;\n\n    // for queries where \"keys\" are set and do not include all 'userField':{field},\n    // we have to transparently include it, and then remove before returning to client\n    // Because if such key not projected the permission won't be enforced properly\n    // PS this is called when 'excludeKeys' already reduced to 'keys'\n    const preserveKeys = queryOptions.keys;\n\n    // these are keys that need to be included only\n    // to be able to apply protectedFields by pointer\n    // and then unset before returning to client (later in  filterSensitiveFields)\n    const serverOnlyKeys = [];\n\n    const authenticated = auth.user;\n\n    // map to allow check without array search\n    const roles = (auth.userRoles || []).reduce((acc, r) => {\n      acc[r] = protectedFields[r];\n      return acc;\n    }, {});\n\n    // array of sets of protected fields. separate item for each applicable criteria\n    const protectedKeysSets = [];\n\n    for (const key in protectedFields) {\n      // skip userFields\n      if (key.startsWith('userField:')) {\n        if (preserveKeys) {\n          const fieldName = key.substring(10);\n          if (!preserveKeys.includes(fieldName)) {\n            // 1. put it there temporarily\n            queryOptions.keys && queryOptions.keys.push(fieldName);\n            // 2. preserve it delete later\n            serverOnlyKeys.push(fieldName);\n          }\n        }\n        continue;\n      }\n\n      // add public tier\n      if (key === '*') {\n        protectedKeysSets.push(protectedFields[key]);\n        continue;\n      }\n\n      if (authenticated) {\n        if (key === 'authenticated') {\n          // for logged in users\n          protectedKeysSets.push(protectedFields[key]);\n          continue;\n        }\n\n        if (roles[key] && key.startsWith('role:')) {\n          // add applicable roles\n          protectedKeysSets.push(roles[key]);\n        }\n      }\n    }\n\n    // check if there's a rule for current user's id\n    if (authenticated) {\n      const userId = auth.user.id;\n      if (perms.protectedFields[userId]) {\n        protectedKeysSets.push(perms.protectedFields[userId]);\n      }\n    }\n\n    // preserve fields to be removed before sending response to client\n    if (serverOnlyKeys.length > 0) {\n      perms.protectedFields.temporaryKeys = serverOnlyKeys;\n    }\n\n    let protectedKeys = protectedKeysSets.reduce((acc, next) => {\n      if (next) {\n        acc.push(...next);\n      }\n      return acc;\n    }, []);\n\n    // intersect all sets of protectedFields\n    protectedKeysSets.forEach(fields => {\n      if (fields) {\n        protectedKeys = protectedKeys.filter(v => fields.includes(v));\n      }\n    });\n\n    return protectedKeys;\n  }\n\n  createTransactionalSession() {\n    return this.adapter.createTransactionalSession().then(transactionalSession => {\n      this._transactionalSession = transactionalSession;\n    });\n  }\n\n  commitTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to commit');\n    }\n    return this.adapter.commitTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  abortTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to abort');\n    }\n    return this.adapter.abortTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  // TODO: create indexes on first creation of a _User object. Otherwise it's impossible to\n  // have a Parse app without it having a _User collection.\n  performInitialization() {\n    const requiredUserFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._User,\n      },\n    };\n    const requiredRoleFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Role,\n      },\n    };\n    const requiredIdempotencyFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Idempotency,\n      },\n    };\n\n    const userClassPromise = this.loadSchema().then(schema => schema.enforceClassExists('_User'));\n    const roleClassPromise = this.loadSchema().then(schema => schema.enforceClassExists('_Role'));\n    const idempotencyClassPromise =\n      this.adapter instanceof MongoStorageAdapter\n        ? this.loadSchema().then(schema => schema.enforceClassExists('_Idempotency'))\n        : Promise.resolve();\n\n    const usernameUniqueness = userClassPromise\n      .then(() => this.adapter.ensureUniqueness('_User', requiredUserFields, ['username']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for usernames: ', error);\n        throw error;\n      });\n\n    const usernameCaseInsensitiveIndex = userClassPromise\n      .then(() =>\n        this.adapter.ensureIndex(\n          '_User',\n          requiredUserFields,\n          ['username'],\n          'case_insensitive_username',\n          true\n        )\n      )\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n\n    const emailUniqueness = userClassPromise\n      .then(() => this.adapter.ensureUniqueness('_User', requiredUserFields, ['email']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for user email addresses: ', error);\n        throw error;\n      });\n\n    const emailCaseInsensitiveIndex = userClassPromise\n      .then(() =>\n        this.adapter.ensureIndex(\n          '_User',\n          requiredUserFields,\n          ['email'],\n          'case_insensitive_email',\n          true\n        )\n      )\n      .catch(error => {\n        logger.warn('Unable to create case insensitive email index: ', error);\n        throw error;\n      });\n\n    const roleUniqueness = roleClassPromise\n      .then(() => this.adapter.ensureUniqueness('_Role', requiredRoleFields, ['name']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for role name: ', error);\n        throw error;\n      });\n\n    const idempotencyRequestIdIndex =\n      this.adapter instanceof MongoStorageAdapter\n        ? idempotencyClassPromise\n          .then(() =>\n            this.adapter.ensureUniqueness('_Idempotency', requiredIdempotencyFields, ['reqId'])\n          )\n          .catch(error => {\n            logger.warn('Unable to ensure uniqueness for idempotency request ID: ', error);\n            throw error;\n          })\n        : Promise.resolve();\n\n    const idempotencyExpireIndex =\n      this.adapter instanceof MongoStorageAdapter\n        ? idempotencyClassPromise\n          .then(() =>\n            this.adapter.ensureIndex(\n              '_Idempotency',\n              requiredIdempotencyFields,\n              ['expire'],\n              'ttl',\n              false,\n              { ttl: 0 }\n            )\n          )\n          .catch(error => {\n            logger.warn('Unable to create TTL index for idempotency expire date: ', error);\n            throw error;\n          })\n        : Promise.resolve();\n\n    const indexPromise = this.adapter.updateSchemaWithIndexes();\n\n    // Create tables for volatile classes\n    const adapterInit = this.adapter.performInitialization({\n      VolatileClassesSchemas: SchemaController.VolatileClassesSchemas,\n    });\n    return Promise.all([\n      usernameUniqueness,\n      usernameCaseInsensitiveIndex,\n      emailUniqueness,\n      emailCaseInsensitiveIndex,\n      roleUniqueness,\n      idempotencyRequestIdIndex,\n      idempotencyExpireIndex,\n      adapterInit,\n      indexPromise,\n    ]);\n  }\n\n  static _validateQuery: any => void;\n}\n\nmodule.exports = DatabaseController;\n// Expose validateQuery for tests\nmodule.exports._validateQuery = validateQuery;\n"],"file":"DatabaseController.js"}