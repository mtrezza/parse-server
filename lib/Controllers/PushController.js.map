{"version":3,"sources":["../../src/Controllers/PushController.js"],"names":["PushController","sendPush","body","where","config","auth","onPushStatusSaved","now","Date","hasPushSupport","Parse","Error","PUSH_MISCONFIGURED","expiration_time","getExpirationTime","expiration_interval","getExpirationInterval","Object","prototype","hasOwnProperty","call","ttlMs","valueOf","pushTime","getPushTime","date","formatPushTime","badgeUpdate","Promise","resolve","data","badge","restUpdate","toLowerCase","__op","amount","Number","updateWhere","restQuery","RestQuery","buildRestWhere","then","write","RestWrite","restWhere","runOptions","many","execute","pushStatus","setInitial","objectId","audience_id","audienceId","updateAudience","lastUsed","__type","iso","toISOString","timesUsed","hasPushScheduledSupport","pushControllerQueue","enqueue","catch","err","fail","hasExpirationTime","expirationTimeParam","expirationTime","isFinite","hasExpirationInterval","expirationIntervalParam","hasPushTime","pushTimeParam","isLocalTime","pushTimeHasTimezoneComponent","offsetPattern","indexOf","length","test","isoString","substring"],"mappings":"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","sourcesContent":["import { Parse } from 'parse/node';\nimport RestQuery from '../RestQuery';\nimport RestWrite from '../RestWrite';\nimport { master } from '../Auth';\nimport { pushStatusHandler } from '../StatusHandler';\nimport { applyDeviceTokenExists } from '../Push/utils';\n\nexport class PushController {\n  sendPush(body = {}, where = {}, config, auth, onPushStatusSaved = () => {}, now = new Date()) {\n    if (!config.hasPushSupport) {\n      throw new Parse.Error(Parse.Error.PUSH_MISCONFIGURED, 'Missing push configuration');\n    }\n\n    // Replace the expiration_time and push_time with a valid Unix epoch milliseconds time\n    body.expiration_time = PushController.getExpirationTime(body);\n    body.expiration_interval = PushController.getExpirationInterval(body);\n    if (body.expiration_time && body.expiration_interval) {\n      throw new Parse.Error(\n        Parse.Error.PUSH_MISCONFIGURED,\n        'Both expiration_time and expiration_interval cannot be set'\n      );\n    }\n\n    // Immediate push\n    if (body.expiration_interval && !Object.prototype.hasOwnProperty.call(body, 'push_time')) {\n      const ttlMs = body.expiration_interval * 1000;\n      body.expiration_time = new Date(now.valueOf() + ttlMs).valueOf();\n    }\n\n    const pushTime = PushController.getPushTime(body);\n    if (pushTime && pushTime.date !== 'undefined') {\n      body['push_time'] = PushController.formatPushTime(pushTime);\n    }\n\n    // TODO: If the req can pass the checking, we return immediately instead of waiting\n    // pushes to be sent. We probably change this behaviour in the future.\n    let badgeUpdate = () => {\n      return Promise.resolve();\n    };\n\n    if (body.data && body.data.badge) {\n      const badge = body.data.badge;\n      let restUpdate = {};\n      if (typeof badge == 'string' && badge.toLowerCase() === 'increment') {\n        restUpdate = { badge: { __op: 'Increment', amount: 1 } };\n      } else if (\n        typeof badge == 'object' &&\n        typeof badge.__op == 'string' &&\n        badge.__op.toLowerCase() == 'increment' &&\n        Number(badge.amount)\n      ) {\n        restUpdate = { badge: { __op: 'Increment', amount: badge.amount } };\n      } else if (Number(badge)) {\n        restUpdate = { badge: badge };\n      } else {\n        throw \"Invalid value for badge, expected number or 'Increment' or {increment: number}\";\n      }\n\n      // Force filtering on only valid device tokens\n      const updateWhere = applyDeviceTokenExists(where);\n      badgeUpdate = () => {\n        // Build a real RestQuery so we can use it in RestWrite\n        const restQuery = new RestQuery(config, master(config), '_Installation', updateWhere);\n        return restQuery.buildRestWhere().then(() => {\n          const write = new RestWrite(\n            config,\n            master(config),\n            '_Installation',\n            restQuery.restWhere,\n            restUpdate\n          );\n          write.runOptions.many = true;\n          return write.execute();\n        });\n      };\n    }\n    const pushStatus = pushStatusHandler(config);\n    return Promise.resolve()\n      .then(() => {\n        return pushStatus.setInitial(body, where);\n      })\n      .then(() => {\n        onPushStatusSaved(pushStatus.objectId);\n        return badgeUpdate();\n      })\n      .then(() => {\n        // Update audience lastUsed and timesUsed\n        if (body.audience_id) {\n          const audienceId = body.audience_id;\n\n          var updateAudience = {\n            lastUsed: { __type: 'Date', iso: new Date().toISOString() },\n            timesUsed: { __op: 'Increment', amount: 1 },\n          };\n          const write = new RestWrite(\n            config,\n            master(config),\n            '_Audience',\n            { objectId: audienceId },\n            updateAudience\n          );\n          write.execute();\n        }\n        // Don't wait for the audience update promise to resolve.\n        return Promise.resolve();\n      })\n      .then(() => {\n        if (\n          Object.prototype.hasOwnProperty.call(body, 'push_time') &&\n          config.hasPushScheduledSupport\n        ) {\n          return Promise.resolve();\n        }\n        return config.pushControllerQueue.enqueue(body, where, config, auth, pushStatus);\n      })\n      .catch(err => {\n        return pushStatus.fail(err).then(() => {\n          throw err;\n        });\n      });\n  }\n\n  /**\n   * Get expiration time from the request body.\n   * @param {Object} request A request object\n   * @returns {Number|undefined} The expiration time if it exists in the request\n   */\n  static getExpirationTime(body = {}) {\n    var hasExpirationTime = Object.prototype.hasOwnProperty.call(body, 'expiration_time');\n    if (!hasExpirationTime) {\n      return;\n    }\n    var expirationTimeParam = body['expiration_time'];\n    var expirationTime;\n    if (typeof expirationTimeParam === 'number') {\n      expirationTime = new Date(expirationTimeParam * 1000);\n    } else if (typeof expirationTimeParam === 'string') {\n      expirationTime = new Date(expirationTimeParam);\n    } else {\n      throw new Parse.Error(\n        Parse.Error.PUSH_MISCONFIGURED,\n        body['expiration_time'] + ' is not valid time.'\n      );\n    }\n    // Check expirationTime is valid or not, if it is not valid, expirationTime is NaN\n    if (!isFinite(expirationTime)) {\n      throw new Parse.Error(\n        Parse.Error.PUSH_MISCONFIGURED,\n        body['expiration_time'] + ' is not valid time.'\n      );\n    }\n    return expirationTime.valueOf();\n  }\n\n  static getExpirationInterval(body = {}) {\n    const hasExpirationInterval = Object.prototype.hasOwnProperty.call(body, 'expiration_interval');\n    if (!hasExpirationInterval) {\n      return;\n    }\n\n    var expirationIntervalParam = body['expiration_interval'];\n    if (typeof expirationIntervalParam !== 'number' || expirationIntervalParam <= 0) {\n      throw new Parse.Error(\n        Parse.Error.PUSH_MISCONFIGURED,\n        `expiration_interval must be a number greater than 0`\n      );\n    }\n    return expirationIntervalParam;\n  }\n\n  /**\n   * Get push time from the request body.\n   * @param {Object} request A request object\n   * @returns {Number|undefined} The push time if it exists in the request\n   */\n  static getPushTime(body = {}) {\n    var hasPushTime = Object.prototype.hasOwnProperty.call(body, 'push_time');\n    if (!hasPushTime) {\n      return;\n    }\n    var pushTimeParam = body['push_time'];\n    var date;\n    var isLocalTime = true;\n\n    if (typeof pushTimeParam === 'number') {\n      date = new Date(pushTimeParam * 1000);\n    } else if (typeof pushTimeParam === 'string') {\n      isLocalTime = !PushController.pushTimeHasTimezoneComponent(pushTimeParam);\n      date = new Date(pushTimeParam);\n    } else {\n      throw new Parse.Error(\n        Parse.Error.PUSH_MISCONFIGURED,\n        body['push_time'] + ' is not valid time.'\n      );\n    }\n    // Check pushTime is valid or not, if it is not valid, pushTime is NaN\n    if (!isFinite(date)) {\n      throw new Parse.Error(\n        Parse.Error.PUSH_MISCONFIGURED,\n        body['push_time'] + ' is not valid time.'\n      );\n    }\n\n    return {\n      date,\n      isLocalTime,\n    };\n  }\n\n  /**\n   * Checks if a ISO8601 formatted date contains a timezone component\n   * @param pushTimeParam {string}\n   * @returns {boolean}\n   */\n  static pushTimeHasTimezoneComponent(pushTimeParam: string): boolean {\n    const offsetPattern = /(.+)([+-])\\d\\d:\\d\\d$/;\n    return (\n      pushTimeParam.indexOf('Z') === pushTimeParam.length - 1 || offsetPattern.test(pushTimeParam) // 2007-04-05T12:30Z\n    ); // 2007-04-05T12:30.000+02:00, 2007-04-05T12:30.000-02:00\n  }\n\n  /**\n   * Converts a date to ISO format in UTC time and strips the timezone if `isLocalTime` is true\n   * @param date {Date}\n   * @param isLocalTime {boolean}\n   * @returns {string}\n   */\n  static formatPushTime({ date, isLocalTime }: { date: Date, isLocalTime: boolean }) {\n    if (isLocalTime) {\n      // Strip 'Z'\n      const isoString = date.toISOString();\n      return isoString.substring(0, isoString.indexOf('Z'));\n    }\n    return date.toISOString();\n  }\n}\n\nexport default PushController;\n"],"file":"PushController.js"}