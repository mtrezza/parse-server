{"version":3,"sources":["../../src/Controllers/SchemaController.js"],"names":["Parse","require","defaultColumns","Object","freeze","_Default","objectId","type","createdAt","updatedAt","ACL","_User","username","password","email","emailVerified","authData","_Installation","installationId","deviceToken","channels","deviceType","pushType","GCMSenderId","timeZone","localeIdentifier","badge","appVersion","appName","appIdentifier","parseVersion","_Role","name","users","targetClass","roles","_Session","restricted","user","sessionToken","expiresAt","createdWith","_Product","productIdentifier","download","downloadName","icon","order","title","subtitle","_PushStatus","pushTime","source","query","payload","expiry","expiration_interval","status","numSent","numFailed","pushHash","errorMessage","sentPerType","failedPerType","sentPerUTCOffset","failedPerUTCOffset","count","_JobStatus","jobName","message","params","finishedAt","_JobSchedule","description","startAfter","daysOfWeek","timeOfDay","lastRun","repeatMinutes","_Hooks","functionName","className","triggerName","url","_GlobalConfig","masterKeyOnly","_GraphQLConfig","config","_Audience","lastUsed","timesUsed","_Idempotency","reqId","expire","requiredColumns","invalidColumns","systemClasses","volatileClasses","roleRegex","protectedFieldsPointerRegex","publicRegex","authenticatedRegex","requiresAuthenticationRegex","clpPointerRegex","protectedFieldsRegex","clpFieldsRegex","validatePermissionKey","key","userIdRegExp","matchesSome","regEx","match","valid","Error","INVALID_JSON","validateProtectedFieldsKey","CLPValidKeys","validateCLP","perms","fields","operationKey","indexOf","operation","validateCLPjson","fieldName","validatePointerPermission","entity","protectedFields","Array","isArray","field","prototype","hasOwnProperty","call","pointerFields","pointerField","permit","joinClassRegex","classAndFieldRegex","classNameIsValid","test","fieldNameIsValid","includes","fieldNameIsValidForClass","invalidClassNameMessage","invalidJsonError","validNonRelationOrPointerTypes","fieldTypeIsInvalid","INVALID_CLASS_NAME","undefined","INCORRECT_TYPE","convertSchemaToAdapterSchema","schema","injectDefaultSchema","_rperm","_wperm","_hashed_password","convertAdapterSchemaToParseSchema","indexes","keys","length","SchemaData","constructor","allSchemas","__data","__protectedFields","forEach","defineProperty","get","data","classLevelPermissions","classProtectedFields","unq","Set","from","defaultSchema","_HooksSchema","_GlobalConfigSchema","_GraphQLConfigSchema","_PushStatusSchema","_JobStatusSchema","_JobScheduleSchema","_AudienceSchema","_IdempotencySchema","VolatileClassesSchemas","dbTypeMatchesObjectType","dbType","objectType","typeToString","SchemaController","databaseAdapter","schemaCache","_dbAdapter","_cache","schemaData","Config","applicationId","customIds","allowCustomObjectId","customIdRegEx","autoIdRegEx","userIdRegEx","reloadData","options","clearCache","reloadDataPromise","getAllClasses","then","err","setAllClasses","allClasses","Promise","resolve","map","catch","error","console","getOneSchema","allowVolatileClasses","promise","clear","cached","oneSchema","find","reject","addClassIfNotExists","validationError","validateNewClass","code","createClass","DUPLICATE_VALUE","updateClass","submittedFields","database","existingFields","__op","newSchema","buildMergedSchemaObject","defaultFields","fullNewSchema","assign","validateSchemaData","deletedFields","insertedFields","push","deletePromise","deleteFields","enforceFields","promises","enforceFieldExists","all","results","filter","result","setPermissions","setIndexesWithSchemaFormat","ensureFields","reloadedSchema","enforceClassExists","existingFieldNames","INVALID_KEY_NAME","fieldType","defaultValue","defaultValueType","getType","required","geoPoints","setClassLevelPermissions","split","expectedType","getExpectedType","addFieldIfNotExists","i","deleteField","fieldNames","schemaFields","adapter","deleteClass","validateObject","object","geocount","expected","thenValidateRequiredColumns","validateRequiredColumns","columns","missingColumns","column","testPermissionsForClassName","aclGroup","testPermissions","getClassLevelPermissions","classPermissions","some","acl","validatePermission","action","OBJECT_NOT_FOUND","permissionField","OPERATION_FORBIDDEN","hasClass","load","dbAdapter","putRequest","sysSchemaField","_id","oldField","fieldIsDeleted","newField","schemaPromise","obj","getObjectType","__type","iso","latitude","longitude","base64","coordinates","objects","ops"],"mappings":"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","sourcesContent":["// @flow\n// This class handles schema validation, persistence, and modification.\n//\n// Each individual Schema object should be immutable. The helpers to\n// do things with the Schema just return a new schema when the schema\n// is changed.\n//\n// The canonical place to store this Schema is in the database itself,\n// in a _SCHEMA collection. This is not the right way to do it for an\n// open source framework, but it's backward compatible, so we're\n// keeping it this way for now.\n//\n// In API-handling code, you should only use the Schema class via the\n// DatabaseController. This will let us replace the schema logic for\n// different databases.\n// TODO: hide all schema logic inside the database adapter.\n// @flow-disable-next\nconst Parse = require('parse/node').Parse;\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport DatabaseController from './DatabaseController';\nimport Config from '../Config';\n// @flow-disable-next\nimport deepcopy from 'deepcopy';\nimport type {\n  Schema,\n  SchemaFields,\n  ClassLevelPermissions,\n  SchemaField,\n  LoadSchemaOptions,\n} from './types';\n\nconst defaultColumns: { [string]: SchemaFields } = Object.freeze({\n  // Contain the default columns for every parse object type (except _Join collection)\n  _Default: {\n    objectId: { type: 'String' },\n    createdAt: { type: 'Date' },\n    updatedAt: { type: 'Date' },\n    ACL: { type: 'ACL' },\n  },\n  // The additional default columns for the _User collection (in addition to DefaultCols)\n  _User: {\n    username: { type: 'String' },\n    password: { type: 'String' },\n    email: { type: 'String' },\n    emailVerified: { type: 'Boolean' },\n    authData: { type: 'Object' },\n  },\n  // The additional default columns for the _Installation collection (in addition to DefaultCols)\n  _Installation: {\n    installationId: { type: 'String' },\n    deviceToken: { type: 'String' },\n    channels: { type: 'Array' },\n    deviceType: { type: 'String' },\n    pushType: { type: 'String' },\n    GCMSenderId: { type: 'String' },\n    timeZone: { type: 'String' },\n    localeIdentifier: { type: 'String' },\n    badge: { type: 'Number' },\n    appVersion: { type: 'String' },\n    appName: { type: 'String' },\n    appIdentifier: { type: 'String' },\n    parseVersion: { type: 'String' },\n  },\n  // The additional default columns for the _Role collection (in addition to DefaultCols)\n  _Role: {\n    name: { type: 'String' },\n    users: { type: 'Relation', targetClass: '_User' },\n    roles: { type: 'Relation', targetClass: '_Role' },\n  },\n  // The additional default columns for the _Session collection (in addition to DefaultCols)\n  _Session: {\n    restricted: { type: 'Boolean' },\n    user: { type: 'Pointer', targetClass: '_User' },\n    installationId: { type: 'String' },\n    sessionToken: { type: 'String' },\n    expiresAt: { type: 'Date' },\n    createdWith: { type: 'Object' },\n  },\n  _Product: {\n    productIdentifier: { type: 'String' },\n    download: { type: 'File' },\n    downloadName: { type: 'String' },\n    icon: { type: 'File' },\n    order: { type: 'Number' },\n    title: { type: 'String' },\n    subtitle: { type: 'String' },\n  },\n  _PushStatus: {\n    pushTime: { type: 'String' },\n    source: { type: 'String' }, // rest or webui\n    query: { type: 'String' }, // the stringified JSON query\n    payload: { type: 'String' }, // the stringified JSON payload,\n    title: { type: 'String' },\n    expiry: { type: 'Number' },\n    expiration_interval: { type: 'Number' },\n    status: { type: 'String' },\n    numSent: { type: 'Number' },\n    numFailed: { type: 'Number' },\n    pushHash: { type: 'String' },\n    errorMessage: { type: 'Object' },\n    sentPerType: { type: 'Object' },\n    failedPerType: { type: 'Object' },\n    sentPerUTCOffset: { type: 'Object' },\n    failedPerUTCOffset: { type: 'Object' },\n    count: { type: 'Number' }, // tracks # of batches queued and pending\n  },\n  _JobStatus: {\n    jobName: { type: 'String' },\n    source: { type: 'String' },\n    status: { type: 'String' },\n    message: { type: 'String' },\n    params: { type: 'Object' }, // params received when calling the job\n    finishedAt: { type: 'Date' },\n  },\n  _JobSchedule: {\n    jobName: { type: 'String' },\n    description: { type: 'String' },\n    params: { type: 'String' },\n    startAfter: { type: 'String' },\n    daysOfWeek: { type: 'Array' },\n    timeOfDay: { type: 'String' },\n    lastRun: { type: 'Number' },\n    repeatMinutes: { type: 'Number' },\n  },\n  _Hooks: {\n    functionName: { type: 'String' },\n    className: { type: 'String' },\n    triggerName: { type: 'String' },\n    url: { type: 'String' },\n  },\n  _GlobalConfig: {\n    objectId: { type: 'String' },\n    params: { type: 'Object' },\n    masterKeyOnly: { type: 'Object' },\n  },\n  _GraphQLConfig: {\n    objectId: { type: 'String' },\n    config: { type: 'Object' },\n  },\n  _Audience: {\n    objectId: { type: 'String' },\n    name: { type: 'String' },\n    query: { type: 'String' }, //storing query as JSON string to prevent \"Nested keys should not contain the '$' or '.' characters\" error\n    lastUsed: { type: 'Date' },\n    timesUsed: { type: 'Number' },\n  },\n  _Idempotency: {\n    reqId: { type: 'String' },\n    expire: { type: 'Date' },\n  },\n});\n\nconst requiredColumns = Object.freeze({\n  _Product: ['productIdentifier', 'icon', 'order', 'title', 'subtitle'],\n  _Role: ['name', 'ACL'],\n});\n\nconst invalidColumns = ['length'];\n\nconst systemClasses = Object.freeze([\n  '_User',\n  '_Installation',\n  '_Role',\n  '_Session',\n  '_Product',\n  '_PushStatus',\n  '_JobStatus',\n  '_JobSchedule',\n  '_Audience',\n  '_Idempotency',\n]);\n\nconst volatileClasses = Object.freeze([\n  '_JobStatus',\n  '_PushStatus',\n  '_Hooks',\n  '_GlobalConfig',\n  '_GraphQLConfig',\n  '_JobSchedule',\n  '_Audience',\n  '_Idempotency',\n]);\n\n// Anything that start with role\nconst roleRegex = /^role:.*/;\n// Anything that starts with userField (allowed for protected fields only)\nconst protectedFieldsPointerRegex = /^userField:.*/;\n// * permission\nconst publicRegex = /^\\*$/;\n\nconst authenticatedRegex = /^authenticated$/;\n\nconst requiresAuthenticationRegex = /^requiresAuthentication$/;\n\nconst clpPointerRegex = /^pointerFields$/;\n\n// regex for validating entities in protectedFields object\nconst protectedFieldsRegex = Object.freeze([\n  protectedFieldsPointerRegex,\n  publicRegex,\n  authenticatedRegex,\n  roleRegex,\n]);\n\n// clp regex\nconst clpFieldsRegex = Object.freeze([\n  clpPointerRegex,\n  publicRegex,\n  requiresAuthenticationRegex,\n  roleRegex,\n]);\n\nfunction validatePermissionKey(key, userIdRegExp) {\n  let matchesSome = false;\n  for (const regEx of clpFieldsRegex) {\n    if (key.match(regEx) !== null) {\n      matchesSome = true;\n      break;\n    }\n  }\n\n  // userId depends on startup options so it's dynamic\n  const valid = matchesSome || key.match(userIdRegExp) !== null;\n  if (!valid) {\n    throw new Parse.Error(\n      Parse.Error.INVALID_JSON,\n      `'${key}' is not a valid key for class level permissions`\n    );\n  }\n}\n\nfunction validateProtectedFieldsKey(key, userIdRegExp) {\n  let matchesSome = false;\n  for (const regEx of protectedFieldsRegex) {\n    if (key.match(regEx) !== null) {\n      matchesSome = true;\n      break;\n    }\n  }\n\n  // userId regex depends on launch options so it's dynamic\n  const valid = matchesSome || key.match(userIdRegExp) !== null;\n  if (!valid) {\n    throw new Parse.Error(\n      Parse.Error.INVALID_JSON,\n      `'${key}' is not a valid key for class level permissions`\n    );\n  }\n}\n\nconst CLPValidKeys = Object.freeze([\n  'find',\n  'count',\n  'get',\n  'create',\n  'update',\n  'delete',\n  'addField',\n  'readUserFields',\n  'writeUserFields',\n  'protectedFields',\n]);\n\n// validation before setting class-level permissions on collection\nfunction validateCLP(perms: ClassLevelPermissions, fields: SchemaFields, userIdRegExp: RegExp) {\n  if (!perms) {\n    return;\n  }\n  for (const operationKey in perms) {\n    if (CLPValidKeys.indexOf(operationKey) == -1) {\n      throw new Parse.Error(\n        Parse.Error.INVALID_JSON,\n        `${operationKey} is not a valid operation for class level permissions`\n      );\n    }\n\n    const operation = perms[operationKey];\n    // proceed with next operationKey\n\n    // throws when root fields are of wrong type\n    validateCLPjson(operation, operationKey);\n\n    if (operationKey === 'readUserFields' || operationKey === 'writeUserFields') {\n      // validate grouped pointer permissions\n      // must be an array with field names\n      for (const fieldName of operation) {\n        validatePointerPermission(fieldName, fields, operationKey);\n      }\n      // readUserFields and writerUserFields do not have nesdted fields\n      // proceed with next operationKey\n      continue;\n    }\n\n    // validate protected fields\n    if (operationKey === 'protectedFields') {\n      for (const entity in operation) {\n        // throws on unexpected key\n        validateProtectedFieldsKey(entity, userIdRegExp);\n\n        const protectedFields = operation[entity];\n\n        if (!Array.isArray(protectedFields)) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_JSON,\n            `'${protectedFields}' is not a valid value for protectedFields[${entity}] - expected an array.`\n          );\n        }\n\n        // if the field is in form of array\n        for (const field of protectedFields) {\n          // do not alloow to protect default fields\n          if (defaultColumns._Default[field]) {\n            throw new Parse.Error(\n              Parse.Error.INVALID_JSON,\n              `Default field '${field}' can not be protected`\n            );\n          }\n          // field should exist on collection\n          if (!Object.prototype.hasOwnProperty.call(fields, field)) {\n            throw new Parse.Error(\n              Parse.Error.INVALID_JSON,\n              `Field '${field}' in protectedFields:${entity} does not exist`\n            );\n          }\n        }\n      }\n      // proceed with next operationKey\n      continue;\n    }\n\n    // validate other fields\n    // Entity can be:\n    // \"*\" - Public,\n    // \"requiresAuthentication\" - authenticated users,\n    // \"objectId\" - _User id,\n    // \"role:rolename\",\n    // \"pointerFields\" - array of field names containing pointers to users\n    for (const entity in operation) {\n      // throws on unexpected key\n      validatePermissionKey(entity, userIdRegExp);\n\n      // entity can be either:\n      // \"pointerFields\": string[]\n      if (entity === 'pointerFields') {\n        const pointerFields = operation[entity];\n\n        if (Array.isArray(pointerFields)) {\n          for (const pointerField of pointerFields) {\n            validatePointerPermission(pointerField, fields, operation);\n          }\n        } else {\n          throw new Parse.Error(\n            Parse.Error.INVALID_JSON,\n            `'${pointerFields}' is not a valid value for ${operationKey}[${entity}] - expected an array.`\n          );\n        }\n        // proceed with next entity key\n        continue;\n      }\n\n      // or [entity]: boolean\n      const permit = operation[entity];\n\n      if (permit !== true) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `'${permit}' is not a valid value for class level permissions ${operationKey}:${entity}:${permit}`\n        );\n      }\n    }\n  }\n}\n\nfunction validateCLPjson(operation: any, operationKey: string) {\n  if (operationKey === 'readUserFields' || operationKey === 'writeUserFields') {\n    if (!Array.isArray(operation)) {\n      throw new Parse.Error(\n        Parse.Error.INVALID_JSON,\n        `'${operation}' is not a valid value for class level permissions ${operationKey} - must be an array`\n      );\n    }\n  } else {\n    if (typeof operation === 'object' && operation !== null) {\n      // ok to proceed\n      return;\n    } else {\n      throw new Parse.Error(\n        Parse.Error.INVALID_JSON,\n        `'${operation}' is not a valid value for class level permissions ${operationKey} - must be an object`\n      );\n    }\n  }\n}\n\nfunction validatePointerPermission(fieldName: string, fields: Object, operation: string) {\n  // Uses collection schema to ensure the field is of type:\n  // - Pointer<_User> (pointers)\n  // - Array\n  //\n  //    It's not possible to enforce type on Array's items in schema\n  //  so we accept any Array field, and later when applying permissions\n  //  only items that are pointers to _User are considered.\n  if (\n    !(\n      fields[fieldName] &&\n      ((fields[fieldName].type == 'Pointer' && fields[fieldName].targetClass == '_User') ||\n        fields[fieldName].type == 'Array')\n    )\n  ) {\n    throw new Parse.Error(\n      Parse.Error.INVALID_JSON,\n      `'${fieldName}' is not a valid column for class level pointer permissions ${operation}`\n    );\n  }\n}\n\nconst joinClassRegex = /^_Join:[A-Za-z0-9_]+:[A-Za-z0-9_]+/;\nconst classAndFieldRegex = /^[A-Za-z][A-Za-z0-9_]*$/;\nfunction classNameIsValid(className: string): boolean {\n  // Valid classes must:\n  return (\n    // Be one of _User, _Installation, _Role, _Session OR\n    systemClasses.indexOf(className) > -1 ||\n    // Be a join table OR\n    joinClassRegex.test(className) ||\n    // Include only alpha-numeric and underscores, and not start with an underscore or number\n    fieldNameIsValid(className, className)\n  );\n}\n\n// Valid fields must be alpha-numeric, and not start with an underscore or number\n// must not be a reserved key\nfunction fieldNameIsValid(fieldName: string, className: string): boolean {\n  if (className && className !== '_Hooks') {\n    if (fieldName === 'className') {\n      return false;\n    }\n  }\n  return classAndFieldRegex.test(fieldName) && !invalidColumns.includes(fieldName);\n}\n\n// Checks that it's not trying to clobber one of the default fields of the class.\nfunction fieldNameIsValidForClass(fieldName: string, className: string): boolean {\n  if (!fieldNameIsValid(fieldName, className)) {\n    return false;\n  }\n  if (defaultColumns._Default[fieldName]) {\n    return false;\n  }\n  if (defaultColumns[className] && defaultColumns[className][fieldName]) {\n    return false;\n  }\n  return true;\n}\n\nfunction invalidClassNameMessage(className: string): string {\n  return (\n    'Invalid classname: ' +\n    className +\n    ', classnames can only have alphanumeric characters and _, and must start with an alpha character '\n  );\n}\n\nconst invalidJsonError = new Parse.Error(Parse.Error.INVALID_JSON, 'invalid JSON');\nconst validNonRelationOrPointerTypes = [\n  'Number',\n  'String',\n  'Boolean',\n  'Date',\n  'Object',\n  'Array',\n  'GeoPoint',\n  'File',\n  'Bytes',\n  'Polygon',\n];\n// Returns an error suitable for throwing if the type is invalid\nconst fieldTypeIsInvalid = ({ type, targetClass }) => {\n  if (['Pointer', 'Relation'].indexOf(type) >= 0) {\n    if (!targetClass) {\n      return new Parse.Error(135, `type ${type} needs a class name`);\n    } else if (typeof targetClass !== 'string') {\n      return invalidJsonError;\n    } else if (!classNameIsValid(targetClass)) {\n      return new Parse.Error(Parse.Error.INVALID_CLASS_NAME, invalidClassNameMessage(targetClass));\n    } else {\n      return undefined;\n    }\n  }\n  if (typeof type !== 'string') {\n    return invalidJsonError;\n  }\n  if (validNonRelationOrPointerTypes.indexOf(type) < 0) {\n    return new Parse.Error(Parse.Error.INCORRECT_TYPE, `invalid field type: ${type}`);\n  }\n  return undefined;\n};\n\nconst convertSchemaToAdapterSchema = (schema: any) => {\n  schema = injectDefaultSchema(schema);\n  delete schema.fields.ACL;\n  schema.fields._rperm = { type: 'Array' };\n  schema.fields._wperm = { type: 'Array' };\n\n  if (schema.className === '_User') {\n    delete schema.fields.password;\n    schema.fields._hashed_password = { type: 'String' };\n  }\n\n  return schema;\n};\n\nconst convertAdapterSchemaToParseSchema = ({ ...schema }) => {\n  delete schema.fields._rperm;\n  delete schema.fields._wperm;\n\n  schema.fields.ACL = { type: 'ACL' };\n\n  if (schema.className === '_User') {\n    delete schema.fields.authData; //Auth data is implicit\n    delete schema.fields._hashed_password;\n    schema.fields.password = { type: 'String' };\n  }\n\n  if (schema.indexes && Object.keys(schema.indexes).length === 0) {\n    delete schema.indexes;\n  }\n\n  return schema;\n};\n\nclass SchemaData {\n  __data: any;\n  __protectedFields: any;\n  constructor(allSchemas = [], protectedFields = {}) {\n    this.__data = {};\n    this.__protectedFields = protectedFields;\n    allSchemas.forEach(schema => {\n      if (volatileClasses.includes(schema.className)) {\n        return;\n      }\n      Object.defineProperty(this, schema.className, {\n        get: () => {\n          if (!this.__data[schema.className]) {\n            const data = {};\n            data.fields = injectDefaultSchema(schema).fields;\n            data.classLevelPermissions = deepcopy(schema.classLevelPermissions);\n            data.indexes = schema.indexes;\n\n            const classProtectedFields = this.__protectedFields[schema.className];\n            if (classProtectedFields) {\n              for (const key in classProtectedFields) {\n                const unq = new Set([\n                  ...(data.classLevelPermissions.protectedFields[key] || []),\n                  ...classProtectedFields[key],\n                ]);\n                data.classLevelPermissions.protectedFields[key] = Array.from(unq);\n              }\n            }\n\n            this.__data[schema.className] = data;\n          }\n          return this.__data[schema.className];\n        },\n      });\n    });\n\n    // Inject the in-memory classes\n    volatileClasses.forEach(className => {\n      Object.defineProperty(this, className, {\n        get: () => {\n          if (!this.__data[className]) {\n            const schema = injectDefaultSchema({\n              className,\n              fields: {},\n              classLevelPermissions: {},\n            });\n            const data = {};\n            data.fields = schema.fields;\n            data.classLevelPermissions = schema.classLevelPermissions;\n            data.indexes = schema.indexes;\n            this.__data[className] = data;\n          }\n          return this.__data[className];\n        },\n      });\n    });\n  }\n}\n\nconst injectDefaultSchema = ({ className, fields, classLevelPermissions, indexes }: Schema) => {\n  const defaultSchema: Schema = {\n    className,\n    fields: {\n      ...defaultColumns._Default,\n      ...(defaultColumns[className] || {}),\n      ...fields,\n    },\n    classLevelPermissions,\n  };\n  if (indexes && Object.keys(indexes).length !== 0) {\n    defaultSchema.indexes = indexes;\n  }\n  return defaultSchema;\n};\n\nconst _HooksSchema = { className: '_Hooks', fields: defaultColumns._Hooks };\nconst _GlobalConfigSchema = {\n  className: '_GlobalConfig',\n  fields: defaultColumns._GlobalConfig,\n};\nconst _GraphQLConfigSchema = {\n  className: '_GraphQLConfig',\n  fields: defaultColumns._GraphQLConfig,\n};\nconst _PushStatusSchema = convertSchemaToAdapterSchema(\n  injectDefaultSchema({\n    className: '_PushStatus',\n    fields: {},\n    classLevelPermissions: {},\n  })\n);\nconst _JobStatusSchema = convertSchemaToAdapterSchema(\n  injectDefaultSchema({\n    className: '_JobStatus',\n    fields: {},\n    classLevelPermissions: {},\n  })\n);\nconst _JobScheduleSchema = convertSchemaToAdapterSchema(\n  injectDefaultSchema({\n    className: '_JobSchedule',\n    fields: {},\n    classLevelPermissions: {},\n  })\n);\nconst _AudienceSchema = convertSchemaToAdapterSchema(\n  injectDefaultSchema({\n    className: '_Audience',\n    fields: defaultColumns._Audience,\n    classLevelPermissions: {},\n  })\n);\nconst _IdempotencySchema = convertSchemaToAdapterSchema(\n  injectDefaultSchema({\n    className: '_Idempotency',\n    fields: defaultColumns._Idempotency,\n    classLevelPermissions: {},\n  })\n);\nconst VolatileClassesSchemas = [\n  _HooksSchema,\n  _JobStatusSchema,\n  _JobScheduleSchema,\n  _PushStatusSchema,\n  _GlobalConfigSchema,\n  _GraphQLConfigSchema,\n  _AudienceSchema,\n  _IdempotencySchema,\n];\n\nconst dbTypeMatchesObjectType = (dbType: SchemaField | string, objectType: SchemaField) => {\n  if (dbType.type !== objectType.type) return false;\n  if (dbType.targetClass !== objectType.targetClass) return false;\n  if (dbType === objectType.type) return true;\n  if (dbType.type === objectType.type) return true;\n  return false;\n};\n\nconst typeToString = (type: SchemaField | string): string => {\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (type.targetClass) {\n    return `${type.type}<${type.targetClass}>`;\n  }\n  return `${type.type}`;\n};\n\n// Stores the entire schema of the app in a weird hybrid format somewhere between\n// the mongo format and the Parse format. Soon, this will all be Parse format.\nexport default class SchemaController {\n  _dbAdapter: StorageAdapter;\n  schemaData: { [string]: Schema };\n  _cache: any;\n  reloadDataPromise: ?Promise<any>;\n  protectedFields: any;\n  userIdRegEx: RegExp;\n\n  constructor(databaseAdapter: StorageAdapter, schemaCache: any) {\n    this._dbAdapter = databaseAdapter;\n    this._cache = schemaCache;\n    this.schemaData = new SchemaData();\n    this.protectedFields = Config.get(Parse.applicationId).protectedFields;\n\n    const customIds = Config.get(Parse.applicationId).allowCustomObjectId;\n\n    const customIdRegEx = /^.{1,}$/u; // 1+ chars\n    const autoIdRegEx = /^[a-zA-Z0-9]{1,}$/;\n\n    this.userIdRegEx = customIds ? customIdRegEx : autoIdRegEx;\n  }\n\n  reloadData(options: LoadSchemaOptions = { clearCache: false }): Promise<any> {\n    if (this.reloadDataPromise && !options.clearCache) {\n      return this.reloadDataPromise;\n    }\n    this.reloadDataPromise = this.getAllClasses(options)\n      .then(\n        allSchemas => {\n          this.schemaData = new SchemaData(allSchemas, this.protectedFields);\n          delete this.reloadDataPromise;\n        },\n        err => {\n          this.schemaData = new SchemaData();\n          delete this.reloadDataPromise;\n          throw err;\n        }\n      )\n      .then(() => {});\n    return this.reloadDataPromise;\n  }\n\n  getAllClasses(options: LoadSchemaOptions = { clearCache: false }): Promise<Array<Schema>> {\n    if (options.clearCache) {\n      return this.setAllClasses();\n    }\n    return this._cache.getAllClasses().then(allClasses => {\n      if (allClasses && allClasses.length) {\n        return Promise.resolve(allClasses);\n      }\n      return this.setAllClasses();\n    });\n  }\n\n  setAllClasses(): Promise<Array<Schema>> {\n    return this._dbAdapter\n      .getAllClasses()\n      .then(allSchemas => allSchemas.map(injectDefaultSchema))\n      .then(allSchemas => {\n        /* eslint-disable no-console */\n        this._cache\n          .setAllClasses(allSchemas)\n          .catch(error => console.error('Error saving schema to cache:', error));\n        /* eslint-enable no-console */\n        return allSchemas;\n      });\n  }\n\n  getOneSchema(\n    className: string,\n    allowVolatileClasses: boolean = false,\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<Schema> {\n    let promise = Promise.resolve();\n    if (options.clearCache) {\n      promise = this._cache.clear();\n    }\n    return promise.then(() => {\n      if (allowVolatileClasses && volatileClasses.indexOf(className) > -1) {\n        const data = this.schemaData[className];\n        return Promise.resolve({\n          className,\n          fields: data.fields,\n          classLevelPermissions: data.classLevelPermissions,\n          indexes: data.indexes,\n        });\n      }\n      return this._cache.getOneSchema(className).then(cached => {\n        if (cached && !options.clearCache) {\n          return Promise.resolve(cached);\n        }\n        return this.setAllClasses().then(allSchemas => {\n          const oneSchema = allSchemas.find(schema => schema.className === className);\n          if (!oneSchema) {\n            return Promise.reject(undefined);\n          }\n          return oneSchema;\n        });\n      });\n    });\n  }\n\n  // Create a new class that includes the three default fields.\n  // ACL is an implicit column that does not get an entry in the\n  // _SCHEMAS database. Returns a promise that resolves with the\n  // created schema, in mongo format.\n  // on success, and rejects with an error on fail. Ensure you\n  // have authorization (master key, or client class creation\n  // enabled) before calling this function.\n  addClassIfNotExists(\n    className: string,\n    fields: SchemaFields = {},\n    classLevelPermissions: any,\n    indexes: any = {}\n  ): Promise<void | Schema> {\n    var validationError = this.validateNewClass(className, fields, classLevelPermissions);\n    if (validationError) {\n      if (validationError instanceof Parse.Error) {\n        return Promise.reject(validationError);\n      } else if (validationError.code && validationError.error) {\n        return Promise.reject(new Parse.Error(validationError.code, validationError.error));\n      }\n      return Promise.reject(validationError);\n    }\n\n    return this._dbAdapter\n      .createClass(\n        className,\n        convertSchemaToAdapterSchema({\n          fields,\n          classLevelPermissions,\n          indexes,\n          className,\n        })\n      )\n      .then(convertAdapterSchemaToParseSchema)\n      .catch(error => {\n        if (error && error.code === Parse.Error.DUPLICATE_VALUE) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_CLASS_NAME,\n            `Class ${className} already exists.`\n          );\n        } else {\n          throw error;\n        }\n      });\n  }\n\n  updateClass(\n    className: string,\n    submittedFields: SchemaFields,\n    classLevelPermissions: any,\n    indexes: any,\n    database: DatabaseController\n  ) {\n    return this.getOneSchema(className)\n      .then(schema => {\n        const existingFields = schema.fields;\n        Object.keys(submittedFields).forEach(name => {\n          const field = submittedFields[name];\n          if (existingFields[name] && field.__op !== 'Delete') {\n            throw new Parse.Error(255, `Field ${name} exists, cannot update.`);\n          }\n          if (!existingFields[name] && field.__op === 'Delete') {\n            throw new Parse.Error(255, `Field ${name} does not exist, cannot delete.`);\n          }\n        });\n\n        delete existingFields._rperm;\n        delete existingFields._wperm;\n        const newSchema = buildMergedSchemaObject(existingFields, submittedFields);\n        const defaultFields = defaultColumns[className] || defaultColumns._Default;\n        const fullNewSchema = Object.assign({}, newSchema, defaultFields);\n        const validationError = this.validateSchemaData(\n          className,\n          newSchema,\n          classLevelPermissions,\n          Object.keys(existingFields)\n        );\n        if (validationError) {\n          throw new Parse.Error(validationError.code, validationError.error);\n        }\n\n        // Finally we have checked to make sure the request is valid and we can start deleting fields.\n        // Do all deletions first, then a single save to _SCHEMA collection to handle all additions.\n        const deletedFields: string[] = [];\n        const insertedFields = [];\n        Object.keys(submittedFields).forEach(fieldName => {\n          if (submittedFields[fieldName].__op === 'Delete') {\n            deletedFields.push(fieldName);\n          } else {\n            insertedFields.push(fieldName);\n          }\n        });\n\n        let deletePromise = Promise.resolve();\n        if (deletedFields.length > 0) {\n          deletePromise = this.deleteFields(deletedFields, className, database);\n        }\n        let enforceFields = [];\n        return (\n          deletePromise // Delete Everything\n            .then(() => this.reloadData({ clearCache: true })) // Reload our Schema, so we have all the new values\n            .then(() => {\n              const promises = insertedFields.map(fieldName => {\n                const type = submittedFields[fieldName];\n                return this.enforceFieldExists(className, fieldName, type);\n              });\n              return Promise.all(promises);\n            })\n            .then(results => {\n              enforceFields = results.filter(result => !!result);\n              return this.setPermissions(className, classLevelPermissions, newSchema);\n            })\n            .then(() =>\n              this._dbAdapter.setIndexesWithSchemaFormat(\n                className,\n                indexes,\n                schema.indexes,\n                fullNewSchema\n              )\n            )\n            .then(() => this.reloadData({ clearCache: true }))\n            //TODO: Move this logic into the database adapter\n            .then(() => {\n              this.ensureFields(enforceFields);\n              const schema = this.schemaData[className];\n              const reloadedSchema: Schema = {\n                className: className,\n                fields: schema.fields,\n                classLevelPermissions: schema.classLevelPermissions,\n              };\n              if (schema.indexes && Object.keys(schema.indexes).length !== 0) {\n                reloadedSchema.indexes = schema.indexes;\n              }\n              return reloadedSchema;\n            })\n        );\n      })\n      .catch(error => {\n        if (error === undefined) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_CLASS_NAME,\n            `Class ${className} does not exist.`\n          );\n        } else {\n          throw error;\n        }\n      });\n  }\n\n  // Returns a promise that resolves successfully to the new schema\n  // object or fails with a reason.\n  enforceClassExists(className: string): Promise<SchemaController> {\n    if (this.schemaData[className]) {\n      return Promise.resolve(this);\n    }\n    // We don't have this class. Update the schema\n    return (\n      this.addClassIfNotExists(className)\n        // The schema update succeeded. Reload the schema\n        .then(() => this.reloadData({ clearCache: true }))\n        .catch(() => {\n          // The schema update failed. This can be okay - it might\n          // have failed because there's a race condition and a different\n          // client is making the exact same schema update that we want.\n          // So just reload the schema.\n          return this.reloadData({ clearCache: true });\n        })\n        .then(() => {\n          // Ensure that the schema now validates\n          if (this.schemaData[className]) {\n            return this;\n          } else {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, `Failed to add ${className}`);\n          }\n        })\n        .catch(() => {\n          // The schema still doesn't validate. Give up\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'schema class name does not revalidate');\n        })\n    );\n  }\n\n  validateNewClass(className: string, fields: SchemaFields = {}, classLevelPermissions: any): any {\n    if (this.schemaData[className]) {\n      throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, `Class ${className} already exists.`);\n    }\n    if (!classNameIsValid(className)) {\n      return {\n        code: Parse.Error.INVALID_CLASS_NAME,\n        error: invalidClassNameMessage(className),\n      };\n    }\n    return this.validateSchemaData(className, fields, classLevelPermissions, []);\n  }\n\n  validateSchemaData(\n    className: string,\n    fields: SchemaFields,\n    classLevelPermissions: ClassLevelPermissions,\n    existingFieldNames: Array<string>\n  ) {\n    for (const fieldName in fields) {\n      if (existingFieldNames.indexOf(fieldName) < 0) {\n        if (!fieldNameIsValid(fieldName, className)) {\n          return {\n            code: Parse.Error.INVALID_KEY_NAME,\n            error: 'invalid field name: ' + fieldName,\n          };\n        }\n        if (!fieldNameIsValidForClass(fieldName, className)) {\n          return {\n            code: 136,\n            error: 'field ' + fieldName + ' cannot be added',\n          };\n        }\n        const fieldType = fields[fieldName];\n        const error = fieldTypeIsInvalid(fieldType);\n        if (error) return { code: error.code, error: error.message };\n        if (fieldType.defaultValue !== undefined) {\n          let defaultValueType = getType(fieldType.defaultValue);\n          if (typeof defaultValueType === 'string') {\n            defaultValueType = { type: defaultValueType };\n          } else if (typeof defaultValueType === 'object' && fieldType.type === 'Relation') {\n            return {\n              code: Parse.Error.INCORRECT_TYPE,\n              error: `The 'default value' option is not applicable for ${typeToString(fieldType)}`,\n            };\n          }\n          if (!dbTypeMatchesObjectType(fieldType, defaultValueType)) {\n            return {\n              code: Parse.Error.INCORRECT_TYPE,\n              error: `schema mismatch for ${className}.${fieldName} default value; expected ${typeToString(\n                fieldType\n              )} but got ${typeToString(defaultValueType)}`,\n            };\n          }\n        } else if (fieldType.required) {\n          if (typeof fieldType === 'object' && fieldType.type === 'Relation') {\n            return {\n              code: Parse.Error.INCORRECT_TYPE,\n              error: `The 'required' option is not applicable for ${typeToString(fieldType)}`,\n            };\n          }\n        }\n      }\n    }\n\n    for (const fieldName in defaultColumns[className]) {\n      fields[fieldName] = defaultColumns[className][fieldName];\n    }\n\n    const geoPoints = Object.keys(fields).filter(\n      key => fields[key] && fields[key].type === 'GeoPoint'\n    );\n    if (geoPoints.length > 1) {\n      return {\n        code: Parse.Error.INCORRECT_TYPE,\n        error:\n          'currently, only one GeoPoint field may exist in an object. Adding ' +\n          geoPoints[1] +\n          ' when ' +\n          geoPoints[0] +\n          ' already exists.',\n      };\n    }\n    validateCLP(classLevelPermissions, fields, this.userIdRegEx);\n  }\n\n  // Sets the Class-level permissions for a given className, which must exist.\n  setPermissions(className: string, perms: any, newSchema: SchemaFields) {\n    if (typeof perms === 'undefined') {\n      return Promise.resolve();\n    }\n    validateCLP(perms, newSchema, this.userIdRegEx);\n    return this._dbAdapter.setClassLevelPermissions(className, perms);\n  }\n\n  // Returns a promise that resolves successfully to the new schema\n  // object if the provided className-fieldName-type tuple is valid.\n  // The className must already be validated.\n  // If 'freeze' is true, refuse to update the schema for this field.\n  enforceFieldExists(className: string, fieldName: string, type: string | SchemaField) {\n    if (fieldName.indexOf('.') > 0) {\n      // subdocument key (x.y) => ok if x is of type 'object'\n      fieldName = fieldName.split('.')[0];\n      type = 'Object';\n    }\n    if (!fieldNameIsValid(fieldName, className)) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid field name: ${fieldName}.`);\n    }\n\n    // If someone tries to create a new field with null/undefined as the value, return;\n    if (!type) {\n      return undefined;\n    }\n\n    const expectedType = this.getExpectedType(className, fieldName);\n    if (typeof type === 'string') {\n      type = ({ type }: SchemaField);\n    }\n\n    if (type.defaultValue !== undefined) {\n      let defaultValueType = getType(type.defaultValue);\n      if (typeof defaultValueType === 'string') {\n        defaultValueType = { type: defaultValueType };\n      }\n      if (!dbTypeMatchesObjectType(type, defaultValueType)) {\n        throw new Parse.Error(\n          Parse.Error.INCORRECT_TYPE,\n          `schema mismatch for ${className}.${fieldName} default value; expected ${typeToString(\n            type\n          )} but got ${typeToString(defaultValueType)}`\n        );\n      }\n    }\n\n    if (expectedType) {\n      if (!dbTypeMatchesObjectType(expectedType, type)) {\n        throw new Parse.Error(\n          Parse.Error.INCORRECT_TYPE,\n          `schema mismatch for ${className}.${fieldName}; expected ${typeToString(\n            expectedType\n          )} but got ${typeToString(type)}`\n        );\n      }\n      return undefined;\n    }\n\n    return this._dbAdapter\n      .addFieldIfNotExists(className, fieldName, type)\n      .catch(error => {\n        if (error.code == Parse.Error.INCORRECT_TYPE) {\n          // Make sure that we throw errors when it is appropriate to do so.\n          throw error;\n        }\n        // The update failed. This can be okay - it might have been a race\n        // condition where another client updated the schema in the same\n        // way that we wanted to. So, just reload the schema\n        return Promise.resolve();\n      })\n      .then(() => {\n        return {\n          className,\n          fieldName,\n          type,\n        };\n      });\n  }\n\n  ensureFields(fields: any) {\n    for (let i = 0; i < fields.length; i += 1) {\n      const { className, fieldName } = fields[i];\n      let { type } = fields[i];\n      const expectedType = this.getExpectedType(className, fieldName);\n      if (typeof type === 'string') {\n        type = { type: type };\n      }\n      if (!expectedType || !dbTypeMatchesObjectType(expectedType, type)) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, `Could not add field ${fieldName}`);\n      }\n    }\n  }\n\n  // maintain compatibility\n  deleteField(fieldName: string, className: string, database: DatabaseController) {\n    return this.deleteFields([fieldName], className, database);\n  }\n\n  // Delete fields, and remove that data from all objects. This is intended\n  // to remove unused fields, if other writers are writing objects that include\n  // this field, the field may reappear. Returns a Promise that resolves with\n  // no object on success, or rejects with { code, error } on failure.\n  // Passing the database and prefix is necessary in order to drop relation collections\n  // and remove fields from objects. Ideally the database would belong to\n  // a database adapter and this function would close over it or access it via member.\n  deleteFields(fieldNames: Array<string>, className: string, database: DatabaseController) {\n    if (!classNameIsValid(className)) {\n      throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, invalidClassNameMessage(className));\n    }\n\n    fieldNames.forEach(fieldName => {\n      if (!fieldNameIsValid(fieldName, className)) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `invalid field name: ${fieldName}`);\n      }\n      //Don't allow deleting the default fields.\n      if (!fieldNameIsValidForClass(fieldName, className)) {\n        throw new Parse.Error(136, `field ${fieldName} cannot be changed`);\n      }\n    });\n\n    return this.getOneSchema(className, false, { clearCache: true })\n      .catch(error => {\n        if (error === undefined) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_CLASS_NAME,\n            `Class ${className} does not exist.`\n          );\n        } else {\n          throw error;\n        }\n      })\n      .then(schema => {\n        fieldNames.forEach(fieldName => {\n          if (!schema.fields[fieldName]) {\n            throw new Parse.Error(255, `Field ${fieldName} does not exist, cannot delete.`);\n          }\n        });\n\n        const schemaFields = { ...schema.fields };\n        return database.adapter.deleteFields(className, schema, fieldNames).then(() => {\n          return Promise.all(\n            fieldNames.map(fieldName => {\n              const field = schemaFields[fieldName];\n              if (field && field.type === 'Relation') {\n                //For relations, drop the _Join table\n                return database.adapter.deleteClass(`_Join:${fieldName}:${className}`);\n              }\n              return Promise.resolve();\n            })\n          );\n        });\n      })\n      .then(() => this._cache.clear());\n  }\n\n  // Validates an object provided in REST format.\n  // Returns a promise that resolves to the new schema if this object is\n  // valid.\n  async validateObject(className: string, object: any, query: any) {\n    let geocount = 0;\n    const schema = await this.enforceClassExists(className);\n    const promises = [];\n\n    for (const fieldName in object) {\n      if (object[fieldName] === undefined) {\n        continue;\n      }\n      const expected = getType(object[fieldName]);\n      if (expected === 'GeoPoint') {\n        geocount++;\n      }\n      if (geocount > 1) {\n        // Make sure all field validation operations run before we return.\n        // If not - we are continuing to run logic, but already provided response from the server.\n        return Promise.reject(\n          new Parse.Error(\n            Parse.Error.INCORRECT_TYPE,\n            'there can only be one geopoint field in a class'\n          )\n        );\n      }\n      if (!expected) {\n        continue;\n      }\n      if (fieldName === 'ACL') {\n        // Every object has ACL implicitly.\n        continue;\n      }\n      promises.push(schema.enforceFieldExists(className, fieldName, expected));\n    }\n    const results = await Promise.all(promises);\n    const enforceFields = results.filter(result => !!result);\n\n    if (enforceFields.length !== 0) {\n      await this.reloadData({ clearCache: true });\n    }\n    this.ensureFields(enforceFields);\n\n    const promise = Promise.resolve(schema);\n    return thenValidateRequiredColumns(promise, className, object, query);\n  }\n\n  // Validates that all the properties are set for the object\n  validateRequiredColumns(className: string, object: any, query: any) {\n    const columns = requiredColumns[className];\n    if (!columns || columns.length == 0) {\n      return Promise.resolve(this);\n    }\n\n    const missingColumns = columns.filter(function (column) {\n      if (query && query.objectId) {\n        if (object[column] && typeof object[column] === 'object') {\n          // Trying to delete a required column\n          return object[column].__op == 'Delete';\n        }\n        // Not trying to do anything there\n        return false;\n      }\n      return !object[column];\n    });\n\n    if (missingColumns.length > 0) {\n      throw new Parse.Error(Parse.Error.INCORRECT_TYPE, missingColumns[0] + ' is required.');\n    }\n    return Promise.resolve(this);\n  }\n\n  testPermissionsForClassName(className: string, aclGroup: string[], operation: string) {\n    return SchemaController.testPermissions(\n      this.getClassLevelPermissions(className),\n      aclGroup,\n      operation\n    );\n  }\n\n  // Tests that the class level permission let pass the operation for a given aclGroup\n  static testPermissions(classPermissions: ?any, aclGroup: string[], operation: string): boolean {\n    if (!classPermissions || !classPermissions[operation]) {\n      return true;\n    }\n    const perms = classPermissions[operation];\n    if (perms['*']) {\n      return true;\n    }\n    // Check permissions against the aclGroup provided (array of userId/roles)\n    if (\n      aclGroup.some(acl => {\n        return perms[acl] === true;\n      })\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  // Validates an operation passes class-level-permissions set in the schema\n  static validatePermission(\n    classPermissions: ?any,\n    className: string,\n    aclGroup: string[],\n    operation: string,\n    action?: string\n  ) {\n    if (SchemaController.testPermissions(classPermissions, aclGroup, operation)) {\n      return Promise.resolve();\n    }\n\n    if (!classPermissions || !classPermissions[operation]) {\n      return true;\n    }\n    const perms = classPermissions[operation];\n    // If only for authenticated users\n    // make sure we have an aclGroup\n    if (perms['requiresAuthentication']) {\n      // If aclGroup has * (public)\n      if (!aclGroup || aclGroup.length == 0) {\n        throw new Parse.Error(\n          Parse.Error.OBJECT_NOT_FOUND,\n          'Permission denied, user needs to be authenticated.'\n        );\n      } else if (aclGroup.indexOf('*') > -1 && aclGroup.length == 1) {\n        throw new Parse.Error(\n          Parse.Error.OBJECT_NOT_FOUND,\n          'Permission denied, user needs to be authenticated.'\n        );\n      }\n      // requiresAuthentication passed, just move forward\n      // probably would be wise at some point to rename to 'authenticatedUser'\n      return Promise.resolve();\n    }\n\n    // No matching CLP, let's check the Pointer permissions\n    // And handle those later\n    const permissionField =\n      ['get', 'find', 'count'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n    // Reject create when write lockdown\n    if (permissionField == 'writeUserFields' && operation == 'create') {\n      throw new Parse.Error(\n        Parse.Error.OPERATION_FORBIDDEN,\n        `Permission denied for action ${operation} on class ${className}.`\n      );\n    }\n\n    // Process the readUserFields later\n    if (\n      Array.isArray(classPermissions[permissionField]) &&\n      classPermissions[permissionField].length > 0\n    ) {\n      return Promise.resolve();\n    }\n\n    const pointerFields = classPermissions[operation].pointerFields;\n    if (Array.isArray(pointerFields) && pointerFields.length > 0) {\n      // any op except 'addField as part of create' is ok.\n      if (operation !== 'addField' || action === 'update') {\n        // We can allow adding field on update flow only.\n        return Promise.resolve();\n      }\n    }\n\n    throw new Parse.Error(\n      Parse.Error.OPERATION_FORBIDDEN,\n      `Permission denied for action ${operation} on class ${className}.`\n    );\n  }\n\n  // Validates an operation passes class-level-permissions set in the schema\n  validatePermission(className: string, aclGroup: string[], operation: string, action?: string) {\n    return SchemaController.validatePermission(\n      this.getClassLevelPermissions(className),\n      className,\n      aclGroup,\n      operation,\n      action\n    );\n  }\n\n  getClassLevelPermissions(className: string): any {\n    return this.schemaData[className] && this.schemaData[className].classLevelPermissions;\n  }\n\n  // Returns the expected type for a className+key combination\n  // or undefined if the schema is not set\n  getExpectedType(className: string, fieldName: string): ?(SchemaField | string) {\n    if (this.schemaData[className]) {\n      const expectedType = this.schemaData[className].fields[fieldName];\n      return expectedType === 'map' ? 'Object' : expectedType;\n    }\n    return undefined;\n  }\n\n  // Checks if a given class is in the schema.\n  hasClass(className: string) {\n    if (this.schemaData[className]) {\n      return Promise.resolve(true);\n    }\n    return this.reloadData().then(() => !!this.schemaData[className]);\n  }\n}\n\n// Returns a promise for a new Schema.\nconst load = (\n  dbAdapter: StorageAdapter,\n  schemaCache: any,\n  options: any\n): Promise<SchemaController> => {\n  const schema = new SchemaController(dbAdapter, schemaCache);\n  return schema.reloadData(options).then(() => schema);\n};\n\n// Builds a new schema (in schema API response format) out of an\n// existing mongo schema + a schemas API put request. This response\n// does not include the default fields, as it is intended to be passed\n// to mongoSchemaFromFieldsAndClassName. No validation is done here, it\n// is done in mongoSchemaFromFieldsAndClassName.\nfunction buildMergedSchemaObject(existingFields: SchemaFields, putRequest: any): SchemaFields {\n  const newSchema = {};\n  // @flow-disable-next\n  const sysSchemaField =\n    Object.keys(defaultColumns).indexOf(existingFields._id) === -1\n      ? []\n      : Object.keys(defaultColumns[existingFields._id]);\n  for (const oldField in existingFields) {\n    if (\n      oldField !== '_id' &&\n      oldField !== 'ACL' &&\n      oldField !== 'updatedAt' &&\n      oldField !== 'createdAt' &&\n      oldField !== 'objectId'\n    ) {\n      if (sysSchemaField.length > 0 && sysSchemaField.indexOf(oldField) !== -1) {\n        continue;\n      }\n      const fieldIsDeleted = putRequest[oldField] && putRequest[oldField].__op === 'Delete';\n      if (!fieldIsDeleted) {\n        newSchema[oldField] = existingFields[oldField];\n      }\n    }\n  }\n  for (const newField in putRequest) {\n    if (newField !== 'objectId' && putRequest[newField].__op !== 'Delete') {\n      if (sysSchemaField.length > 0 && sysSchemaField.indexOf(newField) !== -1) {\n        continue;\n      }\n      newSchema[newField] = putRequest[newField];\n    }\n  }\n  return newSchema;\n}\n\n// Given a schema promise, construct another schema promise that\n// validates this field once the schema loads.\nfunction thenValidateRequiredColumns(schemaPromise, className, object, query) {\n  return schemaPromise.then(schema => {\n    return schema.validateRequiredColumns(className, object, query);\n  });\n}\n\n// Gets the type from a REST API formatted object, where 'type' is\n// extended past javascript types to include the rest of the Parse\n// type system.\n// The output should be a valid schema value.\n// TODO: ensure that this is compatible with the format used in Open DB\nfunction getType(obj: any): ?(SchemaField | string) {\n  const type = typeof obj;\n  switch (type) {\n    case 'boolean':\n      return 'Boolean';\n    case 'string':\n      return 'String';\n    case 'number':\n      return 'Number';\n    case 'map':\n    case 'object':\n      if (!obj) {\n        return undefined;\n      }\n      return getObjectType(obj);\n    case 'function':\n    case 'symbol':\n    case 'undefined':\n    default:\n      throw 'bad obj: ' + obj;\n  }\n}\n\n// This gets the type for non-JSON types like pointers and files, but\n// also gets the appropriate type for $ operators.\n// Returns null if the type is unknown.\nfunction getObjectType(obj): ?(SchemaField | string) {\n  if (obj instanceof Array) {\n    return 'Array';\n  }\n  if (obj.__type) {\n    switch (obj.__type) {\n      case 'Pointer':\n        if (obj.className) {\n          return {\n            type: 'Pointer',\n            targetClass: obj.className,\n          };\n        }\n        break;\n      case 'Relation':\n        if (obj.className) {\n          return {\n            type: 'Relation',\n            targetClass: obj.className,\n          };\n        }\n        break;\n      case 'File':\n        if (obj.name) {\n          return 'File';\n        }\n        break;\n      case 'Date':\n        if (obj.iso) {\n          return 'Date';\n        }\n        break;\n      case 'GeoPoint':\n        if (obj.latitude != null && obj.longitude != null) {\n          return 'GeoPoint';\n        }\n        break;\n      case 'Bytes':\n        if (obj.base64) {\n          return 'Bytes';\n        }\n        break;\n      case 'Polygon':\n        if (obj.coordinates) {\n          return 'Polygon';\n        }\n        break;\n    }\n    throw new Parse.Error(Parse.Error.INCORRECT_TYPE, 'This is not a valid ' + obj.__type);\n  }\n  if (obj['$ne']) {\n    return getObjectType(obj['$ne']);\n  }\n  if (obj.__op) {\n    switch (obj.__op) {\n      case 'Increment':\n        return 'Number';\n      case 'Delete':\n        return null;\n      case 'Add':\n      case 'AddUnique':\n      case 'Remove':\n        return 'Array';\n      case 'AddRelation':\n      case 'RemoveRelation':\n        return {\n          type: 'Relation',\n          targetClass: obj.objects[0].className,\n        };\n      case 'Batch':\n        return getObjectType(obj.ops[0]);\n      default:\n        throw 'unexpected op: ' + obj.__op;\n    }\n  }\n  return 'Object';\n}\n\nexport {\n  load,\n  classNameIsValid,\n  fieldNameIsValid,\n  invalidClassNameMessage,\n  buildMergedSchemaObject,\n  systemClasses,\n  defaultColumns,\n  convertSchemaToAdapterSchema,\n  VolatileClassesSchemas,\n  SchemaController,\n};\n"],"file":"SchemaController.js"}