{"version":3,"sources":["../src/rest.js"],"names":["Parse","require","RestQuery","RestWrite","triggers","checkTriggers","className","config","types","some","triggerType","getTrigger","Types","applicationId","checkLiveQuery","liveQueryController","hasLiveQuery","find","auth","restWhere","restOptions","clientSDK","context","enforceRoleSecurity","maybeRunQueryTrigger","beforeFind","then","result","query","execute","get","objectId","del","Error","INVALID_JSON","isUnauthenticated","SESSION_MISSING","inflatedObject","schemaController","Promise","resolve","hasTriggers","op","response","results","length","firstResult","isMaster","user","id","INVALID_SESSION_TOKEN","cacheAdapter","cacheController","sessionToken","Object","fromJSON","maybeRunTrigger","beforeDelete","OBJECT_NOT_FOUND","getUserRoles","database","loadSchema","s","options","acl","push","concat","userRoles","destroy","perms","getClassLevelPermissions","onAfterDelete","afterDelete","catch","error","handleSessionMissingError","create","restObject","write","update","undefined","originalRestObject","code","classesWithMasterOnlyAccess","method","OPERATION_FORBIDDEN","indexOf","isReadOnly","module","exports"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,YAAD,CAAP,CAAsBD,KAAlC;;AAEA,IAAIE,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,YAAD,CAAtB;;AAEA,SAASI,aAAT,CAAuBC,SAAvB,EAAkCC,MAAlC,EAA0CC,KAA1C,EAAiD;AAC/C,SAAOA,KAAK,CAACC,IAAN,CAAWC,WAAW,IAAI;AAC/B,WAAON,QAAQ,CAACO,UAAT,CAAoBL,SAApB,EAA+BF,QAAQ,CAACQ,KAAT,CAAeF,WAAf,CAA/B,EAA4DH,MAAM,CAACM,aAAnE,CAAP;AACD,GAFM,CAAP;AAGD;;AAED,SAASC,cAAT,CAAwBR,SAAxB,EAAmCC,MAAnC,EAA2C;AACzC,SAAOA,MAAM,CAACQ,mBAAP,IAA8BR,MAAM,CAACQ,mBAAP,CAA2BC,YAA3B,CAAwCV,SAAxC,CAArC;AACD,C,CAED;;;AACA,SAASW,IAAT,CAAcV,MAAd,EAAsBW,IAAtB,EAA4BZ,SAA5B,EAAuCa,SAAvC,EAAkDC,WAAlD,EAA+DC,SAA/D,EAA0EC,OAA1E,EAAmF;AACjFC,EAAAA,mBAAmB,CAAC,MAAD,EAASjB,SAAT,EAAoBY,IAApB,CAAnB;AACA,SAAOd,QAAQ,CACZoB,oBADI,CAEHpB,QAAQ,CAACQ,KAAT,CAAea,UAFZ,EAGHnB,SAHG,EAIHa,SAJG,EAKHC,WALG,EAMHb,MANG,EAOHW,IAPG,EAQHI,OARG,EAUJI,IAVI,CAUCC,MAAM,IAAI;AACdR,IAAAA,SAAS,GAAGQ,MAAM,CAACR,SAAP,IAAoBA,SAAhC;AACAC,IAAAA,WAAW,GAAGO,MAAM,CAACP,WAAP,IAAsBA,WAApC;AACA,UAAMQ,KAAK,GAAG,IAAI1B,SAAJ,CACZK,MADY,EAEZW,IAFY,EAGZZ,SAHY,EAIZa,SAJY,EAKZC,WALY,EAMZC,SANY,EAOZ,IAPY,EAQZC,OARY,CAAd;AAUA,WAAOM,KAAK,CAACC,OAAN,EAAP;AACD,GAxBI,CAAP;AAyBD,C,CAED;;;AACA,MAAMC,GAAG,GAAG,CAACvB,MAAD,EAASW,IAAT,EAAeZ,SAAf,EAA0ByB,QAA1B,EAAoCX,WAApC,EAAiDC,SAAjD,EAA4DC,OAA5D,KAAwE;AAClF,MAAIH,SAAS,GAAG;AAAEY,IAAAA;AAAF,GAAhB;AACAR,EAAAA,mBAAmB,CAAC,KAAD,EAAQjB,SAAR,EAAmBY,IAAnB,CAAnB;AACA,SAAOd,QAAQ,CACZoB,oBADI,CAEHpB,QAAQ,CAACQ,KAAT,CAAea,UAFZ,EAGHnB,SAHG,EAIHa,SAJG,EAKHC,WALG,EAMHb,MANG,EAOHW,IAPG,EAQHI,OARG,EASH,IATG,EAWJI,IAXI,CAWCC,MAAM,IAAI;AACdR,IAAAA,SAAS,GAAGQ,MAAM,CAACR,SAAP,IAAoBA,SAAhC;AACAC,IAAAA,WAAW,GAAGO,MAAM,CAACP,WAAP,IAAsBA,WAApC;AACA,UAAMQ,KAAK,GAAG,IAAI1B,SAAJ,CACZK,MADY,EAEZW,IAFY,EAGZZ,SAHY,EAIZa,SAJY,EAKZC,WALY,EAMZC,SANY,EAOZ,IAPY,EAQZC,OARY,CAAd;AAUA,WAAOM,KAAK,CAACC,OAAN,EAAP;AACD,GAzBI,CAAP;AA0BD,CA7BD,C,CA+BA;;;AACA,SAASG,GAAT,CAAazB,MAAb,EAAqBW,IAArB,EAA2BZ,SAA3B,EAAsCyB,QAAtC,EAAgDT,OAAhD,EAAyD;AACvD,MAAI,OAAOS,QAAP,KAAoB,QAAxB,EAAkC;AAChC,UAAM,IAAI/B,KAAK,CAACiC,KAAV,CAAgBjC,KAAK,CAACiC,KAAN,CAAYC,YAA5B,EAA0C,cAA1C,CAAN;AACD;;AAED,MAAI5B,SAAS,KAAK,OAAd,IAAyBY,IAAI,CAACiB,iBAAL,EAA7B,EAAuD;AACrD,UAAM,IAAInC,KAAK,CAACiC,KAAV,CAAgBjC,KAAK,CAACiC,KAAN,CAAYG,eAA5B,EAA6C,kCAA7C,CAAN;AACD;;AAEDb,EAAAA,mBAAmB,CAAC,QAAD,EAAWjB,SAAX,EAAsBY,IAAtB,CAAnB;AAEA,MAAImB,cAAJ;AACA,MAAIC,gBAAJ;AAEA,SAAOC,OAAO,CAACC,OAAR,GACJd,IADI,CACC,MAAM;AACV,UAAMe,WAAW,GAAGpC,aAAa,CAACC,SAAD,EAAYC,MAAZ,EAAoB,CAAC,cAAD,EAAiB,aAAjB,CAApB,CAAjC;AACA,UAAMS,YAAY,GAAGF,cAAc,CAACR,SAAD,EAAYC,MAAZ,CAAnC;;AACA,QAAIkC,WAAW,IAAIzB,YAAf,IAA+BV,SAAS,IAAI,UAAhD,EAA4D;AAC1D,aAAO,IAAIJ,SAAJ,CAAcK,MAAd,EAAsBW,IAAtB,EAA4BZ,SAA5B,EAAuC;AAAEyB,QAAAA;AAAF,OAAvC,EACJF,OADI,CACI;AAAEa,QAAAA,EAAE,EAAE;AAAN,OADJ,EAEJhB,IAFI,CAECiB,QAAQ,IAAI;AAChB,YAAIA,QAAQ,IAAIA,QAAQ,CAACC,OAArB,IAAgCD,QAAQ,CAACC,OAAT,CAAiBC,MAArD,EAA6D;AAC3D,gBAAMC,WAAW,GAAGH,QAAQ,CAACC,OAAT,CAAiB,CAAjB,CAApB;AACAE,UAAAA,WAAW,CAACxC,SAAZ,GAAwBA,SAAxB;;AACA,cAAIA,SAAS,KAAK,UAAd,IAA4B,CAACY,IAAI,CAAC6B,QAAtC,EAAgD;AAC9C,gBAAI,CAAC7B,IAAI,CAAC8B,IAAN,IAAcF,WAAW,CAACE,IAAZ,CAAiBjB,QAAjB,KAA8Bb,IAAI,CAAC8B,IAAL,CAAUC,EAA1D,EAA8D;AAC5D,oBAAM,IAAIjD,KAAK,CAACiC,KAAV,CAAgBjC,KAAK,CAACiC,KAAN,CAAYiB,qBAA5B,EAAmD,uBAAnD,CAAN;AACD;AACF;;AACD,cAAIC,YAAY,GAAG5C,MAAM,CAAC6C,eAA1B;AACAD,UAAAA,YAAY,CAACH,IAAb,CAAkBhB,GAAlB,CAAsBc,WAAW,CAACO,YAAlC;AACAhB,UAAAA,cAAc,GAAGrC,KAAK,CAACsD,MAAN,CAAaC,QAAb,CAAsBT,WAAtB,CAAjB;AACA,iBAAO1C,QAAQ,CAACoD,eAAT,CACLpD,QAAQ,CAACQ,KAAT,CAAe6C,YADV,EAELvC,IAFK,EAGLmB,cAHK,EAIL,IAJK,EAKL9B,MALK,EAMLe,OANK,CAAP;AAQD;;AACD,cAAM,IAAItB,KAAK,CAACiC,KAAV,CAAgBjC,KAAK,CAACiC,KAAN,CAAYyB,gBAA5B,EAA8C,8BAA9C,CAAN;AACD,OAxBI,CAAP;AAyBD;;AACD,WAAOnB,OAAO,CAACC,OAAR,CAAgB,EAAhB,CAAP;AACD,GAhCI,EAiCJd,IAjCI,CAiCC,MAAM;AACV,QAAI,CAACR,IAAI,CAAC6B,QAAV,EAAoB;AAClB,aAAO7B,IAAI,CAACyC,YAAL,EAAP;AACD,KAFD,MAEO;AACL;AACD;AACF,GAvCI,EAwCJjC,IAxCI,CAwCC,MAAMnB,MAAM,CAACqD,QAAP,CAAgBC,UAAhB,EAxCP,EAyCJnC,IAzCI,CAyCCoC,CAAC,IAAI;AACTxB,IAAAA,gBAAgB,GAAGwB,CAAnB;AACA,UAAMC,OAAO,GAAG,EAAhB;;AACA,QAAI,CAAC7C,IAAI,CAAC6B,QAAV,EAAoB;AAClBgB,MAAAA,OAAO,CAACC,GAAR,GAAc,CAAC,GAAD,CAAd;;AACA,UAAI9C,IAAI,CAAC8B,IAAT,EAAe;AACbe,QAAAA,OAAO,CAACC,GAAR,CAAYC,IAAZ,CAAiB/C,IAAI,CAAC8B,IAAL,CAAUC,EAA3B;AACAc,QAAAA,OAAO,CAACC,GAAR,GAAcD,OAAO,CAACC,GAAR,CAAYE,MAAZ,CAAmBhD,IAAI,CAACiD,SAAxB,CAAd;AACD;AACF;;AAED,WAAO5D,MAAM,CAACqD,QAAP,CAAgBQ,OAAhB,CACL9D,SADK,EAEL;AACEyB,MAAAA,QAAQ,EAAEA;AADZ,KAFK,EAKLgC,OALK,EAMLzB,gBANK,CAAP;AAQD,GA5DI,EA6DJZ,IA7DI,CA6DC,MAAM;AACV;AACA,UAAM2C,KAAK,GAAG/B,gBAAgB,CAACgC,wBAAjB,CAA0ChE,SAA1C,CAAd;AACAC,IAAAA,MAAM,CAACQ,mBAAP,CAA2BwD,aAA3B,CAAyCjE,SAAzC,EAAoD+B,cAApD,EAAoE,IAApE,EAA0EgC,KAA1E;AACA,WAAOjE,QAAQ,CAACoD,eAAT,CACLpD,QAAQ,CAACQ,KAAT,CAAe4D,WADV,EAELtD,IAFK,EAGLmB,cAHK,EAIL,IAJK,EAKL9B,MALK,EAMLe,OANK,CAAP;AAQD,GAzEI,EA0EJmD,KA1EI,CA0EEC,KAAK,IAAI;AACdC,IAAAA,yBAAyB,CAACD,KAAD,EAAQpE,SAAR,EAAmBY,IAAnB,CAAzB;AACD,GA5EI,CAAP;AA6ED,C,CAED;;;AACA,SAAS0D,MAAT,CAAgBrE,MAAhB,EAAwBW,IAAxB,EAA8BZ,SAA9B,EAAyCuE,UAAzC,EAAqDxD,SAArD,EAAgEC,OAAhE,EAAyE;AACvEC,EAAAA,mBAAmB,CAAC,QAAD,EAAWjB,SAAX,EAAsBY,IAAtB,CAAnB;AACA,MAAI4D,KAAK,GAAG,IAAI3E,SAAJ,CAAcI,MAAd,EAAsBW,IAAtB,EAA4BZ,SAA5B,EAAuC,IAAvC,EAA6CuE,UAA7C,EAAyD,IAAzD,EAA+DxD,SAA/D,EAA0EC,OAA1E,CAAZ;AACA,SAAOwD,KAAK,CAACjD,OAAN,EAAP;AACD,C,CAED;AACA;AACA;;;AACA,SAASkD,MAAT,CAAgBxE,MAAhB,EAAwBW,IAAxB,EAA8BZ,SAA9B,EAAyCa,SAAzC,EAAoD0D,UAApD,EAAgExD,SAAhE,EAA2EC,OAA3E,EAAoF;AAClFC,EAAAA,mBAAmB,CAAC,QAAD,EAAWjB,SAAX,EAAsBY,IAAtB,CAAnB;AAEA,SAAOqB,OAAO,CAACC,OAAR,GACJd,IADI,CACC,MAAM;AACV,UAAMe,WAAW,GAAGpC,aAAa,CAACC,SAAD,EAAYC,MAAZ,EAAoB,CAAC,YAAD,EAAe,WAAf,CAApB,CAAjC;AACA,UAAMS,YAAY,GAAGF,cAAc,CAACR,SAAD,EAAYC,MAAZ,CAAnC;;AACA,QAAIkC,WAAW,IAAIzB,YAAnB,EAAiC;AAC/B;AACA,aAAO,IAAId,SAAJ,CACLK,MADK,EAELW,IAFK,EAGLZ,SAHK,EAILa,SAJK,EAKL6D,SALK,EAMLA,SANK,EAOL,KAPK,EAQL1D,OARK,EASLO,OATK,CASG;AACRa,QAAAA,EAAE,EAAE;AADI,OATH,CAAP;AAYD;;AACD,WAAOH,OAAO,CAACC,OAAR,CAAgB,EAAhB,CAAP;AACD,GApBI,EAqBJd,IArBI,CAqBC,CAAC;AAAEkB,IAAAA;AAAF,GAAD,KAAiB;AACrB,QAAIqC,kBAAJ;;AACA,QAAIrC,OAAO,IAAIA,OAAO,CAACC,MAAvB,EAA+B;AAC7BoC,MAAAA,kBAAkB,GAAGrC,OAAO,CAAC,CAAD,CAA5B;AACD;;AACD,WAAO,IAAIzC,SAAJ,CACLI,MADK,EAELW,IAFK,EAGLZ,SAHK,EAILa,SAJK,EAKL0D,UALK,EAMLI,kBANK,EAOL5D,SAPK,EAQLC,OARK,EASL,QATK,EAULO,OAVK,EAAP;AAWD,GArCI,EAsCJ4C,KAtCI,CAsCEC,KAAK,IAAI;AACdC,IAAAA,yBAAyB,CAACD,KAAD,EAAQpE,SAAR,EAAmBY,IAAnB,CAAzB;AACD,GAxCI,CAAP;AAyCD;;AAED,SAASyD,yBAAT,CAAmCD,KAAnC,EAA0CpE,SAA1C,EAAqDY,IAArD,EAA2D;AACzD;AACA,MAAIZ,SAAS,KAAK,OAAd,IAAyBoE,KAAK,CAACQ,IAAN,KAAelF,KAAK,CAACiC,KAAN,CAAYyB,gBAApD,IAAwE,CAACxC,IAAI,CAAC6B,QAAlF,EAA4F;AAC1F,UAAM,IAAI/C,KAAK,CAACiC,KAAV,CAAgBjC,KAAK,CAACiC,KAAN,CAAYG,eAA5B,EAA6C,oBAA7C,CAAN;AACD;;AACD,QAAMsC,KAAN;AACD;;AAED,MAAMS,2BAA2B,GAAG,CAClC,YADkC,EAElC,aAFkC,EAGlC,QAHkC,EAIlC,eAJkC,EAKlC,cALkC,EAMlC,cANkC,CAApC,C,CAQA;;AACA,SAAS5D,mBAAT,CAA6B6D,MAA7B,EAAqC9E,SAArC,EAAgDY,IAAhD,EAAsD;AACpD,MAAIZ,SAAS,KAAK,eAAd,IAAiC,CAACY,IAAI,CAAC6B,QAA3C,EAAqD;AACnD,QAAIqC,MAAM,KAAK,QAAX,IAAuBA,MAAM,KAAK,MAAtC,EAA8C;AAC5C,YAAMV,KAAK,GAAI,yCAAwCU,MAAO,4CAA9D;AACA,YAAM,IAAIpF,KAAK,CAACiC,KAAV,CAAgBjC,KAAK,CAACiC,KAAN,CAAYoD,mBAA5B,EAAiDX,KAAjD,CAAN;AACD;AACF,GANmD,CAQpD;;;AACA,MAAIS,2BAA2B,CAACG,OAA5B,CAAoChF,SAApC,KAAkD,CAAlD,IAAuD,CAACY,IAAI,CAAC6B,QAAjE,EAA2E;AACzE,UAAM2B,KAAK,GAAI,yCAAwCU,MAAO,qBAAoB9E,SAAU,cAA5F;AACA,UAAM,IAAIN,KAAK,CAACiC,KAAV,CAAgBjC,KAAK,CAACiC,KAAN,CAAYoD,mBAA5B,EAAiDX,KAAjD,CAAN;AACD,GAZmD,CAcpD;;;AACA,MAAIxD,IAAI,CAACqE,UAAL,KAAoBH,MAAM,KAAK,QAAX,IAAuBA,MAAM,KAAK,QAAlC,IAA8CA,MAAM,KAAK,QAA7E,CAAJ,EAA4F;AAC1F,UAAMV,KAAK,GAAI,oDAAmDU,MAAO,aAAzE;AACA,UAAM,IAAIpF,KAAK,CAACiC,KAAV,CAAgBjC,KAAK,CAACiC,KAAN,CAAYoD,mBAA5B,EAAiDX,KAAjD,CAAN;AACD;AACF;;AAEDc,MAAM,CAACC,OAAP,GAAiB;AACfb,EAAAA,MADe;AAEf5C,EAAAA,GAFe;AAGff,EAAAA,IAHe;AAIfa,EAAAA,GAJe;AAKfiD,EAAAA;AALe,CAAjB","sourcesContent":["// This file contains helpers for running operations in REST format.\n// The goal is that handlers that explicitly handle an express route\n// should just be shallow wrappers around things in this file, but\n// these functions should not explicitly depend on the request\n// object.\n// This means that one of these handlers can support multiple\n// routes. That's useful for the routes that do really similar\n// things.\n\nvar Parse = require('parse/node').Parse;\n\nvar RestQuery = require('./RestQuery');\nvar RestWrite = require('./RestWrite');\nvar triggers = require('./triggers');\n\nfunction checkTriggers(className, config, types) {\n  return types.some(triggerType => {\n    return triggers.getTrigger(className, triggers.Types[triggerType], config.applicationId);\n  });\n}\n\nfunction checkLiveQuery(className, config) {\n  return config.liveQueryController && config.liveQueryController.hasLiveQuery(className);\n}\n\n// Returns a promise for an object with optional keys 'results' and 'count'.\nfunction find(config, auth, className, restWhere, restOptions, clientSDK, context) {\n  enforceRoleSecurity('find', className, auth);\n  return triggers\n    .maybeRunQueryTrigger(\n      triggers.Types.beforeFind,\n      className,\n      restWhere,\n      restOptions,\n      config,\n      auth,\n      context\n    )\n    .then(result => {\n      restWhere = result.restWhere || restWhere;\n      restOptions = result.restOptions || restOptions;\n      const query = new RestQuery(\n        config,\n        auth,\n        className,\n        restWhere,\n        restOptions,\n        clientSDK,\n        true,\n        context\n      );\n      return query.execute();\n    });\n}\n\n// get is just like find but only queries an objectId.\nconst get = (config, auth, className, objectId, restOptions, clientSDK, context) => {\n  var restWhere = { objectId };\n  enforceRoleSecurity('get', className, auth);\n  return triggers\n    .maybeRunQueryTrigger(\n      triggers.Types.beforeFind,\n      className,\n      restWhere,\n      restOptions,\n      config,\n      auth,\n      context,\n      true\n    )\n    .then(result => {\n      restWhere = result.restWhere || restWhere;\n      restOptions = result.restOptions || restOptions;\n      const query = new RestQuery(\n        config,\n        auth,\n        className,\n        restWhere,\n        restOptions,\n        clientSDK,\n        true,\n        context\n      );\n      return query.execute();\n    });\n};\n\n// Returns a promise that doesn't resolve to any useful value.\nfunction del(config, auth, className, objectId, context) {\n  if (typeof objectId !== 'string') {\n    throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad objectId');\n  }\n\n  if (className === '_User' && auth.isUnauthenticated()) {\n    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'Insufficient auth to delete user');\n  }\n\n  enforceRoleSecurity('delete', className, auth);\n\n  let inflatedObject;\n  let schemaController;\n\n  return Promise.resolve()\n    .then(() => {\n      const hasTriggers = checkTriggers(className, config, ['beforeDelete', 'afterDelete']);\n      const hasLiveQuery = checkLiveQuery(className, config);\n      if (hasTriggers || hasLiveQuery || className == '_Session') {\n        return new RestQuery(config, auth, className, { objectId })\n          .execute({ op: 'delete' })\n          .then(response => {\n            if (response && response.results && response.results.length) {\n              const firstResult = response.results[0];\n              firstResult.className = className;\n              if (className === '_Session' && !auth.isMaster) {\n                if (!auth.user || firstResult.user.objectId !== auth.user.id) {\n                  throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');\n                }\n              }\n              var cacheAdapter = config.cacheController;\n              cacheAdapter.user.del(firstResult.sessionToken);\n              inflatedObject = Parse.Object.fromJSON(firstResult);\n              return triggers.maybeRunTrigger(\n                triggers.Types.beforeDelete,\n                auth,\n                inflatedObject,\n                null,\n                config,\n                context\n              );\n            }\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for delete.');\n          });\n      }\n      return Promise.resolve({});\n    })\n    .then(() => {\n      if (!auth.isMaster) {\n        return auth.getUserRoles();\n      } else {\n        return;\n      }\n    })\n    .then(() => config.database.loadSchema())\n    .then(s => {\n      schemaController = s;\n      const options = {};\n      if (!auth.isMaster) {\n        options.acl = ['*'];\n        if (auth.user) {\n          options.acl.push(auth.user.id);\n          options.acl = options.acl.concat(auth.userRoles);\n        }\n      }\n\n      return config.database.destroy(\n        className,\n        {\n          objectId: objectId,\n        },\n        options,\n        schemaController\n      );\n    })\n    .then(() => {\n      // Notify LiveQuery server if possible\n      const perms = schemaController.getClassLevelPermissions(className);\n      config.liveQueryController.onAfterDelete(className, inflatedObject, null, perms);\n      return triggers.maybeRunTrigger(\n        triggers.Types.afterDelete,\n        auth,\n        inflatedObject,\n        null,\n        config,\n        context\n      );\n    })\n    .catch(error => {\n      handleSessionMissingError(error, className, auth);\n    });\n}\n\n// Returns a promise for a {response, status, location} object.\nfunction create(config, auth, className, restObject, clientSDK, context) {\n  enforceRoleSecurity('create', className, auth);\n  var write = new RestWrite(config, auth, className, null, restObject, null, clientSDK, context);\n  return write.execute();\n}\n\n// Returns a promise that contains the fields of the update that the\n// REST API is supposed to return.\n// Usually, this is just updatedAt.\nfunction update(config, auth, className, restWhere, restObject, clientSDK, context) {\n  enforceRoleSecurity('update', className, auth);\n\n  return Promise.resolve()\n    .then(() => {\n      const hasTriggers = checkTriggers(className, config, ['beforeSave', 'afterSave']);\n      const hasLiveQuery = checkLiveQuery(className, config);\n      if (hasTriggers || hasLiveQuery) {\n        // Do not use find, as it runs the before finds\n        return new RestQuery(\n          config,\n          auth,\n          className,\n          restWhere,\n          undefined,\n          undefined,\n          false,\n          context\n        ).execute({\n          op: 'update',\n        });\n      }\n      return Promise.resolve({});\n    })\n    .then(({ results }) => {\n      var originalRestObject;\n      if (results && results.length) {\n        originalRestObject = results[0];\n      }\n      return new RestWrite(\n        config,\n        auth,\n        className,\n        restWhere,\n        restObject,\n        originalRestObject,\n        clientSDK,\n        context,\n        'update'\n      ).execute();\n    })\n    .catch(error => {\n      handleSessionMissingError(error, className, auth);\n    });\n}\n\nfunction handleSessionMissingError(error, className, auth) {\n  // If we're trying to update a user without / with bad session token\n  if (className === '_User' && error.code === Parse.Error.OBJECT_NOT_FOUND && !auth.isMaster) {\n    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'Insufficient auth.');\n  }\n  throw error;\n}\n\nconst classesWithMasterOnlyAccess = [\n  '_JobStatus',\n  '_PushStatus',\n  '_Hooks',\n  '_GlobalConfig',\n  '_JobSchedule',\n  '_Idempotency',\n];\n// Disallowing access to the _Role collection except by master key\nfunction enforceRoleSecurity(method, className, auth) {\n  if (className === '_Installation' && !auth.isMaster) {\n    if (method === 'delete' || method === 'find') {\n      const error = `Clients aren't allowed to perform the ${method} operation on the installation collection.`;\n      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n    }\n  }\n\n  //all volatileClasses are masterKey only\n  if (classesWithMasterOnlyAccess.indexOf(className) >= 0 && !auth.isMaster) {\n    const error = `Clients aren't allowed to perform the ${method} operation on the ${className} collection.`;\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n  }\n\n  // readOnly masterKey is not allowed\n  if (auth.isReadOnly && (method === 'delete' || method === 'create' || method === 'update')) {\n    const error = `read-only masterKey isn't allowed to perform the ${method} operation.`;\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n  }\n}\n\nmodule.exports = {\n  create,\n  del,\n  find,\n  get,\n  update,\n};\n"],"file":"rest.js"}